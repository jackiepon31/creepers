!
function(t, e) {
    "function" == typeof define && define.amd ? define([], e) : "object" == typeof module && module.exports ? module.exports = e() : t.echarts = e()
} (this,
function() {
    var t, e; !
    function() {
        function i(t, e) {
            if (!e) return t;
            if (0 === t.indexOf(".")) {
                var i = e.split("/"),
                n = t.split("/"),
                r = i.length - 1,
                a = n.length,
                o = 0,
                s = 0;
                t: for (var l = 0; a > l; l++) switch (n[l]) {
                case "..":
                    if (! (r > o)) break t;
                    o++,
                    s++;
                    break;
                case ".":
                    s++;
                    break;
                default:
                    break t
                }
                return i.length = r - o,
                n = n.slice(s),
                i.concat(n).join("/")
            }
            return t
        }
        function n(t) {
            function e(e, o) {
                if ("string" == typeof e) {
                    var s = n[e];
                    return s || (s = a(i(e, t)), n[e] = s),
                    s
                }
                e instanceof Array && (o = o ||
                function() {},
                o.apply(this, r(e, o, t)))
            }
            var n = {};
            return e
        }
        function r(e, n, r) {
            for (var s = [], l = o[r], u = 0, c = Math.min(e.length, n.length); c > u; u++) {
                var h, d = i(e[u], r);
                switch (d) {
                case "require":
                    h = l && l.require || t;
                    break;
                case "exports":
                    h = l.exports;
                    break;
                case "module":
                    h = l;
                    break;
                default:
                    h = a(d)
                }
                s.push(h)
            }
            return s
        }
        function a(t) {
            var e = o[t];
            if (!e) throw new Error("No " + t);
            if (!e.defined) {
                var i = e.factory,
                n = i.apply(this, r(e.deps || [], i, t));
                "undefined" != typeof n && (e.exports = n),
                e.defined = 1
            }
            return e.exports
        }
        var o = {};
        e = function(t, e, i) {
            o[t] = {
                id: t,
                deps: e,
                factory: i,
                defined: 0,
                exports: {},
                require: n(t)
            }
        },
        t = n("")
    } ();
    var i = "updateTransform",
    n = "coordToData",
    r = "../core/util",
    a = "__dirty",
    o = "rotate",
    s = "vertical",
    l = "orient",
    u = "axisName",
    c = "../../model/Component",
    h = "closePath",
    d = "lineTo",
    f = "bezierCurveTo",
    p = "moveTo",
    v = "formatter",
    g = "axisLabel",
    m = "axisTick",
    y = "splitLine",
    x = "axisLine",
    _ = "offsetY",
    w = "offsetX",
    b = "linear",
    M = "invisible",
    S = "reverse",
    A = "parentNode",
    T = "rectProvider",
    C = "eachNode",
    L = "draggable",
    k = "transform",
    P = "createSymbol",
    I = "../../util/symbol",
    D = "polarIndex",
    z = "points",
    V = "getAreaStyle",
    R = "interval",
    O = "horizontal",
    E = "layout",
    N = "borderColor",
    B = "dataToCoord",
    G = "../../util/format",
    H = "itemStyle.emphasis",
    F = "itemStyle.normal",
    Z = "textPosition",
    W = "../../model/Model",
    q = "cartesian2d",
    U = "toGlobalCoord",
    j = "coordDimToDataDim",
    X = "boundaryGap",
    Y = "onBand",
    $ = "createScaleByModel",
    J = "getAxis",
    Q = "inverse",
    K = "isHorizontal",
    te = "category",
    ee = "getFormattedLabels",
    ie = "niceScaleExtent",
    ne = "../../CoordinateSystem",
    re = "../../util/layout",
    ae = "dataToPoint",
    oe = "symbolSize",
    se = "symbol",
    le = "../../model/Series",
    ue = "setLayout",
    ce = "getVisual",
    he = "mapArray",
    de = "dimensions",
    fe = "hasItemOption",
    pe = "parent",
    ve = "getLocalTransform",
    ge = "distance",
    me = "setText",
    ye = "stroke",
    xe = "lineWidth",
    _e = "applyTransform",
    we = "Polygon",
    be = "Circle",
    Me = "zrender/core/BoundingRect",
    Se = "eachItemGraphicEl",
    Ae = "indexOfName",
    Te = "ecModel",
    Ce = "getShallow",
    Le = "<br />",
    ke = "getRawValue",
    Pe = "ordinal",
    Ie = "getBaseAxis",
    De = "mergeDefaultAndTheme",
    ze = "addCommas",
    Ve = "encodeHTML",
    Re = "getComponent",
    Oe = "componentIndex",
    Ee = "queryComponents",
    Ne = "mainType",
    Be = "undefined",
    Ge = "linearMap",
    He = "setItemLayout",
    Fe = "getDataExtent",
    Ze = "radius",
    We = "parsePercent",
    qe = "../../util/number",
    Ue = "setItemVisual",
    je = "getRawIndex",
    Xe = "initProps",
    Ye = "clockwise",
    $e = "setItemGraphicEl",
    Je = "eachChild",
    Qe = "execute",
    Ke = "lineStyle",
    ti = "getLineStyle",
    ei = "label.emphasis",
    ii = "label.normal",
    ni = "rotation",
    ri = "setHoverStyle",
    ai = "selected",
    oi = "hoverStyle",
    si = "useStyle",
    li = "itemStyle",
    ui = "updateProps",
    ci = "setShape",
    hi = "getItemModel",
    di = "childAt",
    fi = "hostModel",
    pi = "getFormattedLabel",
    vi = "retrieve",
    gi = "getItemVisual",
    mi = "inside",
    yi = "updateData",
    xi = "Polyline",
    _i = "Sector",
    wi = "animate",
    bi = "getItemLayout",
    Mi = "getItemGraphicEl",
    Si = "../../util/graphic",
    Ai = "concat",
    Ti = "createElement",
    Ci = "getName",
    Li = "emphasis",
    ki = "normal",
    Pi = "defaultEmphasis",
    Ii = "toFixed",
    Di = "initData",
    zi = "option",
    Vi = "mergeOption",
    Ri = "superCall",
    Oi = "superApply",
    Ei = "../../echarts",
    Ni = "../../data/helper/completeDimensions",
    Bi = "../../util/model",
    Gi = "../../data/List",
    Hi = "unionExtent",
    Fi = "getExtent",
    Zi = "setExtent",
    Wi = "getLabel",
    qi = "getTicks",
    Ui = "normalize",
    ji = "contain",
    Xi = "../util/number",
    Yi = "opacity",
    $i = "position",
    Ji = "center",
    Qi = "middle",
    Ki = "getLayoutRect",
    tn = "getBoxLayoutParams",
    en = "getBoundingRect",
    nn = "getTextColor",
    rn = "getFont",
    an = "textAlign",
    on = "textStyle",
    sn = "getItemStyle",
    ln = "coordinateSystem",
    un = "getRect",
    cn = "removeAll",
    hn = "setVisual",
    dn = "eachSeriesByType",
    fn = "circle",
    pn = "isString",
    vn = "inherits",
    gn = "indexOf",
    mn = "filter",
    yn = "number",
    xn = "extendChartView",
    _n = "extendComponentView",
    wn = "extendComponentModel",
    bn = "register",
    Mn = "registerAction",
    Sn = "function",
    An = "isArray",
    Tn = "replace",
    Cn = "zlevel",
    Ln = "setStyle",
    kn = "traverse",
    Pn = "dataType",
    In = "getDataParams",
    Dn = "seriesIndex",
    zn = "dataIndex",
    Vn = "target",
    Rn = "mousemove",
    On = "mouseout",
    En = "mouseover",
    Nn = "silent",
    Bn = "render",
    Gn = "splice",
    Hn = "dispose",
    Fn = "series",
    Zn = "trigger",
    Wn = "length",
    qn = "defaults",
    Un = "dispatchAction",
    jn = "extend",
    Xn = "remove",
    Yn = "isObject",
    $n = "downplay",
    Jn = "highlight",
    Qn = "updateLayout",
    Kn = "getData",
    tr = "eachSeries",
    er = "update",
    ir = "create",
    nr = "height",
    rr = "bottom",
    ar = "ignore",
    or = "eachComponent",
    sr = "stopAnimation",
    lr = "storage",
    ur = "backgroundColor",
    cr = "canvasSupported",
    hr = "getHeight",
    dr = "getWidth",
    fr = "getModel",
    pr = "_model",
    vr = "animation",
    gr = "resize",
    mr = "canvas",
    yr = "string",
    xr = "prototype",
    _r = "toLowerCase",
    wr = "zrender/core/vector",
    br = "zrender/core/matrix",
    Mr = "zrender/tool/color",
    Sr = "zrender/core/env",
    Ar = "zrender/core/util",
    Tr = "require";
    e("echarts/chart/pie", [Tr, Ar, "../echarts", "./pie/PieSeries", "./pie/PieView", "../action/createDataSelectAction", "../visual/dataColor", "./pie/pieLayout", "../processor/dataFilter"],
    function(t) {
        var e = t(Ar),
        i = t("../echarts");
        t("./pie/PieSeries"),
        t("./pie/PieView"),
        t("../action/createDataSelectAction")("pie", [{
            type: "pieToggleSelect",
            event: "pieselectchanged",
            method: "toggleSelected"
        },
        {
            type: "pieSelect",
            event: "pieselected",
            method: "select"
        },
        {
            type: "pieUnSelect",
            event: "pieunselected",
            method: "unSelect"
        }]),
        i.registerVisual(e.curry(t("../visual/dataColor"), "pie")),
        i.registerLayout(e.curry(t("./pie/pieLayout"), "pie")),
        i.registerProcessor(e.curry(t("../processor/dataFilter"), "pie"))
    }),
    e("echarts/echarts", [Tr, Sr, "./model/Global", "./ExtensionAPI", "./CoordinateSystem", "./model/OptionManager", "./model/Component", "./model/Series", "./view/Component", "./view/Chart", "./util/graphic", "zrender", Ar, Mr, "zrender/mixin/Eventful", "zrender/core/timsort", "./visual/seriesColor", "./preprocessor/backwardCompat", "./loading/default", "./data/List", "./model/Model", "./util/number", "./util/format", br, wr],
    function(t) {
        function e(t) {
            return function(e, i, n) {
                e = e && e[_r](),
                k[xr][t].call(this, e, i, n)
            }
        }
        function i() {
            k.call(this)
        }
        function n(t, e, n) {
            function r(t, e) {
                return t.prio - e.prio
            }
            n = n || {},
            typeof e === yr && (e = $[e]),
            this.id,
            this.group,
            this._dom = t,
            this._zr = T.init(t, {
                renderer: n.renderer || mr,
                devicePixelRatio: n.devicePixelRatio
            }),
            this._theme = C.clone(e),
            this._chartsViews = [],
            this._chartsMap = {},
            this._componentsViews = [],
            this._componentsMap = {},
            this._api = new y(this),
            this._coordSysMgr = new x,
            k.call(this),
            this._messageCenter = new i,
            this._initEvents(),
            this[gr] = C.bind(this[gr], this),
            this._pendingActions = [],
            P(Y, r),
            P(j, r),
            this._zr[vr].on("frame", this._onframe, this)
        }
        function r(t, e) {
            var i = this[pr];
            i && i[or]({
                mainType: "series",
                query: e
            },
            function(n) {
                var r = this._chartsMap[n.__viewId];
                r && r.__alive && r[t](n, i, this._api, e)
            },
            this)
        }
        function a(t, e, i) {
            var n = this._api;
            I(this._componentsViews,
            function(r) {
                var a = r.__model;
                r[t](a, e, n, i),
                p(a, r)
            },
            this),
            e[tr](function(r) {
                var a = this._chartsMap[r.__viewId];
                a[t](r, e, n, i),
                p(r, a),
                f(r, a)
            },
            this),
            d(this._zr, e)
        }
        function o(t, e) {
            for (var i = "component" === t,
            n = i ? this._componentsViews: this._chartsViews, r = i ? this._componentsMap: this._chartsMap, a = this._zr, o = 0; o < n[Wn]; o++) n[o].__alive = !1;
            e[i ? or: tr](function(t, o) {
                if (i) {
                    if (t === Fn) return
                } else o = t;
                var s = o.id + "_" + o.type,
                l = r[s];
                if (!l) {
                    var u = w.parseClassType(o.type),
                    c = i ? M.getClass(u.main, u.sub) : S.getClass(u.sub);
                    if (!c) return;
                    l = new c,
                    l.init(e, this._api),
                    r[s] = l,
                    n.push(l),
                    a.add(l.group)
                }
                o.__viewId = s,
                l.__alive = !0,
                l.__id = s,
                l.__model = o
            },
            this);
            for (var o = 0; o < n[Wn];) {
                var s = n[o];
                s.__alive ? o++:(a[Xn](s.group), s[Hn](e, this._api), n[Gn](o, 1), delete r[s.__id])
            }
        }
        function s(t, e) {
            I(j,
            function(i) {
                i.func(t, e)
            })
        }
        function l(t) {
            var e = {};
            t[tr](function(t) {
                var i = t.get("stack"),
                n = t[Kn]();
                if (i && "list" === n.type) {
                    var r = e[i];
                    r && (n.stackedOn = r),
                    e[i] = n
                }
            })
        }
        function u(t, e) {
            var i = this._api;
            I(Y,
            function(n) {
                n.isLayout && n.func(t, i, e)
            })
        }
        function c(t, e) {
            var i = this._api;
            t.clearColorPalette(),
            t[tr](function(t) {
                t.clearColorPalette()
            }),
            I(Y,
            function(n) {
                n.func(t, i, e)
            })
        }
        function h(t, e) {
            var i = this._api;
            I(this._componentsViews,
            function(n) {
                var r = n.__model;
                n[Bn](r, t, i, e),
                p(r, n)
            },
            this),
            I(this._chartsViews,
            function(t) {
                t.__alive = !1
            },
            this),
            t[tr](function(n) {
                var r = this._chartsMap[n.__viewId];
                r.__alive = !0,
                r[Bn](n, t, i, e),
                r.group[Nn] = !!n.get(Nn),
                p(n, r),
                f(n, r)
            },
            this),
            d(this._zr, t),
            I(this._chartsViews,
            function(e) {
                e.__alive || e[Xn](t, i)
            },
            this)
        }
        function d(t, e) {
            var i = t[lr],
            n = 0;
            i[kn](function(t) {
                t.isGroup || n++
            }),
            n > e.get("hoverLayerThreshold") && !g.node && i[kn](function(t) {
                t.isGroup || (t.useHoverLayer = !0)
            })
        }
        function f(t, e) {
            var i = 0;
            e.group[kn](function(t) {
                "group" === t.type || t[ar] || i++
            });
            var n = +t.get("progressive"),
            r = i > t.get("progressiveThreshold") && n && !g.node;
            r && e.group[kn](function(t) {
                t.isGroup || (t.progressive = r ? Math.floor(i++/n):-1,r&&t[sr](!0))});var a=t.get("blendMode")||null;e.group[kn](function(t){t.isGroup||t[Ln]("blend",a)})}function p(t,e){var i=t.get("z"),n=t.get(Cn);e.group[kn](function(t){"group"!==t.type&&(null!=i&&(t.z=i),null!=n&&(t[Cn]=n))})}function v(t){function e(t,e){for(var i=0;i<t[Wn];i++){var n=t[i];n[a]=e}}var i=0,n=1,r=2,a="__connectUpdateStatus";C.each(U,function(o,s){t._messageCenter.on(s,function(o){if(K[t.group]&&t[a]!==i){var s=t.makeActionFromEvent(o),l=[];for(var u in Q){var c=Q[u];c!==t&&c.group===t.group&&l.push(c)}e(l,i),I(l,function(t){t[a]!==n&&t[Un](s)}),e(l,r)}})})}var g=t(Sr),m=t("./model / Global "),y=t(". / ExtensionAPI "),x=t(". / CoordinateSystem "),_=t(". / model / OptionManager "),w=t(". / model / Component "),b=t(". / model / Series "),M=t(". / view / Component "),S=t(". / view / Chart "),A=t(". / util / graphic "),T=t("zrender "),C=t(Ar),L=t(Mr),k=t("zrender / mixin / Eventful "),P=t("zrender / core / timsort "),I=C.each,D=1e3,z=5e3,V=1e3,R=2e3,O=3e3,E=4e3,N=5e3,B="__flag_in_main_process ",G="_hasGradientOrPatternBg ",H="_optionUpdated ";i[xr].on=e("on "),i[xr].off=e("off "),i[xr].one=e("one "),C.mixin(i,k);var F=n[xr];F._onframe=function(){this[H]&&(this[B]=!0,Z.prepareAndUpdate.call(this),this[B]=!1,this[H]=!1)},F.getDom=function(){return this._dom},F.getZr=function(){return this._zr},F.setOption=function(t,e,i){if(this[B]=!0,!this[pr]||e){var n=new _(this._api),r=this._theme,a=this[pr]=new m(null,null,r,n);a.init(null,null,r,n)}this[pr].setOption(t,X),i?this[H]=!0:(Z.prepareAndUpdate.call(this),this._zr.refreshImmediately(),this[H]=!1),this[B]=!1,this._flushPendingActions()},F.setTheme=function(){console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0 ")},F[fr]=function(){return this[pr]},F.getOption=function(){return this[pr]&&this[pr].getOption()},F[dr]=function(){return this._zr[dr]()},F[hr]=function(){return this._zr[hr]()},F.getRenderedCanvas=function(t){if(g[cr]){t=t||{},t.pixelRatio=t.pixelRatio||1,t[ur]=t[ur]||this[pr].get(ur);var e=this._zr,i=e[lr].getDisplayList();return C.each(i,function(t){t[sr](!0)}),e.painter.getRenderedCanvas(t)}},F.getDataURL=function(t){t=t||{};var e=t.excludeComponents,i=this[pr],n=[],r=this;I(e,function(t){i[or]({mainType:t},function(t){var e=r._componentsMap[t.__viewId];e.group[ar]||(n.push(e),e.group[ar]=!0)})});var a=this.getRenderedCanvas(t).toDataURL("image / "+(t&&t.type||"png "));return I(n,function(t){t.group[ar]=!1}),a},F.getConnectedDataURL=function(t){if(g[cr]){var e=this.group,i=Math.min,n=Math.max,r=1/0;if(K[e]){var a=r,o=r,s=-r,l=-r,u=[],c=t&&t.pixelRatio||1;for(var h in Q){var d=Q[h];if(d.group===e){var f=d.getRenderedCanvas(C.clone(t)),p=d.getDom().getBoundingClientRect();a=i(p.left,a),o=i(p.top,o),s=n(p.right,s),l=n(p[rr],l),u.push({dom:f,left:p.left,top:p.top})}}a*=c,o*=c,s*=c,l*=c;var v=s-a,m=l-o,y=C.createCanvas();y.width=v,y[nr]=m;var x=T.init(y);return I(u,function(t){var e=new A.Image({style:{x:t.left*c-a,y:t.top*c-o,image:t.dom}});x.add(e)}),x.refreshImmediately(),y.toDataURL("image / "+(t&&t.type||"png "))}return this.getDataURL(t)}};var Z={update:function(t){var e=this[pr],i=this._api,n=this._coordSysMgr,r=this._zr;if(e){e.restoreData(),n[ir](this[pr],this._api),s.call(this,e,i),l.call(this,e),n[er](e,i),c.call(this,e,t),h.call(this,e,t);var a=e.get(ur)||"transparent ",o=r.painter;if(o.isSingleCanvas&&o.isSingleCanvas())r.configLayer(0,{clearColor:a});else{if(!g[cr]){var u=L.parse(a);a=L.stringify(u,"rgb "),0===u[3]&&(a="transparent ")}a.colorStops||a.image?(r.configLayer(0,{clearColor:a}),this[G]=!0,this._dom.style.background="transparent "):(this[G]&&r.configLayer(0,{clearColor:null}),this[G]=!1,this._dom.style.background=a)}}},updateView:function(t){var e=this[pr];e&&(e[tr](function(t){t[Kn]().clearAllVisual()}),c.call(this,e,t),a.call(this,"updateView ",e,t))},updateVisual:function(t){var e=this[pr];e&&(e[tr](function(t){t[Kn]().clearAllVisual()}),c.call(this,e,t),a.call(this,"updateVisual ",e,t))},updateLayout:function(t){var e=this[pr];e&&(u.call(this,e,t),a.call(this,Qn,e,t))},highlight:function(t){r.call(this,Jn,t)},downplay:function(t){r.call(this,$n,t)},prepareAndUpdate:function(t){var e=this[pr];o.call(this,"component ",e),o.call(this,"chart ",e),Z[er].call(this,t)}};F[gr]=function(){this[B]=!0,this._zr[gr]();var t=this[pr]&&this[pr].resetOption("media ");Z[t?"prepareAndUpdate ":er].call(this),this._loadingFX&&this._loadingFX[gr](),this[B]=!1,this._flushPendingActions()},F.showLoading=function(t,e){if(C[Yn](t)&&(e=t,t=""),t=t||"
            default ",this.hideLoading(),J[t]){var i=J[t](this._api,e),n=this._zr;this._loadingFX=i,n.add(i)}},F.hideLoading=function(){this._loadingFX&&this._zr[Xn](this._loadingFX),this._loadingFX=null},F.makeActionFromEvent=function(t){var e=C[jn]({},t);return e.type=U[t.type],e},F[Un]=function(t,e){var i=q[t.type];if(i){var n=i.actionInfo,r=n[er]||er;if(this[B])return void this._pendingActions.push(t);this[B]=!0;var a=[t],o=!1;t.batch&&(o=!0,a=C.map(t.batch,function(e){return e=C[qn](C[jn]({},e),t),e.batch=null,e}));for(var s,l=[],u=t.type===Jn||t.type===$n,c=0;c<a[Wn];c++){var h=a[c];s=i.action(h,this[pr]),s=s||C[jn]({},h),s.type=n.event||s.type,l.push(s),u&&Z[r].call(this,h)}"none "===r||u||(this[H]?(Z.prepareAndUpdate.call(this,t),this[H]=!1):Z[r].call(this,t)),s=o?{type:n.event||t.type,batch:l}:l[0],this[B]=!1,!e&&this._messageCenter[Zn](s.type,s),this._flushPendingActions()}},F._flushPendingActions=function(){for(var t=this._pendingActions;t[Wn];){var e=t.shift();this[Un](e)}},F.on=e("on "),F.off=e("off "),F.one=e("one ");var W=["click ","dblclick ",En,On,Rn,"mousedown ","mouseup ","globalout "];F._initEvents=function(){I(W,function(t){this._zr.on(t,function(e){var i=this[fr](),n=e[Vn];if(n&&null!=n[zn]){var r=n.dataModel||i.getSeriesByIndex(n[Dn]),a=r&&r[In](n[zn],n[Pn])||{};a.event=e,a.type=t,this[Zn](t,a)}else n&&n.eventData&&this[Zn](t,n.eventData)},this)},this),I(U,function(t,e){this._messageCenter.on(e,function(t){this[Zn](e,t)},this)},this)},F.isDisposed=function(){return this._disposed},F.clear=function(){this.setOption({series:[]},!0)},F[Hn]=function(){if(!this._disposed){this._disposed=!0;var t=this._api,e=this[pr];I(this._componentsViews,function(i){i[Hn](e,t)}),I(this._chartsViews,function(i){i[Hn](e,t)}),this._zr[Hn](),delete Q[this.id]}},C.mixin(n,k);var q=[],U={},j=[],X=[],Y=[],$={},J={},Q={},K={},te=new Date-0,ee=new Date-0,ie="_echarts_instance_ ",ne={version:"3.2.3 ",dependencies:{zrender:"3.1.3 "}};ne.init=function(t,e,i){var r=new n(t,e,i);return r.id="ec_ "+te++,Q[r.id]=r,t.setAttribute&&t.setAttribute(ie,r.id),v(r),r},ne.connect=function(t){if(C[An](t)){var e=t;t=null,C.each(e,function(e){null!=e.group&&(t=e.group)}),t=t||"g_ "+ee++,C.each(e,function(e){e.group=t})}return K[t]=!0,t},ne.disConnect=function(t){K[t]=!1},ne[Hn]=function(t){C.isDom(t)?t=ne.getInstanceByDom(t):typeof t===yr&&(t=Q[t]),t instanceof n&&!t.isDisposed()&&t[Hn]()},ne.getInstanceByDom=function(t){var e=t.getAttribute(ie);return Q[e]},ne.getInstanceById=function(t){return Q[t]},ne.registerTheme=function(t,e){$[t]=e},ne.registerPreprocessor=function(t){X.push(t)},ne.registerProcessor=function(t,e){typeof t===Sn&&(e=t,t=D),j.push({prio:t,func:e})},ne[Mn]=function(t,e,i){typeof e===Sn&&(i=e,e="");var n=C[Yn](t)?t.type:[t,t={event:e}][0];t.event=(t.event||n)[_r](),e=t.event,q[n]||(q[n]={action:i,actionInfo:t}),U[e]=n},ne.registerCoordinateSystem=function(t,e){x[bn](t,e)},ne.registerLayout=function(t,e){typeof t===Sn&&(e=t,t=V),Y.push({prio:t,func:e,isLayout:!0})},ne.registerVisual=function(t,e){typeof t===Sn&&(e=t,t=O),Y.push({prio:t,func:e})},ne.registerLoading=function(t,e){J[t]=e};var re=w.parseClassType;return ne[wn]=function(t,e){var i=w;if(e){var n=re(e);i=w.getClass(n.main,n.sub,!0)}return i[jn](t)},ne[_n]=function(t,e){var i=M;if(e){var n=re(e);i=M.getClass(n.main,n.sub,!0)}return i[jn](t)},ne.extendSeriesModel=function(t,e){var i=b;if(e){e="series."+e[Tn]("series.","");var n=re(e);i=b.getClass(n.main,n.sub,!0)}return i[jn](t)},ne[xn]=function(t,e){var i=S;if(e){e[Tn]("series.","");var n=re(e);i=S.getClass(n.main,!0)}return i[jn](t)},ne.setCanvasCreator=function(t){C.createCanvas=t},ne.registerVisual(R,t(". / visual / seriesColor ")),ne.registerPreprocessor(t(". / preprocessor / backwardCompat ")),ne.registerLoading("
            default ",t(". / loading /
            default ")),ne[Mn]({type:"highlight ",event:"highlight ",update:"highlight "},C.noop),ne[Mn]({type:"downplay ",event:"downplay ",update:"downplay "},C.noop),ne.List=t(". / data / List "),ne.Model=t(". / model / Model "),ne.graphic=t(". / util / graphic "),ne[yn]=t(". / util / number "),ne.format=t(". / util / format "),ne.matrix=t(br),ne.vector=t(wr),ne.color=t(Mr),ne.util={},I(["map ","each ",mn,gn,vn,"reduce ",mn,"bind ","curry ",An,pn,Yn,"isFunction ",jn,qn],function(t){ne.util[t]=C[t]}),ne.PRIORITY={PROCESSOR:{FILTER:D,STATISTIC:z},VISUAL:{LAYOUT:V,GLOBAL:R,CHART:O,COMPONENT:E,BRUSH:N}},ne}),e("echarts / chart / scatter ",[Tr,Ar,".. / echarts ",". / scatter / ScatterSeries ",". / scatter / ScatterView ",".. / visual / symbol ",".. / layout / points ",".. / component / grid "],function(t){var e=t(Ar),i=t(".. / echarts ");t(". / scatter / ScatterSeries "),t(". / scatter / ScatterView "),i.registerVisual(e.curry(t(".. / visual / symbol "),"scatter ",fn,null)),i.registerLayout(e.curry(t(".. / layout / points "),"scatter ")),t(".. / component / grid ")}),e("echarts / chart / bar ",[Tr,Ar,".. / coord / cartesian / Grid ",". / bar / BarSeries ",". / bar / BarView ",".. / layout / barGrid ",".. / echarts ",".. / component / grid "],function(t){var e=t(Ar);t(".. / coord / cartesian / Grid "),t(". / bar / BarSeries "),t(". / bar / BarView ");var i=t(".. / layout / barGrid "),n=t(".. / echarts ");n.registerLayout(e.curry(i,"bar ")),n.registerVisual(function(t){t[dn]("bar ",function(t){var e=t[Kn]();e[hn]("legendSymbol ","roundRect ")})}),t(".. / component / grid ")}),e("echarts / chart / candlestick ",[Tr,".. / echarts ",". / candlestick / CandlestickSeries ",". / candlestick / CandlestickView ",". / candlestick / preprocessor ",". / candlestick / candlestickVisual ",". / candlestick / candlestickLayout "],function(t){var e=t(".. / echarts ");t(". / candlestick / CandlestickSeries "),t(". / candlestick / CandlestickView "),e.registerPreprocessor(t(". / candlestick / preprocessor ")),e.registerVisual(t(". / candlestick / candlestickVisual ")),e.registerLayout(t(". / candlestick / candlestickLayout "))}),e("echarts / chart / line ",[Tr,Ar,".. / echarts ",". / line / LineSeries ",". / line / LineView ",".. / visual / symbol ",".. / layout / points ",".. / processor / dataSample ",".. / component / grid "],function(t){var e=t(Ar),i=t(".. / echarts "),n=i.PRIORITY;t(". / line / LineSeries "),t(". / line / LineView "),i.registerVisual(e.curry(t(".. / visual / symbol "),"line ",fn,"line ")),i.registerLayout(e.curry(t(".. / layout / points "),"line ")),i.registerProcessor(n.PROCESSOR.STATISTIC,e.curry(t(".. / processor / dataSample "),"line ")),t(".. / component / grid ")}),e("echarts / chart / radar ",[Tr,Ar,".. / echarts ",".. / component / radar ",". / radar / RadarSeries ",". / radar / RadarView ",".. / visual / dataColor ",".. / visual / symbol ",". / radar / radarLayout ",".. / processor / dataFilter ",". / radar / backwardCompat "],function(t){var e=t(Ar),i=t(".. / echarts ");t(".. / component / radar "),t(". / radar / RadarSeries "),t(". / radar / RadarView "),i.registerVisual(e.curry(t(".. / visual / dataColor "),"radar ")),i.registerVisual(e.curry(t(".. / visual / symbol "),"radar ",fn,null)),i.registerLayout(t(". / radar / radarLayout ")),i.registerProcessor(e.curry(t(".. / processor / dataFilter "),"radar ")),i.registerPreprocessor(t(". / radar / backwardCompat "))}),e("echarts / chart / heatmap ",[Tr,". / heatmap / HeatmapSeries ",". / heatmap / HeatmapView "],function(t){t(". / heatmap / HeatmapSeries "),t(". / heatmap / HeatmapView ")}),e("echarts / chart / graph ",[Tr,".. / echarts ",Ar,". / graph / GraphSeries ",". / graph / GraphView ",". / graph / roamAction ",". / graph / categoryFilter ",".. / visual / symbol ",". / graph / categoryVisual ",". / graph / edgeVisual ",". / graph / simpleLayout ",". / graph / circularLayout ",". / graph / forceLayout ",". / graph / createView "],function(t){var e=t(".. / echarts "),i=t(Ar);t(". / graph / GraphSeries "),t(". / graph / GraphView "),t(". / graph / roamAction "),e.registerProcessor(t(". / graph / categoryFilter ")),e.registerVisual(i.curry(t(".. / visual / symbol "),"graph ",fn,null)),e.registerVisual(t(". / graph / categoryVisual ")),e.registerVisual(t(". / graph / edgeVisual ")),e.registerLayout(t(". / graph / simpleLayout ")),e.registerLayout(t(". / graph / circularLayout ")),e.registerLayout(t(". / graph / forceLayout ")),e.registerCoordinateSystem("graphView ",{create:t(". / graph / createView ")})}),e("echarts / chart / treemap ",[Tr,".. / echarts ",". / treemap / TreemapSeries ",". / treemap / TreemapView ",". / treemap / treemapAction ",". / treemap / treemapVisual ",". / treemap / treemapLayout "],function(t){var e=t(".. / echarts ");t(". / treemap / TreemapSeries "),t(". / treemap / TreemapView "),t(". / treemap / treemapAction "),e.registerVisual(t(". / treemap / treemapVisual ")),e.registerLayout(t(". / treemap / treemapLayout "))}),e("echarts / chart / map ",[Tr,".. / echarts ",". / map / MapSeries ",". / map / MapView ",".. / action / geoRoam ",".. / coord / geo / geoCreator ",". / map / mapSymbolLayout ",". / map / mapVisual ",". / map / mapDataStatistic ",". / map / backwardCompat ",".. / action / createDataSelectAction "],function(t){var e=t(".. / echarts "),i=e.PRIORITY;t(". / map / MapSeries "),t(". / map / MapView "),t(".. / action / geoRoam "),t(".. / coord / geo / geoCreator "),e.registerLayout(t(". / map / mapSymbolLayout ")),e.registerVisual(t(". / map / mapVisual ")),e.registerProcessor(i.PROCESSOR.STATISTIC,t(". / map / mapDataStatistic ")),e.registerPreprocessor(t(". / map / backwardCompat ")),t(".. / action / createDataSelectAction ")("map ",[{type:"mapToggleSelect ",event:"mapselectchanged ",method:"toggleSelected "},{type:"mapSelect ",event:"mapselected ",method:"select "},{type:"mapUnSelect ",event:"mapunselected ",method:"unSelect "}])}),e("echarts / chart / lines ",[Tr,". / lines / LinesSeries ",". / lines / LinesView ",".. / echarts ",". / lines / linesLayout "],function(t){t(". / lines / LinesSeries "),t(". / lines / LinesView ");var e=t(".. / echarts ");e.registerLayout(t(". / lines / linesLayout "))}),e("echarts / chart / boxplot ",[Tr,".. / echarts ",". / boxplot / BoxplotSeries ",". / boxplot / BoxplotView ",". / boxplot / boxplotVisual ",". / boxplot / boxplotLayout "],function(t){var e=t(".. / echarts ");t(". / boxplot / BoxplotSeries "),t(". / boxplot / BoxplotView "),e.registerVisual(t(". / boxplot / boxplotVisual ")),e.registerLayout(t(". / boxplot / boxplotLayout "))}),e("echarts / chart / parallel ",[Tr,".. / echarts ",".. / component / parallel ",". / parallel / ParallelSeries ",". / parallel / ParallelView ",". / parallel / parallelVisual "],function(t){var e=t(".. / echarts ");t(".. / component / parallel "),t(". / parallel / ParallelSeries "),t(". / parallel / ParallelView "),e.registerVisual(t(". / parallel / parallelVisual "))}),e("echarts / chart / gauge ",[Tr,". / gauge / GaugeSeries ",". / gauge / GaugeView "],function(t){t(". / gauge / GaugeSeries "),t(". / gauge / GaugeView ")}),e("echarts / chart / funnel ",[Tr,Ar,".. / echarts ",". / funnel / FunnelSeries ",". / funnel / FunnelView ",".. / visual / dataColor ",". / funnel / funnelLayout ",".. / processor / dataFilter "],function(t){var e=t(Ar),i=t(".. / echarts ");t(". / funnel / FunnelSeries "),t(". / funnel / FunnelView "),i.registerVisual(e.curry(t(".. / visual / dataColor "),"funnel ")),i.registerLayout(t(". / funnel / funnelLayout ")),i.registerProcessor(e.curry(t(".. / processor / dataFilter "),"funnel "))}),e("echarts / chart / sankey ",[Tr,".. / echarts ",". / sankey / SankeySeries ",". / sankey / SankeyView ",". / sankey / sankeyLayout ",". / sankey / sankeyVisual "],function(t){var e=t(".. / echarts ");t(". / sankey / SankeySeries "),t(". / sankey / SankeyView "),e.registerLayout(t(". / sankey / sankeyLayout ")),e.registerVisual(t(". / sankey / sankeyVisual "))}),e("echarts / chart / effectScatter ",[Tr,Ar,".. / echarts ",". / effectScatter / EffectScatterSeries ",". / effectScatter / EffectScatterView ",".. / visual / symbol ",".. / layout / points "],function(t){var e=t(Ar),i=t(".. / echarts ");t(". / effectScatter / EffectScatterSeries "),t(". / effectScatter / EffectScatterView "),i.registerVisual(e.curry(t(".. / visual / symbol "),"effectScatter ",fn,null)),i.registerLayout(e.curry(t(".. / layout / points "),"effectScatter "))}),e("echarts / component / grid ",[Tr,".. / util / graphic ",Ar,".. / echarts ",".. / coord / cartesian / Grid ",". / axis "],function(t){var e=t(".. / util / graphic "),i=t(Ar),n=t(".. / echarts ");t(".. / coord / cartesian / Grid "),t(". / axis "),n[_n]({type:"grid ",render:function(t){this.group[cn](),t.get("show ")&&this.group.add(new e.Rect({shape:t[ln][un](),style:i[qn]({fill:t.get(ur)},t[sn]()),silent:!0}))}}),n.registerPreprocessor(function(t){t.xAxis&&t.yAxis&&!t.grid&&(t.grid={})})}),e("echarts / component / polar ",[Tr,".. / coord / polar / polarCreator ",". / angleAxis ",". / radiusAxis ",".. / echarts "],function(t){t(".. / coord / polar / polarCreator "),t(". / angleAxis "),t(". / radiusAxis "),t(".. / echarts ")[_n]({type:"polar "})}),e("echarts / component / geo ",[Tr,".. / coord / geo / GeoModel ",".. / coord / geo / geoCreator ",". / geo / GeoView ",".. / action / geoRoam ",".. / echarts ",Ar],function(t){function e(t,e){e[er]="updateView ",i[Mn](e,function(e,i){var r={};return i[or]({mainType:"geo ",query:e},function(i){i[t](e.name);var a=i[ln];n.each(a.regions,function(t){r[t.name]=i.isSelected(t.name)||!1})}),{selected:r,name:e.name}})}t(".. / coord / geo / GeoModel "),t(".. / coord / geo / geoCreator "),t(". / geo / GeoView "),t(".. / action / geoRoam ");var i=t(".. / echarts "),n=t(Ar);e("toggleSelected ",{type:"geoToggleSelect ",event:"geoselectchanged "}),e("select ",{type:"geoSelect ",event:"geoselected "}),e("unSelect ",{type:"geoUnSelect ",event:"geounselected "})}),e("echarts / component / singleAxis ",[Tr,".. / coord / single / singleCreator ",". / axis / SingleAxisView ",".. / coord / single / AxisModel ",".. / echarts "],function(t){t(".. / coord / single / singleCreator "),t(". / axis / SingleAxisView "),t(".. / coord / single / AxisModel ");var e=t(".. / echarts ");e[_n]({type:"single "})}),e("echarts / component / legend ",[Tr,". / legend / LegendModel ",". / legend / legendAction ",". / legend / LegendView ",".. / echarts ",". / legend / legendFilter "],function(t){t(". / legend / LegendModel "),t(". / legend / legendAction "),t(". / legend / LegendView ");var e=t(".. / echarts ");e.registerProcessor(t(". / legend / legendFilter "))}),e("echarts / component / title ",[Tr,".. / echarts ",".. / util / graphic ",".. / util / layout "],function(t){var e=t(".. / echarts "),i=t(".. / util / graphic "),n=t(".. / util / layout ");e[wn]({type:"title ",layoutMode:{type:"box ",ignoreSize:!0},defaultOption:{zlevel:0,z:6,show:!0,text:"",target:"blank ",subtext:"",subtarget:"blank ",left:0,top:0,backgroundColor:"rgba(0, 0, 0, 0)",borderColor:"#ccc ",borderWidth:0,padding:5,itemGap:10,textStyle:{fontSize:18,fontWeight:"bolder ",color:"#333 "},subtextStyle:{color:"#aaa "}}}),e[_n]({type:"title ",render:function(t,e,r){if(this.group[cn](),t.get("show ")){var a=this.group,o=t[fr](on),s=t[fr]("subtextStyle "),l=t.get(an),u=t.get("textBaseline "),c=new i.Text({style:{text:t.get("text "),textFont:o[rn](),fill:o[nn]()},z2:10}),h=c[en](),d=t.get("subtext "),f=new i.Text({style:{text:d,textFont:s[rn](),fill:s[nn](),y:h[nr]+t.get("itemGap "),textBaseline:"top "},z2:10}),p=t.get("link "),v=t.get("sublink ");c[Nn]=!p,f[Nn]=!v,p&&c.on("click ",function(){window.open(p,"_ "+t.get(Vn))}),v&&f.on("click ",function(){window.open(v,"_ "+t.get("subtarget "))}),a.add(c),d&&a.add(f);var g=a[en](),m=t[tn]();m.width=g.width,m[nr]=g[nr];var y=n[Ki](m,{width:r[dr](),height:r[hr]()},t.get("padding "));l||(l=t.get("left ")||t.get("right "),l===Qi&&(l=Ji),"right "===l?y.x+=y.width:l===Ji&&(y.x+=y.width/2)),u||(u=t.get("top ")||t.get(rr),u===Ji&&(u=Qi),u===rr?y.y+=y[nr]:u===Qi&&(y.y+=y[nr]/2),u=u||"top "),a.attr($i,[y.x,y.y]);var x={textAlign:l,textVerticalAlign:u};c[Ln](x),f[Ln](x),g=a[en]();var _=y.margin,w=t[sn](["color ",Yi]);w.fill=t.get(ur);var b=new i.Rect({shape:{x:g.x-_[3],y:g.y-_[0],width:g.width+_[1]+_[3],height:g[nr]+_[0]+_[2]},style:w,silent:!0});i.subPixelOptimizeRect(b),a.add(b)}}})}),e("echarts / component / tooltip ",[Tr,". / tooltip / TooltipModel ",". / tooltip / TooltipView ",".. / echarts "],function(t){t(". / tooltip / TooltipModel "),t(". / tooltip / TooltipView "),t(".. / echarts ")[Mn]({type:"showTip ",event:"showTip ",update:"none "},function(){}),t(".. / echarts ")[Mn]({type:"hideTip ",event:"hideTip ",update:"none "},function(){})}),e("echarts / component / markPoint ",[Tr,". / marker / MarkPointModel ",". / marker / MarkPointView ",".. / echarts "],function(t){t(". / marker / MarkPointModel "),t(". / marker / MarkPointView "),t(".. / echarts ").registerPreprocessor(function(t){t.markPoint=t.markPoint||{}})}),e("echarts / component / markLine ",[Tr,". / marker / MarkLineModel ",". / marker / MarkLineView ",".. / echarts "],function(t){t(". / marker / MarkLineModel "),t(". / marker / MarkLineView "),t(".. / echarts ").registerPreprocessor(function(t){t.markLine=t.markLine||{}})}),e("echarts / component / markArea ",[Tr,". / marker / MarkAreaModel ",". / marker / MarkAreaView ",".. / echarts "],function(t){t(". / marker / MarkAreaModel "),t(". / marker / MarkAreaView "),t(".. / echarts ").registerPreprocessor(function(t){t.markArea=t.markArea||{}})}),e("echarts / component / timeline ",[Tr,".. / echarts ",". / timeline / preprocessor ",". / timeline / typeDefaulter ",". / timeline / timelineAction ",". / timeline / SliderTimelineModel ",". / timeline / SliderTimelineView "],function(t){var e=t(".. / echarts ");e.registerPreprocessor(t(". / timeline / preprocessor ")),t(". / timeline / typeDefaulter "),t(". / timeline / timelineAction "),t(". / timeline / SliderTimelineModel "),t(". / timeline / SliderTimelineView ")}),e("echarts / component / dataZoom ",[Tr,". / dataZoom / typeDefaulter ",". / dataZoom / DataZoomModel ",". / dataZoom / DataZoomView ",". / dataZoom / SliderZoomModel ",". / dataZoom / SliderZoomView ",". / dataZoom / InsideZoomModel ",". / dataZoom / InsideZoomView ",". / dataZoom / dataZoomProcessor ",". / dataZoom / dataZoomAction "],function(t){t(". / dataZoom / typeDefaulter "),t(". / dataZoom / DataZoomModel "),t(". / dataZoom / DataZoomView "),t(". / dataZoom / SliderZoomModel "),t(". / dataZoom / SliderZoomView "),t(". / dataZoom / InsideZoomModel "),t(". / dataZoom / InsideZoomView "),t(". / dataZoom / dataZoomProcessor "),t(". / dataZoom / dataZoomAction ")}),e("echarts / component / visualMap ",[Tr,". / visualMapContinuous ",". / visualMapPiecewise "],function(t){t(". / visualMapContinuous "),t(". / visualMapPiecewise ")}),e("echarts / component / brush ",[Tr,".. / echarts ",". / brush / preprocessor ",". / brush / visualEncoding ",". / brush / BrushModel ",". / brush / BrushView ",". / brush / brushAction ",". / toolbox / feature / Brush "],function(t){t(".. / echarts ").registerPreprocessor(t(". / brush / preprocessor ")),t(". / brush / visualEncoding "),t(". / brush / BrushModel "),t(". / brush / BrushView "),t(". / brush / brushAction "),t(". / toolbox / feature / Brush ")}),e("echarts / component / toolbox ",[Tr,". / toolbox / ToolboxModel ",". / toolbox / ToolboxView ",". / toolbox / feature / SaveAsImage ",". / toolbox / feature / MagicType ",". / toolbox / feature / DataView ",". / toolbox / feature / DataZoom ",". / toolbox / feature / Restore "],function(t){t(". / toolbox / ToolboxModel "),t(". / toolbox / ToolboxView "),t(". / toolbox / feature / SaveAsImage "),t(". / toolbox / feature / MagicType "),t(". / toolbox / feature / DataView "),t(". / toolbox / feature / DataZoom "),t(". / toolbox / feature / Restore ")}),e("zrender / vml / vml ",[Tr,". / graphic ",".. / zrender ",". / Painter "],function(t){t(". / graphic "),t(".. / zrender ").registerPainter("vml ",t(". / Painter "))}),e("echarts / scale / Time ",[Tr,Ar,Xi,".. / util / format ",". / Interval "],function(t){var e=t(Ar),i=t(Xi),n=t(".. / util / format "),r=t(". / Interval "),a=r[xr],o=Math.ceil,s=Math.floor,l=1e3,u=60*l,c=60*u,h=24*c,d=function(t,e,i,n){for(;n>i;){var r=i+n>>>1;t[r][2]<e?i=r+1:n=r}return i},f=r[jn]({type:"time ",getLabel:function(t){var e=this._stepLvl,i=new Date(t);return n.formatTime(e[0],i)},niceExtent:function(t,e,n){var r=this._extent;if(r[0]===r[1]&&(r[0]-=h,r[1]+=h),r[1]===-1/0&&1/0===r[0]){var a=new Date;r[1]=new Date(a.getFullYear(),a.getMonth(),a.getDate()),r[0]=r[1]-h}this.niceTicks(t);var l=this._interval;e||(r[0]=i.round(s(r[0]/l)*l)),n||(r[1]=i.round(o(r[1]/l)*l))
},niceTicks:function(t){t=t||10;var e=this._extent,n=e[1]-e[0],r=n/t,a=p[Wn],l=d(p,r,0,a),u=p[Math.min(l,a-1)],c=u[2];if("year "===u[0]){var h=n/c,f=i.nice(h/t,!0);c*=f}var v=[o(e[0]/c)*c,s(e[1]/c)*c];this._stepLvl=u,this._interval=c,this._niceExtent=v},parse:function(t){return+i.parseDate(t)}});e.each([ji,Ui],function(t){f[xr][t]=function(e){return a[t].call(this,this.parse(e))}});var p=[["hh: mm: ss ",1,l],["hh: mm: ss ",5,5*l],["hh: mm: ss ",10,10*l],["hh: mm: ss ",15,15*l],["hh: mm: ss ",30,30*l],["hh: mm\nMM - dd ",1,u],["hh: mm\nMM - dd ",5,5*u],["hh: mm\nMM - dd ",10,10*u],["hh: mm\nMM - dd ",15,15*u],["hh: mm\nMM - dd ",30,30*u],["hh: mm\nMM - dd ",1,c],["hh: mm\nMM - dd ",2,2*c],["hh: mm\nMM - dd ",6,6*c],["hh: mm\nMM - dd ",12,12*c],["MM - dd\nyyyy ",1,h],["week ",7,7*h],["month ",1,31*h],["quarter ",3,380*h/4],["half - year ",6,380*h/2],["year ",1,380*h]];return f[ir]=function(){return new f},f}),e("echarts / scale / Log ",[Tr,Ar,". / Scale ",Xi,". / Interval "],function(t){var e=t(Ar),i=t(". / Scale "),n=t(Xi),r=t(". / Interval "),a=i[xr],o=r[xr],s=Math.floor,l=Math.ceil,u=Math.pow,c=Math.log,h=i[jn]({type:"log ",base:10,getTicks:function(){return e.map(o[qi].call(this),function(t){return n.round(u(this.base,t))},this)},getLabel:o[Wi],scale:function(t){return t=a.scale.call(this,t),u(this.base,t)},setExtent:function(t,e){var i=this.base;t=c(t)/c(i),e=c(e)/c(i),o[Zi].call(this,t,e)},getExtent:function(){var t=this.base,e=a[Fi].call(this);return e[0]=u(t,e[0]),e[1]=u(t,e[1]),e},unionExtent:function(t){var e=this.base;t[0]=c(t[0])/c(e),t[1]=c(t[1])/c(e),a[Hi].call(this,t)},niceTicks:function(t){t=t||10;var e=this._extent,i=e[1]-e[0];if(!(1/0===i||0>=i)){var r=n.quantity(i),a=t/i*r;for(.5>=a&&(r*=10);!isNaN(r)&&Math.abs(r)<1&&Math.abs(r)>0;)r*=10;var o=[n.round(l(e[0]/r)*r),n.round(s(e[1]/r)*r)];this._interval=r,this._niceExtent=o}},niceExtent:o.niceExtent});return e.each([ji,Ui],function(t){h[xr][t]=function(e){return e=c(e)/c(this.base),a[t].call(this,e)}}),h[ir]=function(){return new h},h}),e("echarts / chart / pie / PieSeries ",[Tr,Gi,Ar,Bi,Ni,".. / .. / component / helper / selectableMixin ",Ei],function(t){var e=t(Gi),i=t(Ar),n=t(Bi),r=t(Ni),a=t(".. / .. / component / helper / selectableMixin "),o=t(Ei).extendSeriesModel({type:"series.pie ",init:function(t){o[Oi](this,"init ",arguments),this.legendDataProvider=function(){return this._dataBeforeProcessed},this.updateSelectedMap(t.data),this._defaultLabelLine(t)},mergeOption:function(t){o[Ri](this,Vi,t),this.updateSelectedMap(this[zi].data)},getInitialData:function(t){var i=r(["value "],t.data),n=new e(i,this);return n[Di](t.data),n},getDataParams:function(t){var e=this._data,i=o[Ri](this,In,t),n=e.getSum("value ");return i.percent=n?+(e.get("value ",t)/n*100)[Ii](2):0,i.$vars.push("percent "),i},_defaultLabelLine:function(t){n[Pi](t.labelLine,["show "]);var e=t.labelLine[ki],i=t.labelLine[Li];e.show=e.show&&t.label[ki].show,i.show=i.show&&t.label[Li].show},defaultOption:{zlevel:0,z:2,legendHoverLink:!0,hoverAnimation:!0,center:["50 % ","50 % "],radius:[0,"75 % "],clockwise:!0,startAngle:90,minAngle:0,selectedOffset:10,avoidLabelOverlap:!0,label:{normal:{rotate:!1,show:!0,position:"outer "},emphasis:{}},labelLine:{normal:{show:!0,length:15,length2:15,smooth:!1,lineStyle:{width:1,type:"solid "}}},itemStyle:{normal:{borderWidth:1},emphasis:{}},animationEasing:"cubicOut ",data:[]}});return i.mixin(o,a),o}),e("echarts / action / createDataSelectAction ",[Tr,".. / echarts ",Ar],function(t){var e=t(".. / echarts "),i=t(Ar);return function(t,n){i.each(n,function(i){i[er]="updateView ",e[Mn](i,function(e,n){var r={};return n[or]({mainType:"series ",subType:t,query:e},function(t){t[i.method]&&t[i.method](e.name);var n=t[Kn]();n.each(function(e){var i=n[Ci](e);r[i]=t.isSelected(i)||!1})}),{name:e.name,selected:r}})})}}),e(Ar,[Tr],function(){function t(e){if("object "==typeof e&&null!==e){var i=e;if(e instanceof Array){i=[];for(var n=0,r=e[Wn];r>n;n++)i[n]=t(e[n])}else if(!b(e)&&!M(e)){i={};for(var a in e)e.hasOwnProperty(a)&&(i[a]=t(e[a]))}return i}return e}function e(i,n,r){if(!w(n)||!w(i))return r?t(n):i;for(var a in n)if(n.hasOwnProperty(a)){var o=i[a],s=n[a];!w(s)||!w(o)||y(s)||y(o)||M(s)||M(o)||b(s)||b(o)?!r&&a in i||(i[a]=t(n[a],!0)):e(o,s,r)}return i}function i(t,i){for(var n=t[0],r=1,a=t[Wn];a>r;r++)n=e(n,t[r],i);return n}function n(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);return t}function r(t,e,i){for(var n in e)e.hasOwnProperty(n)&&(i?null!=e[n]:null==t[n])&&(t[n]=e[n]);return t}function a(){return document[Ti](mr)}function o(){return C||(C=O.createCanvas().getContext("2d ")),C}function s(t,e){if(t){if(t[gn])return t[gn](e);for(var i=0,n=t[Wn];n>i;i++)if(t[i]===e)return i}return-1}function l(t,e){function i(){}var n=t[xr];i[xr]=e[xr],t[xr]=new i;for(var r in n)t[xr][r]=n[r];t[xr].constructor=t,t.superClass=e}function u(t,e,i){t=xr in t?t[xr]:t,e=xr in e?e[xr]:e,r(t,e,i)}function c(t){return t?typeof t==yr?!1:typeof t[Wn]==yn:void 0}function h(t,e,i){if(t&&e)if(t.forEach&&t.forEach===I)t.forEach(e,i);else if(t[Wn]===+t[Wn])for(var n=0,r=t[Wn];r>n;n++)e.call(i,t[n],n,t);else for(var a in t)t.hasOwnProperty(a)&&e.call(i,t[a],a,t)}function d(t,e,i){if(t&&e){if(t.map&&t.map===V)return t.map(e,i);for(var n=[],r=0,a=t[Wn];a>r;r++)n.push(e.call(i,t[r],r,t));return n}}function f(t,e,i,n){if(t&&e){if(t.reduce&&t.reduce===R)return t.reduce(e,i,n);for(var r=0,a=t[Wn];a>r;r++)i=e.call(n,i,t[r],r,t);return i}}function p(t,e,i){if(t&&e){if(t[mn]&&t[mn]===D)return t[mn](e,i);for(var n=[],r=0,a=t[Wn];a>r;r++)e.call(i,t[r],r,t)&&n.push(t[r]);return n}}function v(t,e,i){if(t&&e)for(var n=0,r=t[Wn];r>n;n++)if(e.call(i,t[n],n,t))return t[n]}function g(t,e){var i=z.call(arguments,2);return function(){return t.apply(e,i[Ai](z.call(arguments)))}}function m(t){var e=z.call(arguments,1);return function(){return t.apply(this,e[Ai](z.call(arguments)))}}function y(t){return" [object Array]"===k.call(t)}function x(t){return typeof t===Sn}function _(t){return" [object String]"===k.call(t)}function w(t){var e=typeof t;return e===Sn||!!t&&"object "==e}function b(t){return!!L[k.call(t)]}function M(t){return t&&1===t.nodeType&&typeof t.nodeName==yr}function S(){for(var t=0,e=arguments[Wn];e>t;t++)if(null!=arguments[t])return arguments[t]}function A(){return Function.call.apply(z,arguments)}function T(t,e){if(!t)throw new Error(e)}var C,L={" [object Function]":1," [object RegExp]":1," [object Date]":1," [object Error]":1," [object CanvasGradient]":1," [object CanvasPattern]":1," [object Image]":1},k=Object[xr].toString,P=Array[xr],I=P.forEach,D=P[mn],z=P.slice,V=P.map,R=P.reduce,O={inherits:l,mixin:u,clone:t,merge:e,mergeAll:i,extend:n,defaults:r,getContext:o,createCanvas:a,indexOf:s,slice:A,find:v,isArrayLike:c,each:h,map:d,reduce:f,filter:p,bind:g,curry:m,isArray:y,isString:_,isObject:w,isFunction:x,isBuildInObject:b,isDom:M,retrieve:S,assert:T,noop:function(){}};return O}),e("echarts / chart / pie / PieView ",[Tr,Si,Ar,".. / .. / view / Chart "],function(t){function e(t,e,n,r){var a=e[Kn](),o=this[zn],s=a[Ci](o),l=e.get("selectedOffset ");r[Un]({type:"pieToggleSelect ",from:t,name:s,seriesId:e.id}),a.each(function(t){i(a[Mi](t),a[bi](t),e.isSelected(a[Ci](t)),l,n)})}function i(t,e,i,n,r){var a=(e.startAngle+e.endAngle)/2,o=Math.cos(a),s=Math.sin(a),l=i?n:0,u=[o*l,s*l];r?t[wi]().when(200,{position:u}).start("bounceOut "):t.attr($i,u)}function n(t,e){function i(){o[ar]=o.hoverIgnore,s[ar]=s.hoverIgnore}function n(){o[ar]=o.normalIgnore,s[ar]=s.normalIgnore}a.Group.call(this);var r=new a[_i]({z2:2}),o=new a[xi],s=new a.Text;this.add(r),this.add(o),this.add(s),this[yi](t,e,!0),this.on(Li,i).on(ki,n).on(En,i).on(On,n)}function r(t,e,i,n,r){var a=n[fr](on),s=r===mi||"inner "===r;return{fill:a[nn]()||(s?"#fff ":t[gi](e,"color ")),opacity:t[gi](e,Yi),textFont:a[rn](),text:o[vi](t[fi][pi](e,i),t[Ci](e))}}var a=t(Si),o=t(Ar),s=n[xr];s[yi]=function(t,e,n){function r(){l[sr](!0),l.animateTo({shape:{r:h.r+10}},300,"elasticOut ")}function s(){l[sr](!0),l.animateTo({shape:{r:h.r}},300,"elasticOut ")}var l=this[di](0),u=t[fi],c=t[hi](e),h=t[bi](e),d=o[jn]({},h);d.label=null,n?(l[ci](d),l.shape.endAngle=h.startAngle,a[ui](l,{shape:{endAngle:h.endAngle}},u,e)):a[ui](l,{shape:d},u,e);var f=c[fr](li),p=t[gi](e,"color ");l[si](o[qn]({lineJoin:"bevel ",fill:p},f[fr](ki)[sn]())),l[oi]=f[fr](Li)[sn](),i(this,t[bi](e),c.get(ai),u.get("selectedOffset "),u.get(vr)),l.off(En).off(On).off(Li).off(ki),c.get("hoverAnimation ")&&u.ifEnableAnimation()&&l.on(En,r).on(On,s).on(Li,r).on(ki,s),this._updateLabel(t,e),a[ri](this)},s._updateLabel=function(t,e){var i=this[di](1),n=this[di](2),o=t[fi],s=t[hi](e),l=t[bi](e),u=l.label,c=t[gi](e,"color ");a[ui](i,{shape:{points:u.linePoints||[[u.x,u.y],[u.x,u.y],[u.x,u.y]]}},o,e),a[ui](n,{style:{x:u.x,y:u.y}},o,e),n.attr({style:{textVerticalAlign:u.verticalAlign,textAlign:u[an],textFont:u.font},rotation:u[ni],origin:[u.x,u.y],z2:10});var h=s[fr](ii),d=s[fr](ei),f=s[fr]("labelLine.normal "),p=s[fr]("labelLine.emphasis "),v=h.get($i)||d.get($i);n[Ln](r(t,e,ki,h,v)),n[ar]=n.normalIgnore=!h.get("show "),n.hoverIgnore=!d.get("show "),i[ar]=i.normalIgnore=!f.get("show "),i.hoverIgnore=!p.get("show "),i[Ln]({stroke:c,opacity:t[gi](e,Yi)}),i[Ln](f[fr](Ke)[ti]()),n[oi]=r(t,e,Li,d,v),i[oi]=p[fr](Ke)[ti]();var g=f.get("smooth ");g&&g===!0&&(g=.4),i[ci]({smooth:g})},o[vn](n,a.Group);var l=t(".. / .. / view / Chart ")[jn]({type:"pie ",init:function(){var t=new a.Group;this._sectorGroup=t},render:function(t,i,r,a){if(!a||a.from!==this.uid){var s=t[Kn](),l=this._data,u=this.group,c=i.get(vr),h=!l,d=o.curry(e,this.uid,t,c,r),f=t.get("selectedMode ");if(s.diff(l).add(function(t){var e=new n(s,t);h&&e[Je](function(t){t[sr](!0)}),f&&e.on("click ",d),s[$e](t,e),u.add(e)})[er](function(t,e){var i=l[Mi](e);i[yi](s,t),i.off("click "),f&&i.on("click ",d),u.add(i),s[$e](t,i)})[Xn](function(t){var e=l[Mi](t);u[Xn](e)})[Qe](),c&&h&&s.count()>0){var p=s[bi](0),v=Math.max(r[dr](),r[hr]())/2,g=o.bind(u.removeClipPath,u);u.setClipPath(this._createClipPath(p.cx,p.cy,v,p.startAngle,p[Ye],g,t))}this._data=s}},_createClipPath:function(t,e,i,n,r,o,s){var l=new a[_i]({shape:{cx:t,cy:e,r0:0,r:i,startAngle:n,endAngle:n,clockwise:r}});return a[Xe](l,{shape:{endAngle:n+(r?1:-1)*Math.PI*2}},s,o),l}});return l}),e("echarts / visual / dataColor ",[Tr],function(){return function(t,e){var i={};e.eachRawSeriesByType(t,function(t){var n=t.getRawData(),r={};if(!e.isSeriesFiltered(t)){var a=t[Kn]();a.each(function(t){var e=a[je](t);r[e]=t}),n.each(function(e){var o=n[hi](e),s=r[e],l=null!=s&&a[gi](s,"color ",!0);if(l)n[Ue](e,"color ",l);else{var u=o.get("itemStyle.normal.color ")||t.getColorFromPalette(n[Ci](e),i);n[Ue](e,"color ",u),null!=s&&a[Ue](s,"color ",u)}})}})}}),e("echarts / chart / pie / pieLayout ",[Tr,qe,". / labelLayout ",Ar],function(t){var e=t(qe),i=e[We],n=t(". / labelLayout "),r=t(Ar),a=2*Math.PI,o=Math.PI/180;return function(t,s,l){s[dn](t,function(t){var s=t.get(Ji),u=t.get(Ze);r[An](u)||(u=[0,u]),r[An](s)||(s=[s,s]);var c=l[dr](),h=l[hr](),d=Math.min(c,h),f=i(s[0],c),p=i(s[1],h),v=i(u[0],d/2),g=i(u[1],d/2),m=t[Kn](),y=-t.get("startAngle ")*o,x=t.get("minAngle ")*o,_=m.getSum("value "),w=Math.PI/(_||m.count())*2,b=t.get(Ye),M=t.get("roseType "),S=m[Fe]("value ");S[0]=0;var A=a,T=0,C=y,L=b?1:-1;if(m.each("value ",function(t,i){var n;n="area "!==M?0===_?w:t*w:a/(m.count()||1),x>n?(n=x,A-=x):T+=t;var r=C+L*n;m[He](i,{angle:n,startAngle:C,endAngle:r,clockwise:b,cx:f,cy:p,r0:v,r:M?e[Ge](t,S,[v,g]):g}),C=r},!0),a>A)if(.001>=A){var k=a/m.count();m.each(function(t){var e=m[bi](t);e.startAngle=y+L*t*k,e.endAngle=y+L*(t+1)*k})}else w=A/T,C=y,m.each("value ",function(t,e){var i=m[bi](e),n=i.angle===x?x:t*w;i.startAngle=C,i.endAngle=C+L*n,C+=n});n(t,g,c,h)})}}),e("echarts / processor / dataFilter ",[],function(){return function(t,e){var i=e.findComponents({mainType:"legend "});i&&i[Wn]&&e[dn](t,function(t){var e=t[Kn]();e.filterSelf(function(t){for(var n=e[Ci](t),r=0;r<i[Wn];r++)if(!i[r].isSelected(n))return!1;return!0},this)},this)}}),e(Sr,[],function(){function t(t){var e={},i={},n=t.match(/Firefox\/([\d.]+)/),r=t.match(/MSIE\s([\d.]+)/)||t.match(/Trident\/.+?rv:(([\d.]+))/),a=t.match(/Edge\/([\d.]+)/);return n&&(i.firefox=!0,i.version=n[1]),r&&(i.ie=!0,i.version=r[1]),r&&(i.ie=!0,i.version=r[1]),a&&(i.edge=!0,i.version=a[1]),{browser:i,os:e,node:!1,canvasSupported:document[Ti](mr).getContext?!0:!1,touchEventsSupported:"ontouchstart "in window&&!i.ie&&!i.edge,pointerEventsSupported:"onpointerdown "in window&&(i.edge||i.ie&&i.version>=10)}}var e={};return e=typeof navigator===Be?{browser:{},os:{},node:!0,canvasSupported:!0}:t(navigator.userAgent)}),e("echarts / model / Global ",[Tr,Ar,".. / util / model ",". / Model ",". / Component ",". / globalDefault ",". / mixin / colorPalette "],function(t){function e(t,e){for(var i in e)y.hasClass(i)||("object "==typeof e[i]?t[i]=t[i]?u.merge(t[i],e[i],!1):u.clone(e[i]):null==t[i]&&(t[i]=e[i]))}function i(t){t=t,this[zi]={},this[zi][_]=1,this._componentsMap={},this._seriesIndices=null,e(t,this._theme[zi]),u.merge(t,x,!1),this[Vi](t)}function n(t,e){u[An](e)||(e=e?[e]:[]);var i={};return d(e,function(e){i[e]=(t[e]||[]).slice()}),i}function r(t,e){var i={};d(e,function(t){var e=t.exist;e&&(i[e.id]=t)}),d(e,function(e){var n=e[zi];if(u.assert(!n||null==n.id||!i[n.id]||i[n.id]===e,"id duplicates: "+(n&&n.id)),n&&null!=n.id&&(i[n.id]=e),m(n)){var r=a(t,n,e.exist);e.keyInfo={mainType:t,subType:r}}}),d(e,function(t){var e=t.exist,n=t[zi],r=t.keyInfo;if(m(n)){if(r.name=null!=n.name?n.name+"":e?e.name:"\x00 - ",e)r.id=e.id;else if(null!=n.id)r.id=n.id+"";else{var a=0;do r.id="\x00 "+r.name+"\x00 "+a++;while(i[r.id])}i[r.id]=t}})}function a(t,e,i){var n=e.type?e.type:i?i.subType:y.determineSubType(t,e);return n}function o(t){return p(t,function(t){return t[Oe]})||[]}function s(t,e){return e.hasOwnProperty("subType ")?f(t,function(t){return t.subType===e.subType}):t}function l(t){}var u=t(Ar),c=t(".. / util / model "),h=t(". / Model "),d=u.each,f=u[mn],p=u.map,v=u[An],g=u[gn],m=u[Yn],y=t(". / Component "),x=t(". / globalDefault "),_="\x00_ec_inner ",w=h[jn]({constructor:w,init:function(t,e,i,n){i=i||{},this[zi]=null,this._theme=new h(i),this._optionManager=n},setOption:function(t,e){u.assert(!(_ in t),"please use chart.getOption()"),this._optionManager.setOption(t,e),this.resetOption()},resetOption:function(t){var e=!1,n=this._optionManager;if(!t||"recreate "===t){var r=n.mountOption("recreate "===t);this[zi]&&"recreate "!==t?(this.restoreData(),this[Vi](r)):i.call(this,r),e=!0}if(("timeline "===t||"media "===t)&&this.restoreData(),!t||"recreate "===t||"timeline "===t){var a=n.getTimelineOption(this);a&&(this[Vi](a),e=!0)}if(!t||"recreate "===t||"media "===t){var o=n.getMediaOption(this,this._api);o[Wn]&&d(o,function(t){this[Vi](t,e=!0)},this)}return e},mergeOption:function(t){function e(e,s){var l=c.normalizeToArray(t[e]),h=c.mappingToExists(a[e],l);r(e,h);var f=n(a,s);i[e]=[],a[e]=[],d(h,function(t,n){var r=t.exist,o=t[zi];if(u.assert(m(o)||r,"Empty component definition "),o){var s=y.getClass(e,t.keyInfo.subType,!0);if(r&&r instanceof s)r[Vi](o,this),r.optionUpdated(o,!1);else{var l=u[jn]({dependentModels:f,componentIndex:n},t.keyInfo);r=new s(o,this,this,l),r.init(o,this,this,l),r.optionUpdated(null,!0)}}else r[Vi]({},this),r.optionUpdated({},!1);a[e][n]=r,i[e][n]=r[zi]},this),e===Fn&&(this._seriesIndices=o(a[Fn]))}var i=this[zi],a=this._componentsMap,s=[];d(t,function(t,e){null!=t&&(y.hasClass(e)?s.push(e):i[e]=null==i[e]?u.clone(t):u.merge(i[e],t,!0))}),y.topologicalTravel(s,y.getAllClassMainTypes(),e,this),this._seriesIndices=this._seriesIndices||[]},getOption:function(){var t=u.clone(this[zi]);return d(t,function(e,i){if(y.hasClass(i)){for(var e=c.normalizeToArray(e),n=e[Wn]-1;n>=0;n--)c.isIdInner(e[n])&&e[Gn](n,1);t[i]=e}}),delete t[_],t},getTheme:function(){return this._theme},getComponent:function(t,e){var i=this._componentsMap[t];return i?i[e||0]:void 0},queryComponents:function(t){var e=t[Ne];if(!e)return[];var i=t.index,n=t.id,r=t.name,a=this._componentsMap[e];if(!a||!a[Wn])return[];var o;if(null!=i)v(i)||(i=[i]),o=f(p(i,function(t){return a[t]}),function(t){return!!t});else if(null!=n){var l=v(n);o=f(a,function(t){return l&&g(n,t.id)>=0||!l&&t.id===n})}else if(null!=r){var u=v(r);o=f(a,function(t){return u&&g(r,t.name)>=0||!u&&t.name===r})}else o=a;return s(o,t)},findComponents:function(t){function e(t){var e=r+"Index ",i=r+"Id ",n=r+"Name ";return t&&(t.hasOwnProperty(e)||t.hasOwnProperty(i)||t.hasOwnProperty(n))?{mainType:r,index:t[e],id:t[i],name:t[n]}:null}function i(e){return t[mn]?f(e,t[mn]):e}var n=t.query,r=t[Ne],a=e(n),o=a?this[Ee](a):this._componentsMap[r];return i(s(o,t))},eachComponent:function(t,e,i){var n=this._componentsMap;if(typeof t===Sn)i=e,e=t,d(n,function(t,n){d(t,function(t,r){e.call(i,n,t,r)})});else if(u[pn](t))d(n[t],e,i);else if(m(t)){var r=this.findComponents(t);d(r,e,i)}},getSeriesByName:function(t){var e=this._componentsMap[Fn];return f(e,function(e){return e.name===t})},getSeriesByIndex:function(t){return this._componentsMap[Fn][t]},getSeriesByType:function(t){var e=this._componentsMap[Fn];return f(e,function(e){return e.subType===t})},getSeries:function(){return this._componentsMap[Fn].slice()},eachSeries:function(t,e){l(this),d(this._seriesIndices,function(i){var n=this._componentsMap[Fn][i];t.call(e,n,i)},this)},eachRawSeries:function(t,e){d(this._componentsMap[Fn],t,e)},eachSeriesByType:function(t,e,i){l(this),d(this._seriesIndices,function(n){var r=this._componentsMap[Fn][n];r.subType===t&&e.call(i,r,n)},this)},eachRawSeriesByType:function(t,e,i){return d(this.getSeriesByType(t),e,i)},isSeriesFiltered:function(t){return l(this),u[gn](this._seriesIndices,t[Oe])<0},filterSeries:function(t,e){l(this);var i=f(this._componentsMap[Fn],t,e);this._seriesIndices=o(i)},restoreData:function(){var t=this._componentsMap;this._seriesIndices=o(t[Fn]);var e=[];d(t,function(t,i){e.push(i)}),y.topologicalTravel(e,y.getAllClassMainTypes(),function(e){d(t[e],function(t){t.restoreData()})})}});return u.mixin(w,t(". / mixin / colorPalette ")),w}),e("echarts / ExtensionAPI ",[Tr,Ar],function(t){function e(t){i.each(n,function(e){this[e]=i.bind(t[e],t)},this)}var i=t(Ar),n=["getDom ","getZr ",dr,hr,Un,"isDisposed ","on ","off ","getDataURL ","getConnectedDataURL ",fr,"getOption "];return e}),e("echarts / CoordinateSystem ",[Tr],function(){function t(){this._coordinateSystems=[]}var e={};return t[xr]={constructor:t,create:function(t,i){var n=[];for(var r in e){var a=e[r][ir](t,i);a&&(n=n[Ai](a))}this._coordinateSystems=n},update:function(t,e){for(var i=this._coordinateSystems,n=0;n<i[Wn];n++)i[n][er]&&i[n][er](t,e)}},t[bn]=function(t,i){e[t]=i},t.get=function(t){return e[t]},t}),e("echarts / model / OptionManager ",[Tr,Ar,".. / util / model ",". / Component "],function(t){function e(t){this._api=t,this._timelineOptions=[],this._mediaList=[],this._mediaDefault,this._currentMediaIndices=[],this._optionBackup,this._newBaseOption}function i(t,e,i){var n,r,a=[],o=[],l=t.timeline;if(t.baseOption&&(r=t.baseOption),(l||t.options)&&(r=r||{},a=(t.options||[]).slice()),t.media){r=r||{};var u=t.media;c(u,function(t){t&&t[zi]&&(t.query?o.push(t):n||(n=t))})}return r||(r=t),r.timeline||(r.timeline=l),c([r][Ai](a)[Ai](s.map(o,function(t){return t[zi]})),function(t){c(e,function(e){e(t,i)})}),{baseOption:r,timelineOptions:a,mediaDefault:n,mediaList:o}}function n(t,e,i){var n={width:e,height:i,aspectratio:e/i},a=!0;return s.each(t,function(t,e){var i=e.match(p);if(i&&i[1]&&i[2]){var o=i[1],s=i[2][_r]();r(n[s],t,o)||(a=!1)}}),a}function r(t,e,i){return"min "===i?t>=e:"max "===i?e>=t:t===e}function a(t,e){return t.join(", ")===e.join(", ")}function o(t,e){e=e||{},c(e,function(e,i){if(null!=e){var n=t[i];if(u.hasClass(i)){e=l.normalizeToArray(e),n=l.normalizeToArray(n);var r=l.mappingToExists(n,e);t[i]=d(r,function(t){return t[zi]&&t.exist?f(t.exist,t[zi],!0):t.exist||t[zi]})}else t[i]=f(n,e,!0)}})}var s=t(Ar),l=t(".. / util / model "),u=t(". / Component "),c=s.each,h=s.clone,d=s.map,f=s.merge,p=/^(min|max)?(.+)$/;return e[xr]={constructor:e,setOption:function(t,e){t=h(t,!0);var n=this._optionBackup,r=i.call(this,t,e,!n);this._newBaseOption=r.baseOption,n?(o(n.baseOption,r.baseOption),r.timelineOptions[Wn]&&(n.timelineOptions=r.timelineOptions),r.mediaList[Wn]&&(n.mediaList=r.mediaList),r.mediaDefault&&(n.mediaDefault=r.mediaDefault)):this._optionBackup=r},mountOption:function(t){var e=this._optionBackup;return this._timelineOptions=d(e.timelineOptions,h),this._mediaList=d(e.mediaList,h),this._mediaDefault=h(e.mediaDefault),this._currentMediaIndices=[],h(t?e.baseOption:this._newBaseOption)},getTimelineOption:function(t){var e,i=this._timelineOptions;if(i[Wn]){var n=t[Re]("timeline ");n&&(e=h(i[n.getCurrentIndex()],!0))}return e},getMediaOption:function(){var t=this._api[dr](),e=this._api[hr](),i=this._mediaList,r=this._mediaDefault,o=[],s=[];if(!i[Wn]&&!r)return s;for(var l=0,u=i[Wn];u>l;l++)n(i[l].query,t,e)&&o.push(l);return!o[Wn]&&r&&(o=[-1]),o[Wn]&&!a(o,this._currentMediaIndices)&&(s=d(o,function(t){return h(-1===t?r[zi]:i[t][zi])})),this._currentMediaIndices=o,s}},e}),e("echarts / model / Series ",[Tr,Ar,".. / util / format ",".. / util / model ",". / Component ",". / mixin / colorPalette ",Sr],function(t){var e=t(Ar),i=t(".. / util / format "),n=t(".. / util / model "),r=t(". / Component "),a=t(". / mixin / colorPalette "),o=t(Sr),s=i[Ve],l=i[ze],u=r[jn]({type:"series.__base__ ",seriesIndex:0,coordinateSystem:null,defaultOption:null,legendDataProvider:null,visualColorAccessPath:"itemStyle.normal.color ",init:function(t,e,i){this[Dn]=this[Oe],this[De](t,i),this._dataBeforeProcessed=this.getInitialData(t,i),this._data=this._dataBeforeProcessed.cloneShallow()},mergeDefaultAndTheme:function(t,i){e.merge(t,i.getTheme().get(this.subType)),e.merge(t,this.getDefaultOption()),n[Pi](t.label,n.LABEL_OPTIONS),this.fillDataTextStyle(t.data)},mergeOption:function(t,i){t=e.merge(this[zi],t,!0),this.fillDataTextStyle(t.data);var n=this.getInitialData(t,i);n&&(this._data=n,this._dataBeforeProcessed=n.cloneShallow())},fillDataTextStyle:function(t){if(t)for(var e=0;e<t[Wn];e++)t[e]&&t[e].label&&n[Pi](t[e].label,n.LABEL_OPTIONS)},getInitialData:function(){},getData:function(t){return null==t?this._data:this._data.getLinkedData(t)},setData:function(t){this._data=t},getRawData:function(){return this._dataBeforeProcessed},coordDimToDataDim:function(t){return[t]},dataDimToCoordDim:function(t){return t},getBaseAxis:function(){var t=this[ln];return t&&t[Ie]&&t[Ie]()},formatTooltip:function(t,n){function r(t){return e.map(t,function(t,e){var r=a.getDimensionInfo(e),o=r&&r.type;return o===Pe?t:"time "===o?n?"":i.formatTime("yyyy / mm / dd hh: mm: ss ",t):l(t)})[mn](function(t){return!!t}).join(", ")}var a=this._data,o=this[ke](t),u=e[An](o)?r(o):l(o),c=a[Ci](t),h=a[gi](t,"color "),d='<span style="display: inline - block; margin - right: 5px; border - radius: 10px; width: 9px; height: 9px; background - color: '+h+'"></span>',f=this.name;return"\x00 - "===f&&(f=""),n?d+s(this.name)+": "+u:(f&&s(f)+Le)+d+(c?s(c)+": "+u:u)},ifEnableAnimation:function(){if(o.node)return!1;var t=this[Ce](vr);return t&&this[Kn]().count()>this[Ce]("animationThreshold ")&&(t=!1),t},restoreData:function(){this._data=this._dataBeforeProcessed.cloneShallow()},getColorFromPalette:function(t,e){var i=this[Te],n=a.getColorFromPalette.call(this,t,e);return n||(n=i.getColorFromPalette(t,e)),n},getAxisTooltipDataIndex:null});return e.mixin(u,n.dataFormatMixin),e.mixin(u,a),u}),e("echarts / model / Component ",[Tr,". / Model ",Ar,".. / util / component ",".. / util / clazz ",".. / util / layout ",". / mixin / boxLayout "],function(t){function e(t){var e=[];return n.each(l.getClassesByMainType(t),function(t){r.apply(e,t[xr].dependencies||[])}),n.map(e,function(t){return o.parseClassType(t).main})}var i=t(". / Model "),n=t(Ar),r=Array[xr].push,a=t(".. / util / component "),o=t(".. / util / clazz "),s=t(".. / util / layout "),l=i[jn]({type:"component ",id:"",name:"",mainType:"",subType:"",componentIndex:0,defaultOption:null,ecModel:null,dependentModels:[],uid:null,layoutMode:null,$constructor:function(t,e,r,o){i.call(this,t,e,r,o),n[jn](this,o),this.uid=a.getUID("componentModel ")},init:function(t,e,i){this[De](t,i)},mergeDefaultAndTheme:function(t,e){var i=this.layoutMode,r=i?s.getLayoutParams(t):{},a=e.getTheme();n.merge(t,a.get(this[Ne])),n.merge(t,this.getDefaultOption()),i&&s.mergeLayoutParam(t,r,i)},mergeOption:function(t){n.merge(this[zi],t,!0);var e=this.layoutMode;e&&s.mergeLayoutParam(this[zi],t,e)},optionUpdated:function(){},getDefaultOption:function(){if(!this.hasOwnProperty("__defaultOption ")){for(var t=[],e=this.constructor;e;){var i=e[xr].defaultOption;i&&t.push(i),e=e.superClass}for(var r={},a=t[Wn]-1;a>=0;a--)r=n.merge(r,t[a],!0);this.__defaultOption=r}return this.__defaultOption}});return o.enableClassManagement(l,{registerWhenExtend:!0}),a.enableSubTypeDefaulter(l),a.enableTopologicalTravel(l,e),n.mixin(l,t(". / mixin / boxLayout ")),l}),e("echarts / view / Component ",[Tr,"zrender / container / Group ",".. / util / component ",".. / util / clazz "],function(t){var e=t("zrender / container / Group "),i=t(".. / util / component "),n=t(".. / util / clazz "),r=function(){this.group=new e,this.uid=i.getUID("viewComponent ")};r[xr]={constructor:r,init:function(){},render:function(){},dispose:function(){}};var a=r[xr];return a.updateView=a[Qn]=a.updateVisual=function(){},n.enableClassExtend(r),n.enableClassManagement(r,{registerWhenExtend:!0}),r}),e("echarts / view / Chart ",[Tr,"zrender / container / Group ",".. / util / component ",".. / util / clazz "],function(t){function e(){this.group=new r,this.uid=a.getUID("viewChart ")}function i(t,e){if(t&&(t[Zn](e),"group "===t.type))for(var n=0;n<t.childCount();n++)i(t[di](n),e)}function n(t,e,n){var r=e&&e[zn],a=e&&e.name;if(null!=r)for(var o=r instanceof Array?r:[r],s=0,l=o[Wn];l>s;s++)i(t[Mi](o[s]),n);else if(a)for(var u=a instanceof Array?a:[a],s=0,l=u[Wn];l>s;s++){var r=t[Ae](u[s]);i(t[Mi](r),n)}else t[Se](function(t){i(t,n)})}var r=t("zrender / container / Group "),a=t(".. / util / component "),o=t(".. / util / clazz ");e[xr]={type:"chart ",init:function(){},render:function(){},highlight:function(t,e,i,r){n(t[Kn](),r,Li)},downplay:function(t,e,i,r){n(t[Kn](),r,ki)},remove:function(){this.group[cn]()},dispose:function(){}};var s=e[xr];return s.updateView=s[Qn]=s.updateVisual=function(t,e,i,n){this[Bn](t,e,i,n)},o.enableClassExtend(e),o.enableClassManagement(e,{registerWhenExtend:!0}),e}),e("echarts / util / graphic ",[Tr,Ar,"zrender / tool / path ","zrender / graphic / Path ",Mr,br,wr,"zrender / graphic / Gradient ","zrender / container / Group ","zrender / graphic / Image ","zrender / graphic / Text ","zrender / graphic / shape / Circle ","zrender / graphic / shape / Sector ","zrender / graphic / shape / Ring ","zrender / graphic / shape / Polygon ","zrender / graphic / shape / Polyline ","zrender / graphic / shape / Rect ","zrender / graphic / shape / Line ","zrender / graphic / shape / BezierCurve ","zrender / graphic / shape / Arc ","zrender / graphic / CompoundPath ","zrender / graphic / LinearGradient ","zrender / graphic / RadialGradient ",Me],function(t){function e(t){return null!=t&&"none "!=t}function i(t){return typeof t===yr?y.lift(t,-.1):t}function n(t){if(t.__hoverStlDirty){var n=t.style[ye],r=t.style.fill,a=t.__hoverStl;a.fill=a.fill||(e(r)?i(r):null),a[ye]=a[ye]||(e(n)?i(n):null);var o={};for(var s in a)a.hasOwnProperty(s)&&(o[s]=t.style[s]);t.__normalStl=o,t.__hoverStlDirty=!1}}function r(t){t.__isHover||(n(t),t.useHoverLayer?t.__zr&&t.__zr.addHover(t,t.__hoverStl):(t[Ln](t.__hoverStl),t.z2+=1),t.__isHover=!0)}function a(t){if(t.__isHover){var e=t.__normalStl;t.useHoverLayer?t.__zr&&t.__zr.removeHover(t):(e&&t[Ln](e),t.z2-=1),t.__isHover=!1}}function o(t){"group "===t.type?t[kn](function(t){"group "!==t.type&&r(t)}):r(t)}function s(t){"group "===t.type?t[kn](function(t){"group "!==t.type&&a(t)}):a(t)}function l(t,e){t.__hoverStl=t[oi]||e||{},t.__hoverStlDirty=!0,t.__isHover&&n(t)}function u(){!this.__isEmphasis&&o(this)}function c(){!this.__isEmphasis&&s(this)}function h(){this.__isEmphasis=!0,o(this)}function d(){this.__isEmphasis=!1,s(this)}function f(t,e,i,n,r,a){typeof r===Sn&&(a=r,r=null);var o=n&&(n.ifEnableAnimation?n.ifEnableAnimation():n[Ce](vr));if(o){var s=t?"Update ":"",l=n&&n[Ce]("animationDuration "+s),u=n&&n[Ce]("animationEasing "+s),c=n&&n[Ce]("animationDelay "+s);typeof c===Sn&&(c=c(r)),l>0?e.animateTo(i,l,c||0,u,a):(e.attr(i),a&&a())}else e.attr(i),a&&a()}var p=t(Ar),v=t("zrender / tool / path "),g=Math.round,m=t("zrender / graphic / Path "),y=t(Mr),x=t(br),_=t(wr),w=(t("zrender / graphic / Gradient "),{});return w.Group=t("zrender / container / Group "),w.Image=t("zrender / graphic / Image "),w.Text=t("zrender / graphic / Text "),w[be]=t("zrender / graphic / shape / Circle "),w[_i]=t("zrender / graphic / shape / Sector "),w.Ring=t("zrender / graphic / shape / Ring "),w[we]=t("zrender / graphic / shape / Polygon "),w[xi]=t("zrender / graphic / shape / Polyline "),w.Rect=t("zrender / graphic / shape / Rect "),w.Line=t("zrender / graphic / shape / Line "),w.BezierCurve=t("zrender / graphic / shape / BezierCurve "),w.Arc=t("zrender / graphic / shape / Arc "),w.CompoundPath=t("zrender / graphic / CompoundPath "),w.LinearGradient=t("zrender / graphic / LinearGradient "),w.RadialGradient=t("zrender / graphic / RadialGradient "),w.BoundingRect=t(Me),w.extendShape=function(t){return m[jn](t)},w.extendPath=function(t,e){return v.extendFromString(t,e)},w.makePath=function(t,e,i,n){var r=v.createFromString(t,e),a=r[en]();if(i){var o=a.width/a[nr];if(n===Ji){var s,l=i[nr]*o;l<=i.width?s=i[nr]:(l=i.width,s=l/o);var u=i.x+i.width/2,c=i.y+i[nr]/2;i.x=u-l/2,i.y=c-s/2,i.width=l,i[nr]=s}this.resizePath(r,i)}return r},w.mergePath=v.mergePath,w.resizePath=function(t,e){if(t[_e]){var i=t[en](),n=i.calculateTransform(e);t[_e](n)}},w.subPixelOptimizeLine=function(t){var e=w.subPixelOptimize,i=t.shape,n=t.style[xe];return g(2*i.x1)===g(2*i.x2)&&(i.x1=i.x2=e(i.x1,n,!0)),g(2*i.y1)===g(2*i.y2)&&(i.y1=i.y2=e(i.y1,n,!0)),t},w.subPixelOptimizeRect=function(t){var e=w.subPixelOptimize,i=t.shape,n=t.style[xe],r=i.x,a=i.y,o=i.width,s=i[nr];return i.x=e(i.x,n,!0),i.y=e(i.y,n,!0),i.width=Math.max(e(r+o,n,!1)-i.x,0===o?0:1),i[nr]=Math.max(e(a+s,n,!1)-i.y,0===s?0:1),t},w.subPixelOptimize=function(t,e,i){var n=g(2*t);return(n+g(e))%2===0?n/2:(n+(i?1:-1))/2},w[ri]=function(t,e){"group "===t.type?t[kn](function(t){"group "!==t.type&&l(t,e)}):l(t,e),t.on(En,u).on(On,c),t.on(Li,h).on(ki,d)},w[me]=function(t,e,i){var n=e[Ce]($i)||mi,r=n[gn](mi)>=0?"white ":i,a=e[fr](on);p[jn](t,{textDistance:e[Ce](ge)||5,textFont:a[rn](),textPosition:n,textFill:a[nn]()||r})},w[ui]=function(t,e,i,n,r){f(!0,t,e,i,n,r)},w[Xe]=function(t,e,i,n,r){f(!1,t,e,i,n,r)},w.getTransform=function(t,e){for(var i=x.identity([]);t&&t!==e;)x.mul(i,t[ve](),i),t=t[pe];return i},w[_e]=function(t,e,i){return i&&(e=x.invert([],e)),_[_e]([],t,e)},w.transformDirection=function(t,e,i){var n=0===e[4]||0===e[5]||0===e[0]?1:Math.abs(2*e[4]/e[0]),r=0===e[4]||0===e[5]||0===e[2]?1:Math.abs(2*e[4]/e[2]),a=["left "===t?-n:"right "===t?n:0,"top "===t?-r:t===rr?r:0];return a=w[_e](a,e,i),Math.abs(a[0])>Math.abs(a[1])?a[0]>0?"right ":"left ":a[1]>0?rr:"top "},w.groupTransition=function(t,e,i){function n(t){var e={};return t[kn](function(t){!t.isGroup&&t.anid&&(e[t.anid]=t)}),e}function r(t){var e={position:_.clone(t[$i]),rotation:t[ni]};return t.shape&&(e.shape=p[jn]({},t.shape)),e}if(t&&e){var a=n(t);e[kn](function(t){if(!t.isGroup&&t.anid){var e=a[t.anid];if(e){var n=r(t);t.attr(r(e)),w[ui](t,n,i,t[zn])}}})}},w}),e("zrender / zrender ",[Tr,". / core / guid ",". / core / env ",". / Handler ",". / Storage ",". / animation / Animation ",". / dom / HandlerProxy ",". / Painter "],function(t){function e(t){delete c[t]}var i=t(". / core / guid "),n=t(". / core / env "),r=t(". / Handler "),a=t(". / Storage "),o=t(". / animation / Animation "),s=t(". / dom / HandlerProxy "),l=!n[cr],u={canvas:t(". / Painter ")},c={},h={};h.version="3.1.3 ",h.init=function(t,e){var n=new d(i(),t,e);return c[n.id]=n,n},h[Hn]=function(t){if(t)t[Hn]();else{for(var e in c)c[e][Hn]();c={}}return h},h.getInstance=function(t){return c[t]},h.registerPainter=function(t,e){u[t]=e};var d=function(t,e,i){i=i||{},this.dom=e,this.id=t;var c=this,h=new a,d=i.renderer;if(l){if(!u.vml)throw new Error("You need to require 'zrender/vml/vml'to support IE8 ");d="vml "}else d&&u[d]||(d=mr);var f=new u[d](e,h,i);this[lr]=h,this.painter=f;var p=n.node?null:new s(f.getViewportRoot());this.handler=new r(h,f,p),this[vr]=new o({stage:{update:function(){c._needsRefresh&&c.refreshImmediately(),c._needsRefreshHover&&c.refreshHoverImmediately()
}}}),this[vr].start(),this._needsRefresh;var v=h.delFromMap,g=h.addToMap;h.delFromMap=function(t){var e=h.get(t);v.call(h,t),e&&e.removeSelfFromZr(c)},h.addToMap=function(t){g.call(h,t),t.addSelfToZr(c)}};return d[xr]={constructor:d,getId:function(){return this.id},add:function(t){this[lr].addRoot(t),this._needsRefresh=!0},remove:function(t){this[lr].delRoot(t),this._needsRefresh=!0},configLayer:function(t,e){this.painter.configLayer(t,e),this._needsRefresh=!0},refreshImmediately:function(){this._needsRefresh=!1,this.painter.refresh(),this._needsRefresh=!1},refresh:function(){this._needsRefresh=!0},addHover:function(t,e){this.painter.addHover&&(this.painter.addHover(t,e),this.refreshHover())},removeHover:function(t){this.painter.removeHover&&(this.painter.removeHover(t),this.refreshHover())},clearHover:function(){this.painter.clearHover&&(this.painter.clearHover(),this.refreshHover())},refreshHover:function(){this._needsRefreshHover=!0},refreshHoverImmediately:function(){this._needsRefreshHover=!1,this.painter.refreshHover&&this.painter.refreshHover()},resize:function(){this.painter[gr](),this.handler[gr]()},clearAnimation:function(){this[vr].clear()},getWidth:function(){return this.painter[dr]()},getHeight:function(){return this.painter[hr]()},pathToImage:function(t,e,n){var r=i();return this.painter.pathToImage(r,t,e,n)},setCursorStyle:function(t){this.handler.setCursorStyle(t)},on:function(t,e,i){this.handler.on(t,e,i)},off:function(t,e){this.handler.off(t,e)},trigger:function(t,e){this.handler[Zn](t,e)},clear:function(){this[lr].delRoot(),this.painter.clear()},dispose:function(){this[vr].stop(),this.clear(),this[lr][Hn](),this.painter[Hn](),this.handler[Hn](),this[vr]=this[lr]=this.painter=this.handler=null,e(this.id)}},h}),e("zrender / mixin / Eventful ",[Tr],function(){var t=Array[xr].slice,e=function(){this._$handlers={}};return e[xr]={constructor:e,one:function(t,e,i){var n=this._$handlers;if(!e||!t)return this;n[t]||(n[t]=[]);for(var r=0;r<n[t][Wn];r++)if(n[t][r].h===e)return this;return n[t].push({h:e,one:!0,ctx:i||this}),this},on:function(t,e,i){var n=this._$handlers;if(!e||!t)return this;n[t]||(n[t]=[]);for(var r=0;r<n[t][Wn];r++)if(n[t][r].h===e)return this;return n[t].push({h:e,one:!1,ctx:i||this}),this},isSilent:function(t){var e=this._$handlers;return e[t]&&e[t][Wn]},off:function(t,e){var i=this._$handlers;if(!t)return this._$handlers={},this;if(e){if(i[t]){for(var n=[],r=0,a=i[t][Wn];a>r;r++)i[t][r].h!=e&&n.push(i[t][r]);i[t]=n}i[t]&&0===i[t][Wn]&&delete i[t]}else delete i[t];return this},trigger:function(e){if(this._$handlers[e]){var i=arguments,n=i[Wn];n>3&&(i=t.call(i,1));for(var r=this._$handlers[e],a=r[Wn],o=0;a>o;){switch(n){case 1:r[o].h.call(r[o].ctx);break;case 2:r[o].h.call(r[o].ctx,i[1]);break;case 3:r[o].h.call(r[o].ctx,i[1],i[2]);break;default:r[o].h.apply(r[o].ctx,i)}r[o].one?(r[Gn](o,1),a--):o++}}return this},triggerWithContext:function(e){if(this._$handlers[e]){var i=arguments,n=i[Wn];n>4&&(i=t.call(i,1,i[Wn]-1));for(var r=i[i[Wn]-1],a=this._$handlers[e],o=a[Wn],s=0;o>s;){switch(n){case 1:a[s].h.call(r);break;case 2:a[s].h.call(r,i[1]);break;case 3:a[s].h.call(r,i[1],i[2]);break;default:a[s].h.apply(r,i)}a[s].one?(a[Gn](s,1),o--):s++}}return this}},e}),e(Mr,[Tr],function(){function t(t){return t=Math.round(t),0>t?0:t>255?255:t}function e(t){return t=Math.round(t),0>t?0:t>360?360:t}function i(t){return 0>t?0:t>1?1:t}function n(e){return t(e[Wn]&&" % "===e.charAt(e[Wn]-1)?parseFloat(e)/100*255:parseInt(e,10))}function r(t){return i(t[Wn]&&" % "===t.charAt(t[Wn]-1)?parseFloat(t)/100:parseFloat(t))}function a(t,e,i){return 0>i?i+=1:i>1&&(i-=1),1>6*i?t+(e-t)*i*6:1>2*i?e:2>3*i?t+(e-t)*(2/3-i)*6:t}function o(t,e,i){return t+(e-t)*i}function s(t){if(t){t+="";var e=t[Tn](/ /g,"")[_r]();if(e in m)return m[e].slice();if("#"!==e.charAt(0)){var i=e[gn](" ("),a=e[gn](")");if(-1!==i&&a+1===e[Wn]){var o=e.substr(0,i),s=e.substr(i+1,a-(i+1)).split(", "),u=1;switch(o){case"rgba ":if(4!==s[Wn])return;u=r(s.pop());case"rgb ":if(3!==s[Wn])return;return[n(s[0]),n(s[1]),n(s[2]),u];case"hsla ":if(4!==s[Wn])return;return s[3]=r(s[3]),l(s);case"hsl ":if(3!==s[Wn])return;return l(s);default:return}}}else{if(4===e[Wn]){var c=parseInt(e.substr(1),16);if(!(c>=0&&4095>=c))return;return[(3840&c)>>4|(3840&c)>>8,240&c|(240&c)>>4,15&c|(15&c)<<4,1]}if(7===e[Wn]){var c=parseInt(e.substr(1),16);if(!(c>=0&&16777215>=c))return;return[(16711680&c)>>16,(65280&c)>>8,255&c,1]}}}}function l(e){var i=(parseFloat(e[0])%360+360)%360/360,n=r(e[1]),o=r(e[2]),s=.5>=o?o*(n+1):o+n-o*n,l=2*o-s,u=[t(255*a(l,s,i+1/3)),t(255*a(l,s,i)),t(255*a(l,s,i-1/3))];return 4===e[Wn]&&(u[3]=e[3]),u}function u(t){if(t){var e,i,n=t[0]/255,r=t[1]/255,a=t[2]/255,o=Math.min(n,r,a),s=Math.max(n,r,a),l=s-o,u=(s+o)/2;if(0===l)e=0,i=0;else{i=.5>u?l/(s+o):l/(2-s-o);var c=((s-n)/6+l/2)/l,h=((s-r)/6+l/2)/l,d=((s-a)/6+l/2)/l;n===s?e=d-h:r===s?e=1/3+c-d:a===s&&(e=2/3+h-c),0>e&&(e+=1),e>1&&(e-=1)}var f=[360*e,i,u];return null!=t[3]&&f.push(t[3]),f}}function c(t,e){var i=s(t);if(i){for(var n=0;3>n;n++)i[n]=0>e?i[n]*(1-e)|0:(255-i[n])*e+i[n]|0;return g(i,4===i[Wn]?"rgba ":"rgb ")}}function h(t){var e=s(t);return e?((1<<24)+(e[0]<<16)+(e[1]<<8)+ +e[2]).toString(16).slice(1):void 0}function d(e,i,n){if(i&&i[Wn]&&e>=0&&1>=e){n=n||[0,0,0,0];var r=e*(i[Wn]-1),a=Math.floor(r),s=Math.ceil(r),l=i[a],u=i[s],c=r-a;return n[0]=t(o(l[0],u[0],c)),n[1]=t(o(l[1],u[1],c)),n[2]=t(o(l[2],u[2],c)),n[3]=t(o(l[3],u[3],c)),n}}function f(e,n,r){if(n&&n[Wn]&&e>=0&&1>=e){var a=e*(n[Wn]-1),l=Math.floor(a),u=Math.ceil(a),c=s(n[l]),h=s(n[u]),d=a-l,f=g([t(o(c[0],h[0],d)),t(o(c[1],h[1],d)),t(o(c[2],h[2],d)),i(o(c[3],h[3],d))],"rgba ");return r?{color:f,leftIndex:l,rightIndex:u,value:a}:f}}function p(t,i,n,a){return t=s(t),t?(t=u(t),null!=i&&(t[0]=e(i)),null!=n&&(t[1]=r(n)),null!=a&&(t[2]=r(a)),g(l(t),"rgba ")):void 0}function v(t,e){return t=s(t),t&&null!=e?(t[3]=i(e),g(t,"rgba ")):void 0}function g(t,e){var i=t[0]+", "+t[1]+", "+t[2];return("rgba "===e||"hsva "===e||"hsla "===e)&&(i+=", "+t[3]),e+" ("+i+")"}var m={transparent:[0,0,0,0],aliceblue:[240,248,255,1],antiquewhite:[250,235,215,1],aqua:[0,255,255,1],aquamarine:[127,255,212,1],azure:[240,255,255,1],beige:[245,245,220,1],bisque:[255,228,196,1],black:[0,0,0,1],blanchedalmond:[255,235,205,1],blue:[0,0,255,1],blueviolet:[138,43,226,1],brown:[165,42,42,1],burlywood:[222,184,135,1],cadetblue:[95,158,160,1],chartreuse:[127,255,0,1],chocolate:[210,105,30,1],coral:[255,127,80,1],cornflowerblue:[100,149,237,1],cornsilk:[255,248,220,1],crimson:[220,20,60,1],cyan:[0,255,255,1],darkblue:[0,0,139,1],darkcyan:[0,139,139,1],darkgoldenrod:[184,134,11,1],darkgray:[169,169,169,1],darkgreen:[0,100,0,1],darkgrey:[169,169,169,1],darkkhaki:[189,183,107,1],darkmagenta:[139,0,139,1],darkolivegreen:[85,107,47,1],darkorange:[255,140,0,1],darkorchid:[153,50,204,1],darkred:[139,0,0,1],darksalmon:[233,150,122,1],darkseagreen:[143,188,143,1],darkslateblue:[72,61,139,1],darkslategray:[47,79,79,1],darkslategrey:[47,79,79,1],darkturquoise:[0,206,209,1],darkviolet:[148,0,211,1],deeppink:[255,20,147,1],deepskyblue:[0,191,255,1],dimgray:[105,105,105,1],dimgrey:[105,105,105,1],dodgerblue:[30,144,255,1],firebrick:[178,34,34,1],floralwhite:[255,250,240,1],forestgreen:[34,139,34,1],fuchsia:[255,0,255,1],gainsboro:[220,220,220,1],ghostwhite:[248,248,255,1],gold:[255,215,0,1],goldenrod:[218,165,32,1],gray:[128,128,128,1],green:[0,128,0,1],greenyellow:[173,255,47,1],grey:[128,128,128,1],honeydew:[240,255,240,1],hotpink:[255,105,180,1],indianred:[205,92,92,1],indigo:[75,0,130,1],ivory:[255,255,240,1],khaki:[240,230,140,1],lavender:[230,230,250,1],lavenderblush:[255,240,245,1],lawngreen:[124,252,0,1],lemonchiffon:[255,250,205,1],lightblue:[173,216,230,1],lightcoral:[240,128,128,1],lightcyan:[224,255,255,1],lightgoldenrodyellow:[250,250,210,1],lightgray:[211,211,211,1],lightgreen:[144,238,144,1],lightgrey:[211,211,211,1],lightpink:[255,182,193,1],lightsalmon:[255,160,122,1],lightseagreen:[32,178,170,1],lightskyblue:[135,206,250,1],lightslategray:[119,136,153,1],lightslategrey:[119,136,153,1],lightsteelblue:[176,196,222,1],lightyellow:[255,255,224,1],lime:[0,255,0,1],limegreen:[50,205,50,1],linen:[250,240,230,1],magenta:[255,0,255,1],maroon:[128,0,0,1],mediumaquamarine:[102,205,170,1],mediumblue:[0,0,205,1],mediumorchid:[186,85,211,1],mediumpurple:[147,112,219,1],mediumseagreen:[60,179,113,1],mediumslateblue:[123,104,238,1],mediumspringgreen:[0,250,154,1],mediumturquoise:[72,209,204,1],mediumvioletred:[199,21,133,1],midnightblue:[25,25,112,1],mintcream:[245,255,250,1],mistyrose:[255,228,225,1],moccasin:[255,228,181,1],navajowhite:[255,222,173,1],navy:[0,0,128,1],oldlace:[253,245,230,1],olive:[128,128,0,1],olivedrab:[107,142,35,1],orange:[255,165,0,1],orangered:[255,69,0,1],orchid:[218,112,214,1],palegoldenrod:[238,232,170,1],palegreen:[152,251,152,1],paleturquoise:[175,238,238,1],palevioletred:[219,112,147,1],papayawhip:[255,239,213,1],peachpuff:[255,218,185,1],peru:[205,133,63,1],pink:[255,192,203,1],plum:[221,160,221,1],powderblue:[176,224,230,1],purple:[128,0,128,1],red:[255,0,0,1],rosybrown:[188,143,143,1],royalblue:[65,105,225,1],saddlebrown:[139,69,19,1],salmon:[250,128,114,1],sandybrown:[244,164,96,1],seagreen:[46,139,87,1],seashell:[255,245,238,1],sienna:[160,82,45,1],silver:[192,192,192,1],skyblue:[135,206,235,1],slateblue:[106,90,205,1],slategray:[112,128,144,1],slategrey:[112,128,144,1],snow:[255,250,250,1],springgreen:[0,255,127,1],steelblue:[70,130,180,1],tan:[210,180,140,1],teal:[0,128,128,1],thistle:[216,191,216,1],tomato:[255,99,71,1],turquoise:[64,224,208,1],violet:[238,130,238,1],wheat:[245,222,179,1],white:[255,255,255,1],whitesmoke:[245,245,245,1],yellow:[255,255,0,1],yellowgreen:[154,205,50,1]};return{parse:s,lift:c,toHex:h,fastMapToColor:d,mapToColor:f,modifyHSL:p,modifyAlpha:v,stringify:g}}),e("zrender / core / timsort ",[],function(){function t(t){for(var e=0;t>=l;)e|=1&t,t>>=1;return t+e}function e(t,e,n,r){var a=e+1;if(a===n)return 1;if(r(t[a++],t[e])<0){for(;n>a&&r(t[a],t[a-1])<0;)a++;i(t,e,a)}else for(;n>a&&r(t[a],t[a-1])>=0;)a++;return a-e}function i(t,e,i){for(i--;i>e;){var n=t[e];t[e++]=t[i],t[i--]=n}}function n(t,e,i,n,r){for(n===e&&n++;i>n;n++){for(var a,o=t[n],s=e,l=n;l>s;)a=s+l>>>1,r(o,t[a])<0?l=a:s=a+1;var u=n-s;switch(u){case 3:t[s+3]=t[s+2];case 2:t[s+2]=t[s+1];case 1:t[s+1]=t[s];break;default:for(;u>0;)t[s+u]=t[s+u-1],u--}t[s]=o}}function r(t,e,i,n,r,a){var o=0,s=0,l=1;if(a(t,e[i+r])>0){for(s=n-r;s>l&&a(t,e[i+r+l])>0;)o=l,l=(l<<1)+1,0>=l&&(l=s);l>s&&(l=s),o+=r,l+=r}else{for(s=r+1;s>l&&a(t,e[i+r-l])<=0;)o=l,l=(l<<1)+1,0>=l&&(l=s);l>s&&(l=s);var u=o;o=r-l,l=r-u}for(o++;l>o;){var c=o+(l-o>>>1);a(t,e[i+c])>0?o=c+1:l=c}return l}function a(t,e,i,n,r,a){var o=0,s=0,l=1;if(a(t,e[i+r])<0){for(s=r+1;s>l&&a(t,e[i+r-l])<0;)o=l,l=(l<<1)+1,0>=l&&(l=s);l>s&&(l=s);var u=o;o=r-l,l=r-u}else{for(s=n-r;s>l&&a(t,e[i+r+l])>=0;)o=l,l=(l<<1)+1,0>=l&&(l=s);l>s&&(l=s),o+=r,l+=r}for(o++;l>o;){var c=o+(l-o>>>1);a(t,e[i+c])<0?l=c:o=c+1}return l}function o(t,e){function i(t,e){d[y]=t,f[y]=e,y+=1}function n(){for(;y>1;){var t=y-2;if(t>=1&&f[t-1]<=f[t]+f[t+1]||t>=2&&f[t-2]<=f[t]+f[t-1])f[t-1]<f[t+1]&&t--;else if(f[t]>f[t+1])break;s(t)}}function o(){for(;y>1;){var t=y-2;t>0&&f[t-1]<f[t+1]&&t--,s(t)}}function s(i){var n=d[i],o=f[i],s=d[i+1],u=f[i+1];f[i]=o+u,i===y-3&&(d[i+1]=d[i+2],f[i+1]=f[i+2]),y--;var c=a(t[s],t,n,o,0,e);n+=c,o-=c,0!==o&&(u=r(t[n+o-1],t,s,u,u-1,e),0!==u&&(u>=o?l(n,o,s,u):h(n,o,s,u)))}function l(i,n,o,s){var l=0;for(l=0;n>l;l++)x[l]=t[i+l];var c=0,h=o,d=i;if(t[d++]=t[h++],0!==--s){if(1===n){for(l=0;s>l;l++)t[d+l]=t[h+l];return void(t[d+s]=x[c])}for(var f,v,g,m=p;;){f=0,v=0,g=!1;do if(e(t[h],x[c])<0){if(t[d++]=t[h++],v++,f=0,0===--s){g=!0;break}}else if(t[d++]=x[c++],f++,v=0,1===--n){g=!0;break}while(m>(f|v));if(g)break;do{if(f=a(t[h],x,c,n,0,e),0!==f){for(l=0;f>l;l++)t[d+l]=x[c+l];if(d+=f,c+=f,n-=f,1>=n){g=!0;break}}if(t[d++]=t[h++],0===--s){g=!0;break}if(v=r(x[c],t,h,s,0,e),0!==v){for(l=0;v>l;l++)t[d+l]=t[h+l];if(d+=v,h+=v,s-=v,0===s){g=!0;break}}if(t[d++]=x[c++],1===--n){g=!0;break}m--}while(f>=u||v>=u);if(g)break;0>m&&(m=0),m+=2}if(p=m,1>p&&(p=1),1===n){for(l=0;s>l;l++)t[d+l]=t[h+l];t[d+s]=x[c]}else{if(0===n)throw new Error;for(l=0;n>l;l++)t[d+l]=x[c+l]}}else for(l=0;n>l;l++)t[d+l]=x[c+l]}function h(i,n,o,s){var l=0;for(l=0;s>l;l++)x[l]=t[o+l];var c=i+n-1,h=s-1,d=o+s-1,f=0,v=0;if(t[d--]=t[c--],0!==--n){if(1===s){for(d-=n,c-=n,v=d+1,f=c+1,l=n-1;l>=0;l--)t[v+l]=t[f+l];return void(t[d]=x[h])}for(var g=p;;){var m=0,y=0,_=!1;do if(e(x[h],t[c])<0){if(t[d--]=t[c--],m++,y=0,0===--n){_=!0;break}}else if(t[d--]=x[h--],y++,m=0,1===--s){_=!0;break}while(g>(m|y));if(_)break;do{if(m=n-a(x[h],t,i,n,n-1,e),0!==m){for(d-=m,c-=m,n-=m,v=d+1,f=c+1,l=m-1;l>=0;l--)t[v+l]=t[f+l];if(0===n){_=!0;break}}if(t[d--]=x[h--],1===--s){_=!0;break}if(y=s-r(t[c],x,0,s,s-1,e),0!==y){for(d-=y,h-=y,s-=y,v=d+1,f=h+1,l=0;y>l;l++)t[v+l]=x[f+l];if(1>=s){_=!0;break}}if(t[d--]=t[c--],0===--n){_=!0;break}g--}while(m>=u||y>=u);if(_)break;0>g&&(g=0),g+=2}if(p=g,1>p&&(p=1),1===s){for(d-=n,c-=n,v=d+1,f=c+1,l=n-1;l>=0;l--)t[v+l]=t[f+l];t[d]=x[h]}else{if(0===s)throw new Error;for(f=d-(s-1),l=0;s>l;l++)t[f+l]=x[l]}}else for(f=d-(s-1),l=0;s>l;l++)t[f+l]=x[l]}var d,f,p=u,v=0,g=c,m=0,y=0;v=t[Wn],2*c>v&&(g=v>>>1);var x=[];m=120>v?5:1542>v?10:119151>v?19:40,d=[],f=[],this.mergeRuns=n,this.forceMergeRuns=o,this.pushRun=i}function s(i,r,a,s){a||(a=0),s||(s=i[Wn]);var u=s-a;if(!(2>u)){var c=0;if(l>u)return c=e(i,a,s,r),void n(i,a,s,a+c,r);var h=new o(i,r),d=t(u);do{if(c=e(i,a,s,r),d>c){var f=u;f>d&&(f=d),n(i,a,a+f,a+c,r),c=f}h.pushRun(a,c),h.mergeRuns(),u-=c,a+=c}while(0!==u);h.forceMergeRuns()}}var l=32,u=7,c=256;return s}),e("echarts / visual / seriesColor ",[Tr,"zrender / graphic / Gradient "],function(t){var e=t("zrender / graphic / Gradient ");return function(t){function i(i){var n=(i.visualColorAccessPath||"itemStyle.normal.color ").split("."),r=i[Kn](),a=i.get(n)||i.getColorFromPalette(i.get("name "));r[hn]("color ",a),t.isSeriesFiltered(i)||(typeof a!==Sn||a instanceof e||r.each(function(t){r[Ue](t,"color ",a(i[In](t)))}),r.each(function(t){var e=r[hi](t),i=e.get(n,!0);null!=i&&r[Ue](t,"color ",i)}))}t.eachRawSeries(i)}}),e("echarts / preprocessor / backwardCompat ",[Tr,Ar,". / helper / compatStyle "],function(t){function e(t,e){e=e.split(", ");for(var i=t,n=0;n<e[Wn]&&(i=i&&i[e[n]],null!=i);n++);return i}function i(t,e,i,n){e=e.split(", ");for(var r,a=t,o=0;o<e[Wn]-1;o++)r=e[o],null==a[r]&&(a[r]={}),a=a[r];(n||null==a[e[o]])&&(a[e[o]]=i)}function n(t){u(o,function(e){e[0]in t&&!(e[1]in t)&&(t[e[1]]=t[e[0]])})}var r=t(Ar),a=t(". / helper / compatStyle "),o=[["x ","left "],["y ","top "],["x2 ","right "],["y2 ",rr]],s=["grid ","geo ","parallel ","legend ","toolbox ","title ","visualMap ","dataZoom ","timeline "],l=["bar ","boxplot ","candlestick ","chord ","effectScatter ","funnel ","gauge ","lines ","graph ","heatmap ","line ","map ","parallel ","pie ","radar ","sankey ","scatter ","treemap "],u=r.each;return function(t){u(t[Fn],function(t){if(r[Yn](t)){var o=t.type;if(a(t),("pie "===o||"gauge "===o)&&null!=t.clockWise&&(t[Ye]=t.clockWise),"gauge "===o){var s=e(t,"pointer.color ");null!=s&&i(t,"itemStyle.normal.color ",s)}for(var u=0;u<l[Wn];u++)if(l[u]===t.type){n(t);break}}}),t.dataRange&&(t.visualMap=t.dataRange),u(s,function(e){var i=t[e];i&&(r[An](i)||(i=[i]),u(i,function(t){n(t)}))})}}),e("echarts / loading /
            default ",[Tr,".. / util / graphic ",Ar],function(t){var e=t(".. / util / graphic "),i=t(Ar),n=Math.PI;return function(t,r){r=r||{},i[qn](r,{text:"loading ",color:"#c23531 ",textColor:"#000 ",maskColor:"rgba(255, 255, 255, 0.8)",zlevel:0});var a=new e.Rect({style:{fill:r.maskColor},zlevel:r[Cn],z:1e4}),o=new e.Arc({shape:{startAngle:-n/2,endAngle:-n/2+.1,r:10},style:{stroke:r.color,lineCap:"round ",lineWidth:5},zlevel:r[Cn],z:10001}),s=new e.Rect({style:{fill:"none ",text:r.text,textPosition:"right ",textDistance:10,textFill:r.textColor},zlevel:r[Cn],z:10001});o.animateShape(!0).when(1e3,{endAngle:3*n/2}).start("circularInOut "),o.animateShape(!0).when(1e3,{startAngle:3*n/2}).delay(300).start("circularInOut ");var l=new e.Group;return l.add(o),l.add(s),l.add(a),l[gr]=function(){var e=t[dr]()/2,i=t[hr]()/2;o[ci]({cx:e,cy:i});var n=o.shape.r;s[ci]({x:e-n,y:i-n,width:2*n,height:2*n}),a[ci]({x:0,y:0,width:t[dr](),height:t[hr]()})},l[gr](),l}}),e("echarts / model / Model ",[Tr,Ar,".. / util / clazz ",". / mixin / lineStyle ",". / mixin / areaStyle ",". / mixin / textStyle ",". / mixin / itemStyle "],function(t){function e(t,e,i){this.parentModel=e,this[Te]=i,this[zi]=t}var i=t(Ar),n=t(".. / util / clazz ");e[xr]={constructor:e,init:null,mergeOption:function(t){i.merge(this[zi],t,!0)},get:function(t,e){if(!t)return this[zi];typeof t===yr&&(t=t.split("."));for(var i=this[zi],n=this.parentModel,r=0;r<t[Wn]&&(!t[r]||(i=i&&"object "==typeof i?i[t[r]]:null,null!=i));r++);return null==i&&n&&!e&&(i=n.get(t)),i},getShallow:function(t,e){var i=this[zi],n=null==i?i:i[t],r=this.parentModel;return null==n&&r&&!e&&(n=r[Ce](t)),n},getModel:function(t,i){var n=this.get(t,!0),r=this.parentModel,a=new e(n,i||r&&r[fr](t),this[Te]);return a},isEmpty:function(){return null==this[zi]},restoreData:function(){},clone:function(){var t=this.constructor;return new t(i.clone(this[zi]))},setReadOnly:function(t){n.setReadOnly(this,t)}},n.enableClassExtend(e);var r=i.mixin;return r(e,t(". / mixin / lineStyle ")),r(e,t(". / mixin / areaStyle ")),r(e,t(". / mixin / textStyle ")),r(e,t(". / mixin / itemStyle ")),e}),e("echarts / util / number ",[Tr],function(){function t(t){return t[Tn](/^\s+/,"")[Tn](/\s+$/,"")}var e={},i=1e-4;return e[Ge]=function(t,e,i,n){var r=e[1]-e[0],a=i[1]-i[0];if(0===r)return 0===a?i[0]:(i[0]+i[1])/2;if(n)if(r>0){if(t<=e[0])return i[0];if(t>=e[1])return i[1]}else{if(t>=e[0])return i[0];if(t<=e[1])return i[1]}else{if(t===e[0])return i[0];if(t===e[1])return i[1]}return(t-e[0])/r*a+i[0]},e[We]=function(e,i){switch(e){case Ji:case Qi:e="50 % ";break;case"left ":case"top ":e="0 % ";break;case"right ":case rr:e="100 % "}return typeof e===yr?t(e).match(/%$/)?parseFloat(e)/100*i:parseFloat(e):null==e?0/0:+e},e.round=function(t,e){return null==e&&(e=10),+(+t)[Ii](e)},e.asc=function(t){return t.sort(function(t,e){return t-e}),t},e.getPrecision=function(t){if(t=+t,isNaN(t))return 0;for(var e=1,i=0;Math.round(t*e)/e!==t;)e*=10,i++;return i},e.getPrecisionSafe=function(t){var e=t.toString(),i=e[gn](".");return 0>i?0:e[Wn]-1-i},e.getPixelPrecision=function(t,e){var i=Math.log,n=Math.LN10,r=Math.floor(i(t[1]-t[0])/n),a=Math.round(i(Math.abs(e[1]-e[0]))/n);return Math.max(-r+a,0)},e.MAX_SAFE_INTEGER=9007199254740991,e.remRadian=function(t){var e=2*Math.PI;return(t%e+e)%e},e.isRadianAroundZero=function(t){return t>-i&&i>t},e.parseDate=function(t){if(t instanceof Date)return t;if(typeof t===yr){var e=new Date(t);return isNaN(+e)&&(e=new Date(new Date(t[Tn](/-/g," / "))-new Date("1970 / 01 / 01 "))),e}return new Date(Math.round(t))},e.quantity=function(t){return Math.pow(10,Math.floor(Math.log(t)/Math.LN10))},e.nice=function(t,i){var n,r=e.quantity(t),a=t/r;return n=i?1.5>a?1:2.5>a?2:4>a?3:7>a?5:10:1>a?1:2>a?2:3>a?3:5>a?5:10,n*r},e}),e("echarts / util / format ",[Tr,Ar,". / number ","zrender / contain / text "],function(t){var e=t(Ar),i=t(". / number "),n=t("zrender / contain / text "),r={};r[ze]=function(t){return isNaN(t)?" - ":(t=(t+"").split("."),t[0][Tn](/(\d{1,3})(?=(?:\d{3})+(?!\d))/g,"$1, ")+(t[Wn]>1?"."+t[1]:""))},r.toCamelCase=function(t){return t[_r]()[Tn](/-(.)/g,function(t,e){return e.toUpperCase()})},r.normalizeCssArray=function(t){var e=t[Wn];return typeof t===yn?[t,t,t,t]:2===e?[t[0],t[1],t[0],t[1]]:3===e?[t[0],t[1],t[2],t[1]]:t},r[Ve]=function(t){return String(t)[Tn](/&/g," & amp;
                ")[Tn](/</g," & lt;
                ")[Tn](/>/g," & gt;
                ")[Tn](/" / g, "&quot;")[Tn](/'/g, "&#39;")
            };
            var a = ["a", "b", "c", "d", "e", "f", "g"],
            o = function(t, e) {
                return "{" + t + (null == e ? "": e) + "}"
            };
            r.formatTpl = function(t, i) {
                e[An](i) || (i = [i]);
                var n = i[Wn];
                if (!n) return "";
                for (var r = i[0].$vars || [], s = 0; s < r[Wn]; s++) {
                    var l = a[s];
                    t = t[Tn](o(l), o(l, 0))
                }
                for (var u = 0; n > u; u++) for (var c = 0; c < r[Wn]; c++) t = t[Tn](o(a[c], u), i[u][r[c]]);
                return t
            };
            var s = function(t) {
                return 10 > t ? "0" + t: t
            };
            return r.formatTime = function(t, e) { ("week" === t || "month" === t || "quarter" === t || "half-year" === t || "year" === t) && (t = "MM-dd\nyyyy");
                var n = i.parseDate(e),
                r = n.getFullYear(),
                a = n.getMonth() + 1,
                o = n.getDate(),
                l = n.getHours(),
                u = n.getMinutes(),
                c = n.getSeconds();
                return t = t[Tn]("MM", s(a))[_r]()[Tn]("yyyy", r)[Tn]("yy", r % 100)[Tn]("dd", s(o))[Tn]("d", o)[Tn]("hh", s(l))[Tn]("h", l)[Tn]("mm", s(u))[Tn]("m", u)[Tn]("ss", s(c))[Tn]("s", c)
            },
            r.capitalFirst = function(t) {
                return t ? t.charAt(0).toUpperCase() + t.substr(1) : t
            },
            r.truncateText = n.truncateText,
            r
        }),
        e("echarts/data/List", [Tr, "../model/Model", "./DataDiffer", Ar, "../util/model"],
        function(t) {
            function e(t) {
                return c[An](t) || (t = [t]),
                t
            }
            function i(t, e) {
                var i = t[de],
                n = new v(c.map(i, t.getDimensionInfo, t), t[fi]);
                p(n, t);
                for (var r = n._storage = {},
                a = t._storage,
                o = 0; o < i[Wn]; o++) {
                    var s = i[o],
                    l = a[s];
                    r[s] = c[gn](e, s) >= 0 ? new l.constructor(a[s][Wn]) : a[s]
                }
                return n
            }
            var n = Be,
            r = typeof window === Be ? global: window,
            a = typeof r.Float64Array === n ? Array: r.Float64Array,
            o = typeof r.Int32Array === n ? Array: r.Int32Array,
            s = {
                "float": a,
                "int": o,
                ordinal: Array,
                number: Array,
                time: Array
            },
            l = t("../model/Model"),
            u = t("./DataDiffer"),
            c = t(Ar),
            h = t("../util/model"),
            d = c[Yn],
            f = ["stackedOn", fe, "_nameList", "_idList", "_rawData"],
            p = function(t, e) {
                c.each(f[Ai](e.__wrappedMethods || []),
                function(i) {
                    e.hasOwnProperty(i) && (t[i] = e[i])
                }),
                t.__wrappedMethods = e.__wrappedMethods
            },
            v = function(t, e) {
                t = t || ["x", "y"];
                for (var i = {},
                n = [], r = 0; r < t[Wn]; r++) {
                    var a, o = {};
                    typeof t[r] === yr ? (a = t[r], o = {
                        name: a,
                        stackable: !1,
                        type: "number"
                    }) : (o = t[r], a = o.name, o.type = o.type || yn),
                    n.push(a),
                    i[a] = o
                }
                this[de] = n,
                this._dimensionInfos = i,
                this[fi] = e,
                this[Pn],
                this.indices = [],
                this._storage = {},
                this._nameList = [],
                this._idList = [],
                this._optionModels = [],
                this.stackedOn = null,
                this._visual = {},
                this._layout = {},
                this._itemVisuals = [],
                this._itemLayouts = [],
                this._graphicEls = [],
                this._rawData,
                this._extent
            },
            g = v[xr];
            g.type = "list",
            g[fe] = !0,
            g.getDimension = function(t) {
                return isNaN(t) || (t = this[de][t] || t),
                t
            },
            g.getDimensionInfo = function(t) {
                return c.clone(this._dimensionInfos[this.getDimension(t)])
            },
            g[Di] = function(t, e, i) {
                t = t || [],
                this._rawData = t;
                var n = this._storage = {},
                r = this.indices = [],
                a = this[de],
                o = t[Wn],
                l = this._dimensionInfos,
                u = [],
                c = {};
                e = e || [];
                for (var d = 0; d < a[Wn]; d++) {
                    var f = l[a[d]],
                    p = s[f.type];
                    n[a[d]] = new p(o)
                }
                var v = this;
                i || (v[fe] = !1),
                i = i ||
                function(t, e, i, n) {
                    var r = h.getDataItemValue(t);
                    return h.isDataItemOption(t) && (v[fe] = !0),
                    h.converDataValue(r instanceof Array ? r[n] : r, l[e])
                };
                for (var g = 0; g < t[Wn]; g++) {
                    for (var m = t[g], y = 0; y < a[Wn]; y++) {
                        var x = a[y],
                        _ = n[x];
                        _[g] = i(m, x, g, y)
                    }
                    r.push(g)
                }
                for (var d = 0; d < t[Wn]; d++) {
                    e[d] || t[d] && null != t[d].name && (e[d] = t[d].name);
                    var w = e[d] || "",
                    b = t[d] && t[d].id; ! b && w && (c[w] = c[w] || 0, b = w, c[w] > 0 && (b += "__ec__" + c[w]), c[w]++),
                    b && (u[d] = b)
                }
                this._nameList = e,
                this._idList = u
            },
            g.count = function() {
                return this.indices[Wn]
            },
            g.get = function(t, e, i) {
                var n = this._storage,
                r = this.indices[e];
                if (null == r) return 0 / 0;
                var a = n[t] && n[t][r];
                if (i) {
                    var o = this._dimensionInfos[t];
                    if (o && o.stackable) for (var s = this.stackedOn; s;) {
                        var l = s.get(t, e); (a >= 0 && l > 0 || 0 >= a && 0 > l) && (a += l),
                        s = s.stackedOn
                    }
                }
                return a
            },
            g.getValues = function(t, e, i) {
                var n = [];
                c[An](t) || (i = e, e = t, t = this[de]);
                for (var r = 0,
                a = t[Wn]; a > r; r++) n.push(this.get(t[r], e, i));
                return n
            },
            g.hasValue = function(t) {
                for (var e = this[de], i = this._dimensionInfos, n = 0, r = e[Wn]; r > n; n++) if (i[e[n]].type !== Pe && isNaN(this.get(e[n], t))) return ! 1;
                return ! 0
            },
            g[Fe] = function(t, e) {
                t = this.getDimension(t);
                var i = this._storage[t],
                n = this.getDimensionInfo(t);
                e = n && n.stackable && e;
                var r, a = (this._extent || (this._extent = {}))[t + !!e];
                if (a) return a;
                if (i) {
                    for (var o = 1 / 0,
                    s = -1 / 0,
                    l = 0,
                    u = this.count(); u > l; l++) r = this.get(t, l, e),
                    o > r && (o = r),
                    r > s && (s = r);
                    return this._extent[t + !!e] = [o, s]
                }
                return [1 / 0, -1 / 0]
            },
            g.getSum = function(t, e) {
                var i = this._storage[t],
                n = 0;
                if (i) for (var r = 0,
                a = this.count(); a > r; r++) {
                    var o = this.get(t, r, e);
                    isNaN(o) || (n += o)
                }
                return n
            },
            g[gn] = function(t, e) {
                var i = this._storage,
                n = i[t],
                r = this.indices;
                if (n) for (var a = 0,
                o = r[Wn]; o > a; a++) {
                    var s = r[a];
                    if (n[s] === e) return a
                }
                return - 1
            },
            g[Ae] = function(t) {
                for (var e = this.indices,
                i = this._nameList,
                n = 0,
                r = e[Wn]; r > n; n++) {
                    var a = e[n];
                    if (i[a] === t) return n
                }
                return - 1
            },
            g.indexOfRawIndex = function(t) {
                for (var e = this.indices,
                i = 0,
                n = e[Wn] - 1; n >= i;) {
                    var r = (i + n) / 2 | 0;
                    if (e[r] < t) i = r + 1;
                    else {
                        if (! (e[r] > t)) return r;
                        n = r - 1
                    }
                }
                return - 1
            },
            g.indexOfNearest = function(t, e, i, n) {
                var r = this._storage,
                a = r[t];
                null == n && (n = 1 / 0);
                var o = -1;
                if (a) for (var s = Number.MAX_VALUE,
                l = 0,
                u = this.count(); u > l; l++) {
                    var c = e - this.get(t, l, i),
                    h = Math.abs(c);
                    n >= c && (s > h || h === s && c > 0) && (s = h, o = l)
                }
                return o
            },
            g[je] = function(t) {
                var e = this.indices[t];
                return null == e ? -1 : e
            },
            g.getRawDataItem = function(t) {
                return this._rawData[this[je](t)]
            },
            g[Ci] = function(t) {
                return this._nameList[this.indices[t]] || ""
            },
            g.getId = function(t) {
                return this._idList[this.indices[t]] || this[je](t) + ""
            },
            g.each = function(t, i, n, r) {
                typeof t === Sn && (r = n, n = i, i = t, t = []),
                t = c.map(e(t), this.getDimension, this);
                var a = [],
                o = t[Wn],
                s = this.indices;
                r = r || this;
                for (var l = 0; l < s[Wn]; l++) switch (o) {
                case 0:
                    i.call(r, l);
                    break;
                case 1:
                    i.call(r, this.get(t[0], l, n), l);
                    break;
                case 2:
                    i.call(r, this.get(t[0], l, n), this.get(t[1], l, n), l);
                    break;
                default:
                    for (var u = 0; o > u; u++) a[u] = this.get(t[u], l, n);
                    a[u] = l,
                    i.apply(r, a)
                }
            },
            g.filterSelf = function(t, i, n, r) {
                typeof t === Sn && (r = n, n = i, i = t, t = []),
                t = c.map(e(t), this.getDimension, this);
                var a = [],
                o = [],
                s = t[Wn],
                l = this.indices;
                r = r || this;
                for (var u = 0; u < l[Wn]; u++) {
                    var h;
                    if (1 === s) h = i.call(r, this.get(t[0], u, n), u);
                    else {
                        for (var d = 0; s > d; d++) o[d] = this.get(t[d], u, n);
                        o[d] = u,
                        h = i.apply(r, o)
                    }
                    h && a.push(l[u])
                }
                return this.indices = a,
                this._extent = {},
                this
            },
            g[he] = function(t, e, i, n) {
                typeof t === Sn && (n = i, i = e, e = t, t = []);
                var r = [];
                return this.each(t,
                function() {
                    r.push(e && e.apply(this, arguments))
                },
                i, n),
                r
            },
            g.map = function(t, n, r, a) {
                t = c.map(e(t), this.getDimension, this);
                var o = i(this, t),
                s = o.indices = this.indices,
                l = o._storage,
                u = [];
                return this.each(t,
                function() {
                    var e = arguments[arguments[Wn] - 1],
                    i = n && n.apply(this, arguments);
                    if (null != i) {
                        typeof i === yn && (u[0] = i, i = u);
                        for (var r = 0; r < i[Wn]; r++) {
                            var a = t[r],
                            o = l[a],
                            c = s[e];
                            o && (o[c] = i[r])
                        }
                    }
                },
                r, a),
                o
            },
            g.downSample = function(t, e, n, r) {
                for (var a = i(this, [t]), o = this._storage, s = a._storage, l = this.indices, u = a.indices = [], c = [], h = [], d = Math.floor(1 / e), f = s[t], p = this.count(), v = 0; v < o[t][Wn]; v++) s[t][v] = o[t][v];
                for (var v = 0; p > v; v += d) {
                    d > p - v && (d = p - v, c[Wn] = d);
                    for (var g = 0; d > g; g++) {
                        var m = l[v + g];
                        c[g] = f[m],
                        h[g] = m
                    }
                    var y = n(c),
                    m = h[r(c, y) || 0];
                    f[m] = y,
                    u.push(m)
                }
                return a
            },
            g[hi] = function(t) {
                var e = this[fi];
                return t = this.indices[t],
                new l(this._rawData[t], e, e && e[Te])
            },
            g.diff = function(t) {
                var e = this._idList,
                i = t && t._idList;
                return new u(t ? t.indices: [], this.indices,
                function(t) {
                    return i[t] || t + ""
                },
                function(t) {
                    return e[t] || t + ""
                })
            },
            g[ce] = function(t) {
                var e = this._visual;
                return e && e[t]
            },
            g[hn] = function(t, e) {
                if (d(t)) for (var i in t) t.hasOwnProperty(i) && this[hn](i, t[i]);
                else this._visual = this._visual || {},
                this._visual[t] = e
            },
            g[ue] = function(t, e) {
                if (d(t)) for (var i in t) t.hasOwnProperty(i) && this[ue](i, t[i]);
                else this._layout[t] = e
            },
            g.getLayout = function(t) {
                return this._layout[t]
            },
            g[bi] = function(t) {
                return this._itemLayouts[t]
            },
            g[He] = function(t, e, i) {
                this._itemLayouts[t] = i ? c[jn](this._itemLayouts[t] || {},
                e) : e
            },
            g.clearItemLayouts = function() {
                this._itemLayouts[Wn] = 0
            },
            g[gi] = function(t, e, i) {
                var n = this._itemVisuals[t],
                r = n && n[e];
                return null != r || i ? r: this[ce](e)
            },
            g[Ue] = function(t, e, i) {
                var n = this._itemVisuals[t] || {};
                if (this._itemVisuals[t] = n, d(e)) for (var r in e) e.hasOwnProperty(r) && (n[r] = e[r]);
                else n[e] = i
            },
            g.clearAllVisual = function() {
                this._visual = {},
                this._itemVisuals = []
            };
            var m = function(t) {
                t[Dn] = this[Dn],
                t[zn] = this[zn],
                t[Pn] = this[Pn]
            };
            return g[$e] = function(t, e) {
                var i = this[fi];
                e && (e[zn] = t, e[Pn] = this[Pn], e[Dn] = i && i[Dn], "group" === e.type && e[kn](m, e)),
                this._graphicEls[t] = e
            },
            g[Mi] = function(t) {
                return this._graphicEls[t]
            },
            g[Se] = function(t, e) {
                c.each(this._graphicEls,
                function(i, n) {
                    i && t && t.call(e, i, n)
                })
            },
            g.cloneShallow = function() {
                var t = c.map(this[de], this.getDimensionInfo, this),
                e = new v(t, this[fi]);
                return e._storage = this._storage,
                p(e, this),
                e.indices = this.indices.slice(),
                this._extent && (e._extent = c[jn]({},
                this._extent)),
                e
            },
            g.wrapMethod = function(t, e) {
                var i = this[t];
                typeof i === Sn && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
                    var t = i.apply(this, arguments);
                    return e.apply(this, [t][Ai](c.slice(arguments)))
                })
            },
            g.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"],
            g.CHANGABLE_METHODS = ["filterSelf"],
            v
        }),
        e(br, [],
        function() {
            var t = typeof Float32Array === Be ? Array: Float32Array,
            e = {
                create: function() {
                    var i = new t(6);
                    return e.identity(i),
                    i
                },
                identity: function(t) {
                    return t[0] = 1,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 1,
                    t[4] = 0,
                    t[5] = 0,
                    t
                },
                copy: function(t, e) {
                    return t[0] = e[0],
                    t[1] = e[1],
                    t[2] = e[2],
                    t[3] = e[3],
                    t[4] = e[4],
                    t[5] = e[5],
                    t
                },
                mul: function(t, e, i) {
                    var n = e[0] * i[0] + e[2] * i[1],
                    r = e[1] * i[0] + e[3] * i[1],
                    a = e[0] * i[2] + e[2] * i[3],
                    o = e[1] * i[2] + e[3] * i[3],
                    s = e[0] * i[4] + e[2] * i[5] + e[4],
                    l = e[1] * i[4] + e[3] * i[5] + e[5];
                    return t[0] = n,
                    t[1] = r,
                    t[2] = a,
                    t[3] = o,
                    t[4] = s,
                    t[5] = l,
                    t
                },
                translate: function(t, e, i) {
                    return t[0] = e[0],
                    t[1] = e[1],
                    t[2] = e[2],
                    t[3] = e[3],
                    t[4] = e[4] + i[0],
                    t[5] = e[5] + i[1],
                    t
                },
                rotate: function(t, e, i) {
                    var n = e[0],
                    r = e[2],
                    a = e[4],
                    o = e[1],
                    s = e[3],
                    l = e[5],
                    u = Math.sin(i),
                    c = Math.cos(i);
                    return t[0] = n * c + o * u,
                    t[1] = -n * u + o * c,
                    t[2] = r * c + s * u,
                    t[3] = -r * u + c * s,
                    t[4] = c * a + u * l,
                    t[5] = c * l - u * a,
                    t
                },
                scale: function(t, e, i) {
                    var n = i[0],
                    r = i[1];
                    return t[0] = e[0] * n,
                    t[1] = e[1] * r,
                    t[2] = e[2] * n,
                    t[3] = e[3] * r,
                    t[4] = e[4] * n,
                    t[5] = e[5] * r,
                    t
                },
                invert: function(t, e) {
                    var i = e[0],
                    n = e[2],
                    r = e[4],
                    a = e[1],
                    o = e[3],
                    s = e[5],
                    l = i * o - a * n;
                    return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - o * r) * l, t[5] = (a * r - i * s) * l, t) : null
                }
            };
            return e
        }),
        e(wr, [],
        function() {
            var t = typeof Float32Array === Be ? Array: Float32Array,
            e = {
                create: function(e, i) {
                    var n = new t(2);
                    return null == e && (e = 0),
                    null == i && (i = 0),
                    n[0] = e,
                    n[1] = i,
                    n
                },
                copy: function(t, e) {
                    return t[0] = e[0],
                    t[1] = e[1],
                    t
                },
                clone: function(e) {
                    var i = new t(2);
                    return i[0] = e[0],
                    i[1] = e[1],
                    i
                },
                set: function(t, e, i) {
                    return t[0] = e,
                    t[1] = i,
                    t
                },
                add: function(t, e, i) {
                    return t[0] = e[0] + i[0],
                    t[1] = e[1] + i[1],
                    t
                },
                scaleAndAdd: function(t, e, i, n) {
                    return t[0] = e[0] + i[0] * n,
                    t[1] = e[1] + i[1] * n,
                    t
                },
                sub: function(t, e, i) {
                    return t[0] = e[0] - i[0],
                    t[1] = e[1] - i[1],
                    t
                },
                len: function(t) {
                    return Math.sqrt(this.lenSquare(t))
                },
                lenSquare: function(t) {
                    return t[0] * t[0] + t[1] * t[1]
                },
                mul: function(t, e, i) {
                    return t[0] = e[0] * i[0],
                    t[1] = e[1] * i[1],
                    t
                },
                div: function(t, e, i) {
                    return t[0] = e[0] / i[0],
                    t[1] = e[1] / i[1],
                    t
                },
                dot: function(t, e) {
                    return t[0] * e[0] + t[1] * e[1]
                },
                scale: function(t, e, i) {
                    return t[0] = e[0] * i,
                    t[1] = e[1] * i,
                    t
                },
                normalize: function(t, i) {
                    var n = e.len(i);
                    return 0 === n ? (t[0] = 0, t[1] = 0) : (t[0] = i[0] / n, t[1] = i[1] / n),
                    t
                },
                distance: function(t, e) {
                    return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
                },
                distanceSquare: function(t, e) {
                    return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
                },
                negate: function(t, e) {
                    return t[0] = -e[0],
                    t[1] = -e[1],
                    t
                },
                lerp: function(t, e, i, n) {
                    return t[0] = e[0] + n * (i[0] - e[0]),
                    t[1] = e[1] + n * (i[1] - e[1]),
                    t
                },
                applyTransform: function(t, e, i) {
                    var n = e[0],
                    r = e[1];
                    return t[0] = i[0] * n + i[2] * r + i[4],
                    t[1] = i[1] * n + i[3] * r + i[5],
                    t
                },
                min: function(t, e, i) {
                    return t[0] = Math.min(e[0], i[0]),
                    t[1] = Math.min(e[1], i[1]),
                    t
                },
                max: function(t, e, i) {
                    return t[0] = Math.max(e[0], i[0]),
                    t[1] = Math.max(e[1], i[1]),
                    t
                }
            };
            return e[Wn] = e.len,
            e.lengthSquare = e.lenSquare,
            e.dist = e[ge],
            e.distSquare = e.distanceSquare,
            e
        }),
        e("echarts/chart/scatter/ScatterView", [Tr, "../helper/SymbolDraw", "../helper/LargeSymbolDraw", Ei],
        function(t) {
            var e = t("../helper/SymbolDraw"),
            i = t("../helper/LargeSymbolDraw");
            t(Ei)[xn]({
                type: "scatter",
                init: function() {
                    this._normalSymbolDraw = new e,
                    this._largeSymbolDraw = new i
                },
                render: function(t) {
                    var e = t[Kn](),
                    i = this._largeSymbolDraw,
                    n = this._normalSymbolDraw,
                    r = this.group,
                    a = t.get("large") && e.count() > t.get("largeThreshold") ? i: n;
                    this._symbolDraw = a,
                    a[yi](e),
                    r.add(a.group),
                    r[Xn](a === i ? n.group: i.group)
                },
                updateLayout: function(t) {
                    this._symbolDraw[Qn](t)
                },
                remove: function(t, e) {
                    this._symbolDraw && this._symbolDraw[Xn](e, !0)
                }
            })
        }),
        e("echarts/chart/scatter/ScatterSeries", [Tr, "../helper/createListFromArray", le],
        function(t) {
            var e = t("../helper/createListFromArray"),
            i = t(le);
            return i[jn]({
                type: "series.scatter",
                dependencies: ["grid", "polar"],
                getInitialData: function(t, i) {
                    var n = e(t.data, this, i);
                    return n
                },
                brushSelector: "point",
                defaultOption: {
                    coordinateSystem: "cartesian2d",
                    zlevel: 0,
                    z: 2,
                    legendHoverLink: !0,
                    hoverAnimation: !0,
                    symbolSize: 10,
                    large: !1,
                    largeThreshold: 2e3,
                    itemStyle: {
                        normal: {
                            opacity: .8
                        }
                    }
                }
            })
        }),
        e("echarts/visual/symbol", [Tr],
        function() {
            return function(t, e, i, n) {
                n.eachRawSeriesByType(t,
                function(t) {
                    var r = t[Kn](),
                    a = t.get(se) || e,
                    o = t.get(oe);
                    r[hn]({
                        legendSymbol: i || a,
                        symbol: a,
                        symbolSize: o
                    }),
                    n.isSeriesFiltered(t) || (typeof o === Sn && r.each(function(e) {
                        var i = t[ke](e),
                        n = t[In](e);
                        r[Ue](e, oe, o(i, n))
                    }), r.each(function(t) {
                        var e = r[hi](t),
                        i = e[Ce](se, !0),
                        n = e[Ce](oe, !0);
                        null != i && r[Ue](t, se, i),
                        null != n && r[Ue](t, oe, n)
                    }))
                })
            }
        }),
        e("echarts/layout/points", [Tr],
        function() {
            return function(t, e) {
                e[dn](t,
                function(t) {
                    var e = t[Kn](),
                    i = t[ln];
                    if (i) {
                        var n = i[de];
                        "singleAxis" === i.type ? e.each(n[0],
                        function(t, n) {
                            e[He](n, isNaN(t) ? [0 / 0, 0 / 0] : i[ae](t))
                        }) : e.each(n,
                        function(t, n, r) {
                            e[He](r, isNaN(t) || isNaN(n) ? [0 / 0, 0 / 0] : i[ae]([t, n]))
                        },
                        !0)
                    }
                })
            }
        }),
        e("echarts/coord/cartesian/Grid", [Tr, "exports", re, "../../coord/axisHelper", Ar, "./Cartesian2D", "./Axis2D", "./GridModel", ne],
        function(t) {
            function e(t, e) {
                return t.findGridModel() === e
            }
            function i(t) {
                var e, i = t.model,
                n = i[ee](),
                r = 1,
                a = n[Wn];
                a > 40 && (r = Math.ceil(a / 40));
                for (var o = 0; a > o; o += r) if (!t.isLabelIgnored(o)) {
                    var s = i.getTextRect(n[o]);
                    e ? e.union(s) : e = s
                }
                return e
            }
            function n(t, e, i) {
                this._coordsMap = {},
                this._coordsList = [],
                this._axesMap = {},
                this._axesList = [],
                this._initCartesian(t, e, i),
                this[pr] = t
            }
            function r(t, e) {
                var i = t[Fi](),
                n = i[0] + i[1];
                t[U] = "x" === t.dim ?
                function(t) {
                    return t + e
                }: function(t) {
                    return n - t + e
                },
                t.toLocalCoord = "x" === t.dim ?
                function(t) {
                    return t - e
                }: function(t) {
                    return n - t + e
                }
            }
            function a(t, e) {
                return u.map(g,
                function(i) {
                    var n = e[Ee]({
                        mainType: i,
                        index: t.get(i + "Index"),
                        id: t.get(i + "Id")
                    })[0];
                    return n
                })
            }
            function o(t) {
                return t.get(ln) === q
            }
            var s = t(re),
            l = t("../../coord/axisHelper"),
            u = t(Ar),
            c = t("./Cartesian2D"),
            h = t("./Axis2D"),
            d = u.each,
            f = l.ifAxisCrossZero,
            p = l[ie];
            t("./GridModel");
            var v = n[xr];
            v.type = "grid",
            v[un] = function() {
                return this._rect
            },
            v[er] = function(t, e) {
                function i(t) {
                    var e = n[t];
                    for (var i in e) {
                        var r = e[i];
                        if (r && (r.type === te || !f(r))) return ! 0
                    }
                    return ! 1
                }
                var n = this._axesMap;
                this._updateScale(t, this[pr]),
                d(n.x,
                function(t) {
                    p(t, t.model)
                }),
                d(n.y,
                function(t) {
                    p(t, t.model)
                }),
                d(n.x,
                function(t) {
                    i("y") && (t.onZero = !1)
                }),
                d(n.y,
                function(t) {
                    i("x") && (t.onZero = !1)
                }),
                this[gr](this[pr], e)
            },
            v[gr] = function(t, e) {
                function n() {
                    d(o,
                    function(t) {
                        var e = t[K](),
                        i = e ? [0, a.width] : [0, a[nr]],
                        n = t[Q] ? 1 : 0;
                        t[Zi](i[n], i[1 - n]),
                        r(t, e ? a.x: a.y)
                    })
                }
                var a = s[Ki](t[tn](), {
                    width: e[dr](),
                    height: e[hr]()
                });
                this._rect = a;
                var o = this._axesList;
                n(),
                t.get("containLabel") && (d(o,
                function(t) {
                    if (!t.model.get("axisLabel.inside")) {
                        var e = i(t);
                        if (e) {
                            var n = t[K]() ? nr: "width",
                            r = t.model.get("axisLabel.margin");
                            a[n] -= e[n] + r,
                            "top" === t[$i] ? a.y += e[nr] + r: "left" === t[$i] && (a.x += e.width + r)
                        }
                    }
                }), n())
            },
            v[J] = function(t, e) {
                var i = this._axesMap[t];
                if (null != i) {
                    if (null == e) for (var n in i) return i[n];
                    return i[e]
                }
            },
            v.getCartesian = function(t, e) {
                if (null != t && null != e) {
                    var i = "x" + t + "y" + e;
                    return this._coordsMap[i]
                }
                for (var n = 0,
                r = this._coordsList; n < r[Wn]; n++) if (r[n][J]("x").index === t || r[n][J]("y").index === e) return r[n]
            },
            v._initCartesian = function(t, i) {
                function n(n) {
                    return function(s, u) {
                        if (e(s, t, i)) {
                            var c = s.get($i);
                            "x" === n ? "top" !== c && c !== rr && (c = rr, r[c] && (c = "top" === c ? rr: "top")) : "left" !== c && "right" !== c && (c = "left", r[c] && (c = "left" === c ? "right": "left")),
                            r[c] = !0;
                            var d = new h(n, l[$](s), [0, 0], s.get("type"), c),
                            f = d.type === te;
                            d[Y] = f && s.get(X),
                            d[Q] = s.get(Q),
                            d.onZero = s.get("axisLine.onZero"),
                            s.axis = d,
                            d.model = s,
                            d.grid = this,
                            d.index = u,
                            this._axesList.push(d),
                            a[n][u] = d,
                            o[n]++
                        }
                    }
                }
                var r = {
                    left: !1,
                    right: !1,
                    top: !1,
                    bottom: !1
                },
                a = {
                    x: {},
                    y: {}
                },
                o = {
                    x: 0,
                    y: 0
                };
                return i[or]("xAxis", n("x"), this),
                i[or]("yAxis", n("y"), this),
                o.x && o.y ? (this._axesMap = a, void d(a.x,
                function(t, e) {
                    d(a.y,
                    function(i, n) {
                        var r = "x" + e + "y" + n,
                        a = new c(r);
                        a.grid = this,
                        this._coordsMap[r] = a,
                        this._coordsList.push(a),
                        a.addAxis(t),
                        a.addAxis(i)
                    },
                    this)
                },
                this)) : (this._axesMap = {},
                void(this._axesList = []))
            },
            v._updateScale = function(t, i) {
                function n(t, e, i) {
                    d(i[j](e.dim),
                    function(i) {
                        e.scale[Hi](t[Fe](i, e.scale.type !== Pe))
                    })
                }
                u.each(this._axesList,
                function(t) {
                    t.scale[Zi](1 / 0, -1 / 0)
                }),
                t[tr](function(r) {
                    if (o(r)) {
                        var s = a(r, t),
                        l = s[0],
                        u = s[1];
                        if (!e(l, i, t) || !e(u, i, t)) return;
                        var c = this.getCartesian(l[Oe], u[Oe]),
                        h = r[Kn](),
                        d = c[J]("x"),
                        f = c[J]("y");
                        "list" === h.type && (n(h, d, r), n(h, f, r))
                    }
                },
                this)
            };
            var g = ["xAxis", "yAxis"];
            return n[ir] = function(t, e) {
                var i = [];
                return t[or]("grid",
                function(r, a) {
                    var o = new n(r, t, e);
                    o.name = "grid_" + a,
                    o[gr](r, e),
                    r[ln] = o,
                    i.push(o)
                }),
                t[tr](function(e) {
                    if (o(e)) {
                        var i = a(e, t),
                        n = i[0],
                        r = i[1],
                        s = n.findGridModel(),
                        l = s[ln];
                        e[ln] = l.getCartesian(n[Oe], r[Oe])
                    }
                }),
                i
            },
            n[de] = c[xr][de],
            t(ne)[bn](q, n),
            n
        }),
        e("echarts/chart/bar/BarSeries", [Tr, le, "../helper/createListFromArray"],
        function(t) {
            var e = t(le),
            i = t("../helper/createListFromArray");
            return e[jn]({
                type: "series.bar",
                dependencies: ["grid", "polar"],
                getInitialData: function(t, e) {
                    return i(t.data, this, e)
                },
                getMarkerPosition: function(t) {
                    var e = this[ln];
                    if (e) {
                        var i = e[ae](t, !0),
                        n = this[Kn](),
                        r = n.getLayout("offset"),
                        a = n.getLayout("size"),
                        o = e[Ie]()[K]() ? 0 : 1;
                        return i[o] += r + a / 2,
                        i
                    }
                    return [0 / 0, 0 / 0]
                },
                brushSelector: "rect",
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: "cartesian2d",
                    legendHoverLink: !0,
                    barMinHeight: 0,
                    itemStyle: {
                        normal: {},
                        emphasis: {}
                    }
                }
            })
        }),
        e("echarts/chart/bar/BarView", [Tr, Ar, Si, W, "./barItemStyle", Ei],
        function(t) {
            function e(t, e) {
                var i = t.width > 0 ? 1 : -1,
                n = t[nr] > 0 ? 1 : -1;
                e = Math.min(e, Math.abs(t.width), Math.abs(t[nr])),
                t.x += i * e / 2,
                t.y += n * e / 2,
                t.width -= i * e,
                t[nr] -= n * e
            }
            var i = t(Ar),
            n = t(Si);
            return i[jn](t(W)[xr], t("./barItemStyle")),
            t(Ei)[xn]({
                type: "bar",
                render: function(t, e, i) {
                    var n = t.get(ln);
                    return n === q && this._renderOnCartesian(t, e, i),
                    this.group
                },
                _renderOnCartesian: function(t) {
                    function r(r, a) {
                        var s = o[bi](r),
                        l = o[hi](r).get(d) || 0;
                        e(s, l);
                        var u = new n.Rect({
                            shape: i[jn]({},
                            s)
                        });
                        if (h) {
                            var f = u.shape,
                            p = c ? nr: "width",
                            v = {};
                            f[p] = 0,
                            v[p] = s[p],
                            n[a ? ui: Xe](u, {
                                shape: v
                            },
                            t, r)
                        }
                        return u
                    }
                    var a = this.group,
                    o = t[Kn](),
                    s = this._data,
                    l = t[ln],
                    u = l[Ie](),
                    c = u[K](),
                    h = t.get(vr),
                    d = [li, ki, "barBorderWidth"];
                    o.diff(s).add(function(t) {
                        if (o.hasValue(t)) {
                            var e = r(t);
                            o[$e](t, e),
                            a.add(e)
                        }
                    })[er](function(i, l) {
                        var u = s[Mi](l);
                        if (!o.hasValue(i)) return void a[Xn](u);
                        u || (u = r(i, !0));
                        var c = o[bi](i),
                        h = o[hi](i).get(d) || 0;
                        e(c, h),
                        n[ui](u, {
                            shape: c
                        },
                        t, i),
                        o[$e](i, u),
                        a.add(u)
                    })[Xn](function(e) {
                        var i = s[Mi](e);
                        i && (i.style.text = "", n[ui](i, {
                            shape: {
                                width: 0
                            }
                        },
                        t, e,
                        function() {
                            a[Xn](i)
                        }))
                    })[Qe](),
                    this._updateStyle(t, o, c),
                    this._data = o
                },
                _updateStyle: function(t, e, r) {
                    function a(t, e, i, r, a) {
                        n[me](t, e, i),
                        t.text = r,
                        "outside" === t[Z] && (t[Z] = a)
                    }
                    e[Se](function(o, s) {
                        var l = e[hi](s),
                        u = e[gi](s, "color"),
                        c = e[gi](s, Yi),
                        h = e[bi](s),
                        d = l[fr](F),
                        f = l[fr](H).getBarItemStyle();
                        o[ci]("r", d.get("barBorderRadius") || 0),
                        o[si](i[qn]({
                            fill: u,
                            opacity: c
                        },
                        d.getBarItemStyle()));
                        var p = r ? h[nr] > 0 ? rr: "top": h.width > 0 ? "left": "right",
                        v = l[fr](ii),
                        g = l[fr](ei),
                        m = o.style;
                        v.get("show") ? a(m, v, u, i[vi](t[pi](s, ki), t[ke](s)), p) : m.text = "",
                        g.get("show") ? a(f, g, u, i[vi](t[pi](s, Li), t[ke](s)), p) : f.text = "",
                        n[ri](o, f)
                    })
                },
                remove: function(t) {
                    var e = this.group;
                    t.get(vr) ? this._data && this._data[Se](function(i) {
                        i.style.text = "",
                        n[ui](i, {
                            shape: {
                                width: 0
                            }
                        },
                        t, i[zn],
                        function() {
                            e[Xn](i)
                        })
                    }) : e[cn]()
                }
            })
        }),
        e("echarts/chart/candlestick/CandlestickSeries", [Tr, Ar, le, "../helper/whiskerBoxCommon", G],
        function(t) {
            var e = t(Ar),
            i = t(le),
            n = t("../helper/whiskerBoxCommon"),
            r = t(G),
            a = r[Ve],
            o = r[ze],
            s = i[jn]({
                type: "series.candlestick",
                dependencies: ["xAxis", "yAxis", "grid"],
                valueDimensions: ["open", "close", "lowest", "highest"],
                dimensions: null,
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: "cartesian2d",
                    legendHoverLink: !0,
                    hoverAnimation: !0,
                    layout: null,
                    itemStyle: {
                        normal: {
                            color: "#c23531",
                            color0: "#314656",
                            borderWidth: 1,
                            borderColor: "#c23531",
                            borderColor0: "#314656"
                        },
                        emphasis: {
                            borderWidth: 2
                        }
                    },
                    animationUpdate: !1,
                    animationEasing: "linear",
                    animationDuration: 300
                },
                getShadowDim: function() {
                    return "open"
                },
                formatTooltip: function(t) {
                    var i = e.map(this.valueDimensions,
                    function(e) {
                        return e + ": " + o(this._data.get(e, t))
                    },
                    this);
                    return a(this.name) + Le + i.join(Le)
                },
                brushSelector: function(t, e) {
                    return e.rect(t.brushRect)
                }
            });
            return e.mixin(s, n.seriesModelMixin, !0),
            s
        }),
        e("echarts/layout/barGrid", [Tr, Ar, Xi],
        function(t) {
            function e(t) {
                return t.get("stack") || "__ec_stack_" + t[Dn]
            }
            function i(t) {
                return t.dim + t.index
            }
            function n(t) {
                var n = {};
                a.each(t,
                function(t) {
                    var r = t[Kn](),
                    a = t[ln],
                    o = a[Ie](),
                    l = o[Fi](),
                    u = o.type === te ? o.getBandWidth() : Math.abs(l[1] - l[0]) / r.count(),
                    c = n[i(o)] || {
                        bandWidth: u,
                        remainedWidth: u,
                        autoWidthCount: 0,
                        categoryGap: "20%",
                        gap: "30%",
                        stacks: {}
                    },
                    h = c.stacks;
                    n[i(o)] = c;
                    var d = e(t);
                    h[d] || c.autoWidthCount++,
                    h[d] = h[d] || {
                        width: 0,
                        maxWidth: 0
                    };
                    var f = s(t.get("barWidth"), u),
                    p = s(t.get("barMaxWidth"), u),
                    v = t.get("barGap"),
                    g = t.get("barCategoryGap");
                    f && !h[d].width && (f = Math.min(c.remainedWidth, f), h[d].width = f, c.remainedWidth -= f),
                    p && (h[d].maxWidth = p),
                    null != v && (c.gap = v),
                    null != g && (c.categoryGap = g)
                });
                var r = {};
                return a.each(n,
                function(t, e) {
                    r[e] = {};
                    var i = t.stacks,
                    n = t.bandWidth,
                    o = s(t.categoryGap, n),
                    l = s(t.gap, 1),
                    u = t.remainedWidth,
                    c = t.autoWidthCount,
                    h = (u - o) / (c + (c - 1) * l);
                    h = Math.max(h, 0),
                    a.each(i,
                    function(t) {
                        var e = t.maxWidth; ! t.width && e && h > e && (e = Math.min(e, u), u -= e, t.width = e, c--)
                    }),
                    h = (u - o) / (c + (c - 1) * l),
                    h = Math.max(h, 0);
                    var d, f = 0;
                    a.each(i,
                    function(t) {
                        t.width || (t.width = h),
                        d = t,
                        f += t.width * (1 + l)
                    }),
                    d && (f -= d.width * l);
                    var p = -f / 2;
                    a.each(i,
                    function(t, i) {
                        r[e][i] = r[e][i] || {
                            offset: p,
                            width: t.width
                        },
                        p += t.width * (1 + l)
                    })
                }),
                r
            }
            function r(t, r) {
                var o = n(a[mn](r.getSeriesByType(t),
                function(t) {
                    return ! r.isSeriesFiltered(t) && t[ln] && t[ln].type === q
                })),
                s = {};
                r[dn](t,
                function(t) {
                    var n = t[Kn](),
                    r = t[ln],
                    a = r[Ie](),
                    l = e(t),
                    u = o[i(a)][l],
                    c = u.offset,
                    h = u.width,
                    d = r.getOtherAxis(a),
                    f = t.get("barMinHeight") || 0,
                    p = a.onZero ? d[U](d[B](0)) : d.getGlobalExtent()[0],
                    v = r.dataToPoints(n, !0);
                    s[l] = s[l] || [],
                    n[ue]({
                        offset: c,
                        size: h
                    }),
                    n.each(d.dim,
                    function(t, e) {
                        if (!isNaN(t)) {
                            s[l][e] || (s[l][e] = {
                                p: p,
                                n: p
                            });
                            var i, r, a, o, u = t >= 0 ? "p": "n",
                            g = v[e],
                            m = s[l][e][u];
                            d[K]() ? (i = m, r = g[1] + c, a = g[0] - m, o = h, Math.abs(a) < f && (a = (0 > a ? -1 : 1) * f), s[l][e][u] += a) : (i = g[0] + c, r = m, a = h, o = g[1] - m, Math.abs(o) < f && (o = (0 >= o ? -1 : 1) * f), s[l][e][u] += o),
                            n[He](e, {
                                x: i,
                                y: r,
                                width: a,
                                height: o
                            })
                        }
                    },
                    !0)
                },
                this)
            }
            var a = t(Ar),
            o = t(Xi),
            s = o[We];
            return r
        }),
        e("echarts/chart/candlestick/CandlestickView", [Tr, Ar, "../../view/Chart", Si, "../helper/whiskerBoxCommon"],
        function(t) {
            function e(t, e, i) {
                var n = e[hi](i),
                a = n[fr](s),
                o = e[gi](i, "color"),
                u = e[gi](i, N) || o,
                c = a[sn](["color", "color0", N, "borderColor0"]),
                h = t[di](t.whiskerIndex);
                h[si](c),
                h.style[ye] = u;
                var d = t[di](t.bodyIndex);
                d[si](c),
                d.style.fill = o,
                d.style[ye] = u;
                var f = n[fr](l)[sn]();
                r[ri](t, f)
            }
            var i = t(Ar),
            n = t("../../view/Chart"),
            r = t(Si),
            a = t("../helper/whiskerBoxCommon"),
            o = n[jn]({
                type: "candlestick",
                getStyleUpdater: function() {
                    return e
                }
            });
            i.mixin(o, a.viewMixin, !0);
            var s = [li, ki],
            l = [li, Li];
            return o
        }),
        e("echarts/chart/candlestick/preprocessor", [Tr, Ar],
        function(t) {
            var e = t(Ar);
            return function(t) {
                t && e[An](t[Fn]) && e.each(t[Fn],
                function(t) {
                    e[Yn](t) && "k" === t.type && (t.type = "candlestick")
                })
            }
        }),
        e("echarts/chart/line/LineSeries", [Tr, "../helper/createListFromArray", le],
        function(t) {
            var e = t("../helper/createListFromArray"),
            i = t(le);
            return i[jn]({
                type: "series.line",
                dependencies: ["grid", "polar"],
                getInitialData: function(t, i) {
                    return e(t.data, this, i)
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: "cartesian2d",
                    legendHoverLink: !0,
                    hoverAnimation: !0,
                    clipOverflow: !0,
                    label: {
                        normal: {
                            position: "top"
                        }
                    },
                    lineStyle: {
                        normal: {
                            width: 2,
                            type: "solid"
                        }
                    },
                    step: !1,
                    smooth: !1,
                    smoothMonotone: null,
                    symbol: "emptyCircle",
                    symbolSize: 4,
                    symbolRotate: null,
                    showSymbol: !0,
                    showAllSymbol: !1,
                    connectNulls: !1,
                    sampling: "none",
                    animationEasing: "linear",
                    progressive: 0,
                    hoverLayerThreshold: 1 / 0
                }
            })
        }),
        e("echarts/chart/candlestick/candlestickLayout", [Tr],
        function() {
            function t(t, r) {
                var a, o = t[Ie](),
                s = o.type === te ? o.getBandWidth() : (a = o[Fi](), Math.abs(a[1] - a[0]) / r.count());
                return s / 2 - 2 > i ? s / 2 - 2 : s - i > n ? i: Math.max(s - n, e)
            }
            var e = 2,
            i = 5,
            n = 4;
            return function(e) {
                e[dn]("candlestick",
                function(e) {
                    var i = e[ln],
                    n = e[Kn](),
                    r = e[de],
                    a = e.get(E),
                    o = t(e, n);
                    n.each(r,
                    function() {
                        function t(t) {
                            var e = [];
                            return e[d] = c,
                            e[f] = t,
                            isNaN(c) || isNaN(t) ? [0 / 0, 0 / 0] : i[ae](e)
                        }
                        function e(t, e) {
                            var i = t.slice(),
                            n = t.slice();
                            i[d] += o / 2,
                            n[d] -= o / 2,
                            e ? A.push(i, n) : A.push(n, i)
                        }
                        function s() {
                            var e = t(Math.min(p, v, g, m)),
                            i = t(Math.max(p, v, g, m));
                            return e[d] -= o / 2,
                            i[d] -= o / 2,
                            {
                                x: e[0],
                                y: e[1],
                                width: f ? o: i[0] - e[0],
                                height: f ? i[1] - e[1] : o
                            }
                        }
                        var l = arguments,
                        u = r[Wn],
                        c = l[0],
                        h = l[u],
                        d = a === O ? 0 : 1,
                        f = 1 - d,
                        p = l[1],
                        v = l[2],
                        g = l[3],
                        m = l[4],
                        y = Math.min(p, v),
                        x = Math.max(p, v),
                        _ = t(y),
                        w = t(x),
                        b = t(g),
                        M = t(m),
                        S = [[M, w], [b, _]],
                        A = [];
                        e(w, 0),
                        e(_, 1),
                        n[He](h, {
                            chartLayout: a,
                            sign: p > v ? -1 : v > p ? 1 : 0,
                            initBaseline: p > v ? w[f] : _[f],
                            bodyEnds: A,
                            whiskerEnds: S,
                            brushRect: s()
                        })
                    },
                    !0)
                })
            }
        }),
        e("echarts/chart/candlestick/candlestickVisual", [Tr],
        function() {
            var t = [li, ki, N],
            e = [li, ki, "borderColor0"],
            i = [li, ki, "color"],
            n = [li, ki, "color0"];
            return function(r) {
                r.eachRawSeriesByType("candlestick",
                function(a) {
                    var o = a[Kn]();
                    o[hn]({
                        legendSymbol: "roundRect"
                    }),
                    r.isSeriesFiltered(a) || o.each(function(r) {
                        var a = o[hi](r),
                        s = o[bi](r).sign;
                        o[Ue](r, {
                            color: a.get(s > 0 ? i: n),
                            borderColor: a.get(s > 0 ? t: e)
                        })
                    })
                })
            }
        }),
        e("echarts/processor/dataSample", [],
        function() {
            var t = {
                average: function(t) {
                    for (var e = 0,
                    i = 0,
                    n = 0; n < t[Wn]; n++) isNaN(t[n]) || (e += t[n], i++);
                    return 0 === i ? 0 / 0 : e / i
                },
                sum: function(t) {
                    for (var e = 0,
                    i = 0; i < t[Wn]; i++) e += t[i] || 0;
                    return e
                },
                max: function(t) {
                    for (var e = -1 / 0,
                    i = 0; i < t[Wn]; i++) t[i] > e && (e = t[i]);
                    return e
                },
                min: function(t) {
                    for (var e = 1 / 0,
                    i = 0; i < t[Wn]; i++) t[i] < e && (e = t[i]);
                    return e
                },
                nearest: function(t) {
                    return t[0]
                }
            },
            e = function(t) {
                return Math.round(t[Wn] / 2)
            };
            return function(i, n) {
                n[dn](i,
                function(i) {
                    var n = i[Kn](),
                    r = i.get("sampling"),
                    a = i[ln];
                    if (a.type === q && r) {
                        var o = a[Ie](),
                        s = a.getOtherAxis(o),
                        l = o[Fi](),
                        u = l[1] - l[0],
                        c = Math.round(n.count() / u);
                        if (c > 1) {
                            var h;
                            typeof r === yr ? h = t[r] : typeof r === Sn && (h = r),
                            h && (n = n.downSample(s.dim, 1 / c, h, e), i.setData(n))
                        }
                    }
                },
                this)
            }
        }),
        e("echarts/component/radar", [Tr, "../coord/radar/Radar", "../coord/radar/RadarModel", "./radar/RadarView"],
        function(t) {
            t("../coord/radar/Radar"),
            t("../coord/radar/RadarModel"),
            t("./radar/RadarView")
        }),
        e("echarts/chart/line/LineView", [Tr, Ar, "../helper/SymbolDraw", "../helper/Symbol", "./lineAnimationDiff", Si, "./poly", "../../view/Chart"],
        function(t) {
            function e(t, e) {
                if (t[Wn] === e[Wn]) {
                    for (var i = 0; i < t[Wn]; i++) {
                        var n = t[i],
                        r = e[i];
                        if (n[0] !== r[0] || n[1] !== r[1]) return
                    }
                    return ! 0
                }
            }
            function i(t) {
                return typeof t === yn ? t: t ? .3 : 0
            }
            function n(t) {
                var e = t.getGlobalExtent();
                if (t[Y]) {
                    var i = t.getBandWidth() / 2 - 1,
                    n = e[1] > e[0] ? 1 : -1;
                    e[0] += n * i,
                    e[1] -= n * i
                }
                return e
            }
            function r(t) {
                return t >= 0 ? 1 : -1
            }
            function a(t, e) {
                var i = t[Ie](),
                n = t.getOtherAxis(i),
                a = i.onZero ? 0 : n.scale[Fi]()[0],
                o = n.dim,
                s = "x" === o || o === Ze ? 1 : 0;
                return e[he]([o],
                function(n, l) {
                    for (var u, c = e.stackedOn; c && r(c.get(o, l)) === r(n);) {
                        u = c;
                        break
                    }
                    var h = [];
                    return h[s] = e.get(i.dim, l),
                    h[1 - s] = u ? u.get(o, l, !0) : a,
                    t[ae](h)
                },
                !0)
            }
            function o(t, e) {
                return null != e[zn] ? e[zn] : null != e.name ? t[Ae](e.name) : void 0
            }
            function s(t, e, i) {
                var r = n(t[J]("x")),
                a = n(t[J]("y")),
                o = t[Ie]()[K](),
                s = Math.min(r[0], r[1]),
                l = Math.min(a[0], a[1]),
                u = Math.max(r[0], r[1]) - s,
                c = Math.max(a[0], a[1]) - l,
                h = i.get("lineStyle.normal.width") || 2,
                d = i.get("clipOverflow") ? h / 2 : Math.max(u, c);
                o ? (l -= d, c += 2 * d) : (s -= d, u += 2 * d);
                var f = new m.Rect({
                    shape: {
                        x: s,
                        y: l,
                        width: u,
                        height: c
                    }
                });
                return e && (f.shape[o ? "width": nr] = 0, m[Xe](f, {
                    shape: {
                        width: u,
                        height: c
                    }
                },
                i)),
                f
            }
            function l(t, e, i) {
                var n = t.getAngleAxis(),
                r = t.getRadiusAxis(),
                a = r[Fi](),
                o = n[Fi](),
                s = Math.PI / 180,
                l = new m[_i]({
                    shape: {
                        cx: t.cx,
                        cy: t.cy,
                        r0: a[0],
                        r: a[1],
                        startAngle: -o[0] * s,
                        endAngle: -o[1] * s,
                        clockwise: n[Q]
                    }
                });
                return e && (l.shape.endAngle = -o[0] * s, m[Xe](l, {
                    shape: {
                        endAngle: -o[1] * s
                    }
                },
                i)),
                l
            }
            function u(t, e, i) {
                return "polar" === t.type ? l(t, e, i) : s(t, e, i)
            }
            function c(t, e, i) {
                for (var n = e[Ie](), r = "x" === n.dim || n.dim === Ze ? 0 : 1, a = [], o = 0; o < t[Wn] - 1; o++) {
                    var s = t[o + 1],
                    l = t[o];
                    a.push(l);
                    var u = [];
                    switch (i) {
                    case "end":
                        u[r] = s[r],
                        u[1 - r] = l[1 - r],
                        a.push(u);
                        break;
                    case Qi:
                        var c = (l[r] + s[r]) / 2,
                        h = [];
                        u[r] = h[r] = c,
                        u[1 - r] = l[1 - r],
                        h[1 - r] = s[1 - r],
                        a.push(u),
                        a.push(h);
                        break;
                    default:
                        u[r] = l[r],
                        u[1 - r] = s[1 - r],
                        a.push(u)
                    }
                }
                return t[o] && a.push(t[o]),
                a
            }
            function h(t, e) {
                return Math.max(Math.min(t, e[1]), e[0])
            }
            function d(t, e) {
                var i = t[ce]("visualMeta");
                if (i && i[Wn]) {
                    for (var n, r = i[Wn] - 1; r >= 0; r--) if (i[r].dimension < 2) {
                        n = i[r];
                        break
                    }
                    if (n && e.type === q) {
                        var a = n.dimension,
                        o = t[de][a],
                        s = t[Fe](o),
                        l = n.stops,
                        u = [];
                        l[0][R] && l.sort(function(t, e) {
                            return t[R][0] - e[R][0]
                        });
                        var c = l[0],
                        d = l[l[Wn] - 1],
                        f = c[R] ? h(c[R][0], s) : c.value,
                        p = d[R] ? h(d[R][1], s) : d.value,
                        v = p - f;
                        if (0 === v) return t[gi](0, "color");
                        for (var r = 0; r < l[Wn]; r++) if (l[r][R]) {
                            if (l[r][R][1] === l[r][R][0]) continue;
                            u.push({
                                offset: (h(l[r][R][0], s) - f) / v,
                                color: l[r].color
                            },
                            {
                                offset: (h(l[r][R][1], s) - f) / v,
                                color: l[r].color
                            })
                        } else u.push({
                            offset: (l[r].value - f) / v,
                            color: l[r].color
                        });
                        var g = new m.LinearGradient(0, 0, 0, 0, u, !0),
                        y = e[J](o),
                        x = Math.round(y[U](y[B](f))),
                        _ = Math.round(y[U](y[B](p)));
                        return g[o] = x,
                        g[o + "2"] = _,
                        g
                    }
                }
            }
            var f = t(Ar),
            p = t("../helper/SymbolDraw"),
            v = t("../helper/Symbol"),
            g = t("./lineAnimationDiff"),
            m = t(Si),
            y = t("./poly"),
            x = t("../../view/Chart");
            return x[jn]({
                type: "line",
                init: function() {
                    var t = new m.Group,
                    e = new p;
                    this.group.add(e.group),
                    this._symbolDraw = e,
                    this._lineGroup = t
                },
                render: function(t, n, r) {
                    var o = t[ln],
                    s = this.group,
                    l = t[Kn](),
                    h = t[fr]("lineStyle.normal"),
                    p = t[fr]("areaStyle.normal"),
                    v = l[he](l[bi], !0),
                    g = "polar" === o.type,
                    m = this._coordSys,
                    y = this._symbolDraw,
                    x = this._polyline,
                    _ = this._polygon,
                    w = this._lineGroup,
                    b = t.get(vr),
                    M = !p.isEmpty(),
                    S = a(o, l),
                    A = t.get("showSymbol"),
                    T = A && !g && !t.get("showAllSymbol") && this._getSymbolIgnoreFunc(l, o),
                    C = this._data;
                    C && C[Se](function(t, e) {
                        t.__temp && (s[Xn](t), C[$e](e, null))
                    }),
                    A || y[Xn](),
                    s.add(w);
                    var L = !g && t.get("step");
                    x && m.type === o.type && L === this._step ? (M && !_ ? _ = this._newPolygon(v, S, o, b) : _ && !M && (w[Xn](_), _ = this._polygon = null), w.setClipPath(u(o, !1, t)), A && y[yi](l, T), l[Se](function(t) {
                        t[sr](!0)
                    }), e(this._stackedOnPoints, S) && e(this._points, v) || (b ? this._updateAnimation(l, S, o, r, L) : (L && (v = c(v, o, L), S = c(S, o, L)), x[ci]({
                        points: v
                    }), _ && _[ci]({
                        points: v,
                        stackedOnPoints: S
                    })))) : (A && y[yi](l, T), L && (v = c(v, o, L), S = c(S, o, L)), x = this._newPolyline(v, o, b), M && (_ = this._newPolygon(v, S, o, b)), w.setClipPath(u(o, !0, t)));
                    var k = d(l, o) || l[ce]("color");
                    x[si](f[qn](h[ti](), {
                        fill: "none",
                        stroke: k,
                        lineJoin: "bevel"
                    }));
                    var P = t.get("smooth");
                    if (P = i(t.get("smooth")), x[ci]({
                        smooth: P,
                        smoothMonotone: t.get("smoothMonotone"),
                        connectNulls: t.get("connectNulls")
                    }), _) {
                        var I = l.stackedOn,
                        D = 0;
                        if (_[si](f[qn](p[V](), {
                            fill: k,
                            opacity: .7,
                            lineJoin: "bevel"
                        })), I) {
                            var z = I[fi];
                            D = i(z.get("smooth"))
                        }
                        _[ci]({
                            smooth: P,
                            stackedOnSmooth: D,
                            smoothMonotone: t.get("smoothMonotone"),
                            connectNulls: t.get("connectNulls")
                        })
                    }
                    this._data = l,
                    this._coordSys = o,
                    this._stackedOnPoints = S,
                    this._points = v,
                    this._step = L
                },
                highlight: function(t, e, i, n) {
                    var r = t[Kn](),
                    a = o(r, n);
                    if (! (a instanceof Array) && null != a && a >= 0) {
                        var s = r[Mi](a);
                        if (!s) {
                            var l = r[bi](a);
                            s = new v(r, a),
                            s[$i] = l,
                            s.setZ(t.get(Cn), t.get("z")),
                            s[ar] = isNaN(l[0]) || isNaN(l[1]),
                            s.__temp = !0,
                            r[$e](a, s),
                            s.stopSymbolAnimation(!0),
                            this.group.add(s)
                        }
                        s[Jn]()
                    } else x[xr][Jn].call(this, t, e, i, n)
                },
                downplay: function(t, e, i, n) {
                    var r = t[Kn](),
                    a = o(r, n);
                    if (null != a && a >= 0) {
                        var s = r[Mi](a);
                        s && (s.__temp ? (r[$e](a, null), this.group[Xn](s)) : s[$n]())
                    } else x[xr][$n].call(this, t, e, i, n)
                },
                _newPolyline: function(t) {
                    var e = this._polyline;
                    return e && this._lineGroup[Xn](e),
                    e = new y[xi]({
                        shape: {
                            points: t
                        },
                        silent: !0,
                        z2: 10
                    }),
                    this._lineGroup.add(e),
                    this._polyline = e,
                    e
                },
                _newPolygon: function(t, e) {
                    var i = this._polygon;
                    return i && this._lineGroup[Xn](i),
                    i = new y[we]({
                        shape: {
                            points: t,
                            stackedOnPoints: e
                        },
                        silent: !0
                    }),
                    this._lineGroup.add(i),
                    this._polygon = i,
                    i
                },
                _getSymbolIgnoreFunc: function(t, e) {
                    var i = e.getAxesByScale(Pe)[0];
                    return i && i.isLabelIgnored ? f.bind(i.isLabelIgnored, i) : void 0
                },
                _updateAnimation: function(t, e, i, n, r) {
                    var a = this._polyline,
                    o = this._polygon,
                    s = t[fi],
                    l = g(this._data, t, this._stackedOnPoints, e, this._coordSys, i),
                    u = l.current,
                    h = l.stackedOnCurrent,
                    d = l.next,
                    f = l.stackedOnNext;
                    r && (u = c(l.current, i, r), h = c(l.stackedOnCurrent, i, r), d = c(l.next, i, r), f = c(l.stackedOnNext, i, r)),
                    a.shape.__points = l.current,
                    a.shape[z] = u,
                    m[ui](a, {
                        shape: {
                            points: d
                        }
                    },
                    s),
                    o && (o[ci]({
                        points: u,
                        stackedOnPoints: h
                    }), m[ui](o, {
                        shape: {
                            points: d,
                            stackedOnPoints: f,
                            __points: l.next
                        }
                    },
                    s));
                    for (var p = [], v = l.status, y = 0; y < v[Wn]; y++) {
                        var x = v[y].cmd;
                        if ("=" === x) {
                            var _ = t[Mi](v[y].idx1);
                            _ && p.push({
                                el: _,
                                ptIdx: y
                            })
                        }
                    }
                    a.animators && a.animators[Wn] && a.animators[0].during(function() {
                        for (var t = 0; t < p[Wn]; t++) {
                            var e = p[t].el;
                            e.attr($i, a.shape.__points[p[t].ptIdx])
                        }
                    })
                },
                remove: function() {
                    var t = this.group,
                    e = this._data;
                    this._lineGroup[cn](),
                    this._symbolDraw[Xn](!0),
                    e && e[Se](function(i, n) {
                        i.__temp && (t[Xn](i), e[$e](n, null))
                    }),
                    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null
                }
            })
        }),
        e("echarts/chart/radar/RadarSeries", [Tr, le, Gi, Ni, Ar],
        function(t) {
            var e = t(le),
            i = t(Gi),
            n = t(Ni),
            r = t(Ar),
            a = e[jn]({
                type: "series.radar",
                dependencies: ["radar"],
                init: function() {
                    a[Oi](this, "init", arguments),
                    this.legendDataProvider = function() {
                        return this._dataBeforeProcessed
                    }
                },
                getInitialData: function(t) {
                    var e = t.data || [],
                    r = n([], e, [], "indicator_"),
                    a = new i(r, this);
                    return a[Di](e),
                    a
                },
                formatTooltip: function(t) {
                    var e = this[ke](t),
                    i = this[ln],
                    n = i.getIndicatorAxes();
                    return ("" == this._data[Ci](t) ? this.name: this._data[Ci](t)) + "<br/>" + r.map(n,
                    function(t, i) {
                        return t.name + " : " + e[i]
                    }).join(Le)
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: "radar",
                    legendHoverLink: !0,
                    radarIndex: 0,
                    lineStyle: {
                        normal: {
                            width: 2,
                            type: "solid"
                        }
                    },
                    label: {
                        normal: {
                            position: "top"
                        }
                    },
                    symbol: "emptyCircle",
                    symbolSize: 4
                }
            });
            return a
        }),
        e("echarts/chart/radar/backwardCompat", [Tr, Ar],
        function(t) {
            var e = t(Ar);
            return function(t) {
                var i = t.polar;
                if (i) {
                    e[An](i) || (i = [i]);
                    var n = [];
                    e.each(i,
                    function(i) {
                        i.indicator ? (i.type && !i.shape && (i.shape = i.type), t.radar = t.radar || [], e[An](t.radar) || (t.radar = [t.radar]), t.radar.push(i)) : n.push(i)
                    }),
                    t.polar = n
                }
                e.each(t[Fn],
                function(t) {
                    "radar" === t.type && t[D] && (t.radarIndex = t[D])
                })
            }
        }),
        e("echarts/chart/radar/RadarView", [Tr, Si, Ar, I, Ei],
        function(t) {
            function e(t) {
                return n[An](t) || (t = [ + t, +t]),
                t
            }
            var i = t(Si),
            n = t(Ar),
            r = t(I);
            return t(Ei)[xn]({
                type: "radar",
                render: function(t) {
                    function a(t, i) {
                        var n = t[gi](i, se) || fn,
                        a = t[gi](i, "color");
                        if ("none" !== n) {
                            var o = r[P](n, -.5, -.5, 1, 1, a);
                            return o.attr({
                                style: {
                                    strokeNoScale: !0
                                },
                                z2: 100,
                                scale: e(t[gi](i, oe))
                            }),
                            o
                        }
                    }
                    function o(e, n, r, o, s, l) {
                        r[cn]();
                        for (var u = 0; u < n[Wn] - 1; u++) {
                            var c = a(o, s);
                            c && (c.__dimIdx = u, e[u] ? (c.attr($i, e[u]), i[l ? Xe: ui](c, {
                                position: n[u]
                            },
                            t, s)) : c.attr($i, n[u]), r.add(c))
                        }
                    }
                    function s(t) {
                        return n.map(t,
                        function() {
                            return [l.cx, l.cy]
                        })
                    }
                    var l = t[ln],
                    u = this.group,
                    c = t[Kn](),
                    h = this._data;
                    c.diff(h).add(function(e) {
                        var n = c[bi](e);
                        if (n) {
                            var r = new i[we],
                            a = new i[xi],
                            l = {
                                shape: {
                                    points: n
                                }
                            };
                            r.shape[z] = s(n),
                            a.shape[z] = s(n),
                            i[Xe](r, l, t, e),
                            i[Xe](a, l, t, e);
                            var u = new i.Group,
                            h = new i.Group;
                            u.add(a),
                            u.add(r),
                            u.add(h),
                            o(a.shape[z], n, h, c, e, !0),
                            c[$e](e, u)
                        }
                    })[er](function(e, n) {
                        var r = h[Mi](n),
                        a = r[di](0),
                        s = r[di](1),
                        l = r[di](2),
                        u = {
                            shape: {
                                points: c[bi](e)
                            }
                        };
                        u.shape[z] && (o(a.shape[z], u.shape[z], l, c, e, !1), i[ui](a, u, t), i[ui](s, u, t), c[$e](e, r))
                    })[Xn](function(t) {
                        u[Xn](h[Mi](t))
                    })[Qe](),
                    c[Se](function(e, r) {
                        function a() {
                            h.attr(ar, m)
                        }
                        function o() {
                            h.attr(ar, g)
                        }
                        var s = c[hi](r),
                        l = e[di](0),
                        h = e[di](1),
                        d = e[di](2),
                        f = c[gi](r, "color");
                        u.add(e),
                        l[si](n[qn](s[fr]("lineStyle.normal")[ti](), {
                            fill: "none",
                            stroke: f
                        })),
                        l[oi] = s[fr]("lineStyle.emphasis")[ti]();
                        var p = s[fr]("areaStyle.normal"),
                        v = s[fr]("areaStyle.emphasis"),
                        g = p.isEmpty() && p.parentModel.isEmpty(),
                        m = v.isEmpty() && v.parentModel.isEmpty();
                        m = m && g,
                        h[ar] = g,
                        h[si](n[qn](p[V](), {
                            fill: f,
                            opacity: .7
                        })),
                        h[oi] = v[V]();
                        var y = s[fr](F)[sn](["color"]),
                        x = s[fr](H)[sn](),
                        _ = s[fr](ii),
                        w = s[fr](ei);
                        d[Je](function(e) {
                            e[Ln](y),
                            e[oi] = n.clone(x);
                            var a = c.get(c[de][e.__dimIdx], r);
                            i[me](e.style, _, f),
                            e[Ln]({
                                text: _.get("show") ? n[vi](t[pi](r, ki, null, e.__dimIdx), a) : ""
                            }),
                            i[me](e[oi], w, f),
                            e[oi].text = w.get("show") ? n[vi](t[pi](r, Li, null, e.__dimIdx), a) : ""
                        }),
                        e.off(En).off(On).off(ki).off(Li),
                        e.on(Li, a).on(En, a).on(ki, o).on(On, o),
                        i[ri](e)
                    }),
                    this._data = c
                },
                remove: function() {
                    this.group[cn](),
                    this._data = null
                }
            })
        }),
        e("echarts/chart/heatmap/HeatmapSeries", [Tr, le, "../helper/createListFromArray"],
        function(t) {
            var e = t(le),
            i = t("../helper/createListFromArray");
            return e[jn]({
                type: "series.heatmap",
                getInitialData: function(t, e) {
                    return i(t.data, this, e)
                },
                defaultOption: {
                    coordinateSystem: "cartesian2d",
                    zlevel: 0,
                    z: 2,
                    geoIndex: 0,
                    blurSize: 30,
                    pointSize: 20,
                    maxOpacity: 1,
                    minOpacity: 0
                }
            })
        }),
        e("echarts/chart/radar/radarLayout", [Tr],
        function() {
            return function(t) {
                t[dn]("radar",
                function(t) {
                    function e(t, e) {
                        n[e] = n[e] || [],
                        n[e][a] = r[ae](t, a)
                    }
                    var i = t[Kn](),
                    n = [],
                    r = t[ln];
                    if (r) {
                        for (var a = 0; a < r.getIndicatorAxes()[Wn]; a++) {
                            var o = i[de][a];
                            i.each(o, e)
                        }
                        i.each(function(t) {
                            n[t][0] && n[t].push(n[t][0].slice()),
                            i[He](t, n[t])
                        })
                    }
                })
            }
        }),
        e("echarts/chart/heatmap/HeatmapView", [Tr, Si, "./HeatmapLayer", Ar, Ei],
        function(t) {
            function e(t, e, i) {
                var n = t[1] - t[0];
                e = o.map(e,
                function(e) {
                    return {
                        interval: [(e[R][0] - t[0]) / n, (e[R][1] - t[0]) / n]
                    }
                });
                var r = e[Wn],
                a = 0;
                return function(t) {
                    for (var n = a; r > n; n++) {
                        var o = e[n][R];
                        if (o[0] <= t && t <= o[1]) {
                            a = n;
                            break
                        }
                    }
                    if (n === r) for (var n = a - 1; n >= 0; n--) {
                        var o = e[n][R];
                        if (o[0] <= t && t <= o[1]) {
                            a = n;
                            break
                        }
                    }
                    return n >= 0 && r > n && i[n]
                }
            }
            function i(t, e) {
                var i = t[1] - t[0];
                return e = [(e[0] - t[0]) / i, (e[1] - t[0]) / i],
                function(t) {
                    return t >= e[0] && t <= e[1]
                }
            }
            function n(t) {
                var e = t[de];
                return "lng" === e[0] && "lat" === e[1]
            }
            var r = t(Si),
            a = t("./HeatmapLayer"),
            o = t(Ar);
            return t(Ei)[xn]({
                type: "heatmap",
                render: function(t, e, i) {
                    var r;
                    e[or]("visualMap",
                    function(e) {
                        e.eachTargetSeries(function(i) {
                            i === t && (r = e)
                        })
                    }),
                    this.group[cn]();
                    var a = t[ln];
                    a.type === q ? this._renderOnCartesian(a, t, i) : n(a) && this._renderOnGeo(a, t, r, i)
                },
                _renderOnCartesian: function(t, e) {
                    var i = t[J]("x"),
                    n = t[J]("y"),
                    a = this.group,
                    s = i.getBandWidth(),
                    l = n.getBandWidth(),
                    u = e[Kn](),
                    c = F,
                    h = H,
                    d = ii,
                    f = ei,
                    p = e[fr](c)[sn](["color"]),
                    v = e[fr](h)[sn](),
                    g = e[fr](ii),
                    m = e[fr](ei);
                    u.each(["x", "y", "z"],
                    function(i, n, y, x) {
                        var _ = u[hi](x),
                        w = t[ae]([i, n]);
                        if (!isNaN(y)) {
                            var b = new r.Rect({
                                shape: {
                                    x: w[0] - s / 2,
                                    y: w[1] - l / 2,
                                    width: s,
                                    height: l
                                },
                                style: {
                                    fill: u[gi](x, "color"),
                                    opacity: u[gi](x, Yi)
                                }
                            });
                            u[fe] && (p = _[fr](c)[sn](["color"]), v = _[fr](h)[sn](), g = _[fr](d), m = _[fr](f));
                            var M = e[ke](x),
                            S = "-";
                            M && null != M[2] && (S = M[2]),
                            g[Ce]("show") && (r[me](p, g), p.text = e[pi](x, ki) || S),
                            m[Ce]("show") && (r[me](v, m), v.text = e[pi](x, Li) || S),
                            b[Ln](p),
                            r[ri](b, u[fe] ? v: o[jn]({},
                            v)),
                            a.add(b),
                            u[$e](x, b)
                        }
                    })
                },
                _renderOnGeo: function(t, n, o, s) {
                    var l = o.targetVisuals.inRange,
                    u = o.targetVisuals.outOfRange,
                    c = n[Kn](),
                    h = this._hmLayer || this._hmLayer || new a;
                    h.blurSize = n.get("blurSize"),
                    h.pointSize = n.get("pointSize"),
                    h.minOpacity = n.get("minOpacity"),
                    h.maxOpacity = n.get("maxOpacity");
                    var d = t.getViewRect().clone(),
                    f = t.getRoamTransform()[k];
                    d[_e](f);
                    var p = Math.max(d.x, 0),
                    v = Math.max(d.y, 0),
                    g = Math.min(d.width + d.x, s[dr]()),
                    m = Math.min(d[nr] + d.y, s[hr]()),
                    y = g - p,
                    x = m - v,
                    _ = c[he](["lng", "lat", "value"],
                    function(e, i, n) {
                        var r = t[ae]([e, i]);
                        return r[0] -= p,
                        r[1] -= v,
                        r.push(n),
                        r
                    }),
                    w = o[Fi](),
                    b = "visualMap.continuous" === o.type ? i(w, o[zi].range) : e(w, o.getPieceList(), o[zi][ai]);
                    h[er](_, y, x, l.color.getNormalizer(), {
                        inRange: l.color.getColorMapper(),
                        outOfRange: u.color.getColorMapper()
                    },
                    b);
                    var M = new r.Image({
                        style: {
                            width: y,
                            height: x,
                            x: p,
                            y: v,
                            image: h[mr]
                        },
                        silent: !0
                    });
                    this.group.add(M)
                }
            })
        }),
        e("echarts/chart/graph/GraphSeries", [Tr, Gi, Ar, Bi, W, "../helper/createGraphFromNodeEdge", Ei],
        function(t) {
            var e = t(Gi),
            i = t(Ar),
            n = t(Bi),
            r = t(W),
            a = t("../helper/createGraphFromNodeEdge"),
            o = t(Ei).extendSeriesModel({
                type: "series.graph",
                init: function(t) {
                    o[Oi](this, "init", arguments),
                    this.legendDataProvider = function() {
                        return this._categoriesData
                    },
                    this.fillDataTextStyle(t.edges || t.links),
                    this._updateCategoriesData()
                },
                mergeOption: function(t) {
                    o[Oi](this, Vi, arguments),
                    this.fillDataTextStyle(t.edges || t.links),
                    this._updateCategoriesData()
                },
                mergeDefaultAndTheme: function(t) {
                    o[Oi](this, De, arguments),
                    n[Pi](t.edgeLabel, n.LABEL_OPTIONS)
                },
                getInitialData: function(t) {
                    function e(t, e) {
                        t.wrapMethod(hi,
                        function(t) {
                            var e = o._categoriesModels,
                            i = t[Ce](te),
                            n = e[i];
                            return n && (n.parentModel = t.parentModel, t.parentModel = n),
                            t
                        });
                        var i = o[fr]("edgeLabel"),
                        n = function(t, e) {
                            var a = (t || "").split(".");
                            "label" === a[0] && (e = e || i[fr](a.slice(1)));
                            var o = r[xr][fr].call(this, a, e);
                            return o[fr] = n,
                            o
                        };
                        e.wrapMethod(hi,
                        function(t) {
                            return t[fr] = n,
                            t
                        })
                    }
                    var i = t.edges || t.links || [],
                    n = t.data || t.nodes || [],
                    o = this;
                    return n && i ? a(n, i, this, !0, e).data: void 0
                },
                getGraph: function() {
                    return this[Kn]().graph
                },
                getEdgeData: function() {
                    return this.getGraph().edgeData
                },
                getCategoriesData: function() {
                    return this._categoriesData
                },
                formatTooltip: function(t, e, i) {
                    if ("edge" === i) {
                        var n = this[Kn](),
                        r = this[In](t, i),
                        a = n.graph.getEdgeByIndex(t),
                        s = n[Ci](a.node1[zn]),
                        l = n[Ci](a.node2[zn]),
                        u = s + " > " + l;
                        return r.value && (u += " : " + r.value),
                        u
                    }
                    return o[Oi](this, "formatTooltip", arguments)
                },
                _updateCategoriesData: function() {
                    var t = i.map(this[zi].categories || [],
                    function(t) {
                        return null != t.value ? t: i[jn]({
                            value: 0
                        },
                        t)
                    }),
                    n = new e(["value"], this);
                    n[Di](t),
                    this._categoriesData = n,
                    this._categoriesModels = n[he](function(t) {
                        return n[hi](t, !0)
                    })
                },
                setZoom: function(t) {
                    this[zi].zoom = t
                },
                setCenter: function(t) {
                    this[zi][Ji] = t
                },
                ifEnableAnimation: function() {
                    return o[Ri](this, "ifEnableAnimation") && !("force" === this.get(E) && this.get("force.layoutAnimation"))
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: "view",
                    legendHoverLink: !0,
                    hoverAnimation: !0,
                    layout: null,
                    focusNodeAdjacency: !1,
                    circular: {
                        rotateLabel: !1
                    },
                    force: {
                        initLayout: null,
                        repulsion: [0, 50],
                        gravity: .1,
                        edgeLength: 30,
                        layoutAnimation: !0
                    },
                    left: "center",
                    top: "center",
                    symbol: "circle",
                    symbolSize: 10,
                    edgeSymbol: ["none", "none"],
                    edgeSymbolSize: 10,
                    edgeLabel: {
                        normal: {
                            position: "middle"
                        },
                        emphasis: {}
                    },
                    draggable: !1,
                    roam: !1,
                    center: null,
                    zoom: 1,
                    nodeScaleRatio: .6,
                    label: {
                        normal: {
                            show: !1,
                            formatter: "{b}"
                        },
                        emphasis: {
                            show: !0
                        }
                    },
                    itemStyle: {
                        normal: {},
                        emphasis: {}
                    },
                    lineStyle: {
                        normal: {
                            color: "#aaa",
                            width: 1,
                            curveness: 0,
                            opacity: .5
                        },
                        emphasis: {}
                    }
                }
            });
            return o
        }),
        e("echarts/chart/graph/GraphView", [Tr, "../helper/SymbolDraw", "../helper/LineDraw", "../../component/helper/RoamController", Si, "./adjustEdge", Ar, Ei],
        function(t) {
            function e(t, e) {
                return t[ce](Yi) || t[fr]().get(e)
            }
            var i = t("../helper/SymbolDraw"),
            n = t("../helper/LineDraw"),
            r = t("../../component/helper/RoamController"),
            a = t(Si),
            o = t("./adjustEdge"),
            s = t(Ar),
            l = [li, ki, Yi],
            u = [Ke, ki, Yi];
            t(Ei)[xn]({
                type: "graph",
                init: function(t, e) {
                    var a = new i,
                    o = new n,
                    s = this.group,
                    l = new r(e.getZr(), s);
                    s.add(a.group),
                    s.add(o.group),
                    this._symbolDraw = a,
                    this._lineDraw = o,
                    this._controller = l,
                    this._firstRender = !0
                },
                render: function(t, e, i) {
                    var n = t[ln];
                    this[pr] = t,
                    this._nodeScaleRatio = t.get("nodeScaleRatio");
                    var r = this._symbolDraw,
                    s = this._lineDraw,
                    l = this.group;
                    if ("view" === n.type) {
                        var u = {
                            position: n[$i],
                            scale: n.scale
                        };
                        this._firstRender ? l.attr(u) : a[ui](l, u, t)
                    }
                    o(t.getGraph(), this._getNodeGlobalScale(t));
                    var c = t[Kn]();
                    r[yi](c);
                    var h = t.getEdgeData();
                    s[yi](h),
                    this._updateNodeAndLinkScale(),
                    this._updateController(t, i),
                    clearTimeout(this._layoutTimeout);
                    var d = t.forceLayout,
                    f = t.get("force.layoutAnimation");
                    d && this._startForceLayoutIteration(d, f),
                    c[Se](function(t, e) {
                        var i = c[hi](e);
                        t.off("drag").off("dragend");
                        var n = c[hi](e).get(L);
                        n && t.on("drag",
                        function() {
                            d && (d.warmUp(), !this._layouting && this._startForceLayoutIteration(d, f), d.setFixed(e), c[He](e, t[$i]))
                        },
                        this).on("dragend",
                        function() {
                            d && d.setUnfixed(e)
                        },
                        this),
                        t.setDraggable(n && d),
                        t.off(En, this._focusNodeAdjacency),
                        t.off(On, this._unfocusAll),
                        i.get("focusNodeAdjacency") && (t.on(En, this._focusNodeAdjacency, this), t.on(On, this._unfocusAll, this))
                    },
                    this);
                    var p = "circular" === t.get(E) && t.get("circular.rotateLabel"),
                    v = c.getLayout("cx"),
                    g = c.getLayout("cy");
                    c[Se](function(t, e) {
                        var i = t.getSymbolPath();
                        if (p) {
                            var n = c[bi](e),
                            r = Math.atan2(n[1] - g, n[0] - v);
                            0 > r && (r = 2 * Math.PI + r);
                            var a = n[0] < v;
                            a && (r -= Math.PI);
                            var o = a ? "left": "right";
                            i[Ln]({
                                textRotation: r,
                                textPosition: o
                            }),
                            i[oi] && (i[oi][Z] = o)
                        } else i[Ln]({
                            textRotation: 0
                        })
                    }),
                    this._firstRender = !1
                },
                _focusNodeAdjacency: function(t) {
                    function i(t, i) {
                        var n = e(t, i),
                        r = t.getGraphicEl();
                        null == n && (n = 1),
                        r[kn](function(t) {
                            t[Zn](ki),
                            "group" !== t.type && t[Ln](Yi, .1 * n)
                        })
                    }
                    function n(t, i) {
                        var n = e(t, i),
                        r = t.getGraphicEl();
                        r[kn](function(t) {
                            t[Zn](Li),
                            "group" !== t.type && t[Ln](Yi, n)
                        })
                    }
                    var r = this[pr][Kn](),
                    a = r.graph,
                    o = t[Vn],
                    c = o[zn],
                    h = o[Pn];
                    if (null !== c && "edge" !== h) {
                        a[C](function(t) {
                            i(t, l)
                        }),
                        a.eachEdge(function(t) {
                            i(t, u)
                        });
                        var d = a.getNodeByIndex(c);
                        n(d, l),
                        s.each(d.edges,
                        function(t) {
                            t[zn] < 0 || (n(t, u), n(t.node1, l), n(t.node2, l))
                        })
                    }
                },
                _unfocusAll: function() {
                    var t = this[pr][Kn](),
                    i = t.graph;
                    i[C](function(t) {
                        var i = e(t, l);
                        t.getGraphicEl()[kn](function(t) {
                            t[Zn](ki),
                            "group" !== t.type && t[Ln](Yi, i)
                        })
                    }),
                    i.eachEdge(function(t) {
                        var i = e(t, u);
                        t.getGraphicEl()[kn](function(t) {
                            t[Zn](ki),
                            "group" !== t.type && t[Ln](Yi, i)
                        })
                    })
                },
                _startForceLayoutIteration: function(t, e) {
                    var i = this; !
                    function n() {
                        t.step(function(t) {
                            i[Qn](i[pr]),
                            (i._layouting = !t) && (e ? i._layoutTimeout = setTimeout(n, 16) : n())
                        })
                    } ()
                },
                _updateController: function(t, e) {
                    var i = this._controller,
                    n = this.group;
                    return i[T] = function() {
                        var t = n[en]();
                        return t[_e](n[k]),
                        t
                    },
                    "view" !== t[ln].type ? void i.disable() : (i.enable(t.get("roam")), i.zoomLimit = t.get("scaleLimit"), i.zoom = t[ln].getZoom(), void i.off("pan").off("zoom").on("pan",
                    function(i, n) {
                        e[Un]({
                            seriesId: t.id,
                            type: "graphRoam",
                            dx: i,
                            dy: n
                        })
                    }).on("zoom",
                    function(i, n, r) {
                        e[Un]({
                            seriesId: t.id,
                            type: "graphRoam",
                            zoom: i,
                            originX: n,
                            originY: r
                        }),
                        this._updateNodeAndLinkScale(),
                        o(t.getGraph(), this._getNodeGlobalScale(t)),
                        this._lineDraw[Qn]()
                    },
                    this))
                },
                _updateNodeAndLinkScale: function() {
                    var t = this[pr],
                    e = t[Kn](),
                    i = this._getNodeGlobalScale(t),
                    n = [i, i];
                    e[Se](function(t) {
                        t.attr("scale", n)
                    })
                },
                _getNodeGlobalScale: function(t) {
                    var e = t[ln];
                    if ("view" !== e.type) return 1;
                    var i = this._nodeScaleRatio,
                    n = e.scale,
                    r = n && n[0] || 1,
                    a = e.getZoom(),
                    o = (a - 1) * i + 1;
                    return o / r
                },
                updateLayout: function(t) {
                    o(t.getGraph(), this._getNodeGlobalScale(t)),
                    this._symbolDraw[Qn](),
                    this._lineDraw[Qn]()
                },
                remove: function() {
                    this._symbolDraw && this._symbolDraw[Xn](),
                    this._lineDraw && this._lineDraw[Xn]()
                }
            })
        }),
        e("echarts/chart/graph/roamAction", [Tr, Ei, "../../action/roamHelper"],
        function(t) {
            var e = t(Ei),
            i = t("../../action/roamHelper"),
            n = {
                type: "graphRoam",
                event: "graphRoam",
                update: "none"
            };
            e[Mn](n,
            function(t, e) {
                e[or]({
                    mainType: "series",
                    query: t
                },
                function(e) {
                    var n = e[ln],
                    r = i.updateCenterAndZoom(n, t);
                    e.setCenter && e.setCenter(r[Ji]),
                    e.setZoom && e.setZoom(r.zoom)
                })
            })
        }),
        e("echarts/chart/graph/simpleLayout", [Tr, "./simpleLayoutHelper", "./simpleLayoutEdge"],
        function(t) {
            var e = t("./simpleLayoutHelper"),
            i = t("./simpleLayoutEdge");
            return function(t) {
                t[dn]("graph",
                function(t) {
                    var n = t.get(E),
                    r = t[ln];
                    if (r && "view" !== r.type) {
                        var a = t[Kn]();
                        a.each(r[de],
                        function(t, e, i) {
                            isNaN(t) || isNaN(e) ? a[He](i, [0 / 0, 0 / 0]) : a[He](i, r[ae]([t, e]))
                        }),
                        i(a.graph)
                    } else n && "none" !== n || e(t)
                })
            }
        }),
        e("echarts/chart/graph/categoryFilter", [Tr],
        function() {
            return function(t) {
                var e = t.findComponents({
                    mainType: "legend"
                });
                e && e[Wn] && t[dn]("graph",
                function(t) {
                    var i = t.getCategoriesData(),
                    n = t.getGraph(),
                    r = n.data,
                    a = i[he](i[Ci]);
                    r.filterSelf(function(t) {
                        var i = r[hi](t),
                        n = i[Ce](te);
                        if (null != n) {
                            typeof n === yn && (n = a[n]);
                            for (var o = 0; o < e[Wn]; o++) if (!e[o].isSelected(n)) return ! 1
                        }
                        return ! 0
                    })
                },
                this)
            }
        }),
        e("echarts/chart/graph/categoryVisual", [Tr],
        function() {
            return function(t) {
                var e = {};
                t[dn]("graph",
                function(t) {
                    var i = t.getCategoriesData(),
                    n = t[Kn](),
                    r = {};
                    i.each(function(n) {
                        var a = i[Ci](n);
                        r[a] = n;
                        var o = i[hi](n),
                        s = o.get("itemStyle.normal.color") || t.getColorFromPalette(a, e);
                        i[Ue](n, "color", s)
                    }),
                    i.count() && n.each(function(t) {
                        var e = n[hi](t),
                        a = e[Ce](te);
                        null != a && (typeof a === yr && (a = r[a]), n[gi](t, "color", !0) || n[Ue](t, "color", i[gi](a, "color")))
                    })
                })
            }
        }),
        e("echarts/chart/graph/edgeVisual", [Tr],
        function() {
            function t(t) {
                return t instanceof Array || (t = [t, t]),
                t
            }
            return function(e) {
                e[dn]("graph",
                function(e) {
                    var i = e.getGraph(),
                    n = e.getEdgeData(),
                    r = t(e.get("edgeSymbol")),
                    a = t(e.get("edgeSymbolSize")),
                    o = "lineStyle.normal.color".split("."),
                    s = "lineStyle.normal.opacity".split(".");
                    n[hn]("fromSymbol", r && r[0]),
                    n[hn]("toSymbol", r && r[1]),
                    n[hn]("fromSymbolSize", a && a[0]),
                    n[hn]("toSymbolSize", a && a[1]),
                    n[hn]("color", e.get(o)),
                    n[hn](Yi, e.get(s)),
                    n.each(function(e) {
                        var r = n[hi](e),
                        a = i.getEdgeByIndex(e),
                        l = t(r[Ce](se, !0)),
                        u = t(r[Ce](oe, !0)),
                        c = r.get(o),
                        h = r.get(s);
                        switch (c) {
                        case "source":
                            c = a.node1[ce]("color");
                            break;
                        case Vn:
                            c = a.node2[ce]("color")
                        }
                        l[0] && a[hn]("fromSymbol", l[0]),
                        l[1] && a[hn]("toSymbol", l[1]),
                        u[0] && a[hn]("fromSymbolSize", u[0]),
                        u[1] && a[hn]("toSymbolSize", u[1]),
                        a[hn]("color", c),
                        a[hn](Yi, h)
                    })
                })
            }
        }),
        e("echarts/chart/graph/circularLayout", [Tr, "./circularLayoutHelper"],
        function(t) {
            var e = t("./circularLayoutHelper");
            return function(t) {
                t[dn]("graph",
                function(t) {
                    "circular" === t.get(E) && e(t)
                })
            }
        }),
        e("echarts/chart/graph/createView", [Tr, "../../coord/View", re, "zrender/core/bbox"],
        function(t) {
            function e(t, e, i) {
                var r = t[tn]();
                return r.aspect = i,
                n[Ki](r, {
                    width: e[dr](),
                    height: e[hr]()
                })
            }
            var i = t("../../coord/View"),
            n = t(re),
            r = t("zrender/core/bbox");
            return function(t, n) {
                var a = [];
                return t[dn]("graph",
                function(t) {
                    var o = t.get(ln);
                    if (!o || "view" === o) {
                        var s = new i;
                        a.push(s);
                        var l = t[Kn](),
                        u = l[he](function(t) {
                            var e = l[hi](t);
                            return [ + e.get("x"), +e.get("y")]
                        }),
                        c = [],
                        h = [];
                        r.fromPoints(u, c, h),
                        h[0] - c[0] === 0 && (h[0] += 1, c[0] -= 1),
                        h[1] - c[1] === 0 && (h[1] += 1, c[1] -= 1);
                        var d = (h[0] - c[0]) / (h[1] - c[1]),
                        f = e(t, n, d);
                        isNaN(d) && (c = [f.x, f.y], h = [f.x + f.width, f.y + f[nr]]);
                        var p = h[0] - c[0],
                        v = h[1] - c[1],
                        g = f.width,
                        m = f[nr];
                        s = t[ln] = new i,
                        s.zoomLimit = t.get("scaleLimit"),
                        s.setBoundingRect(c[0], c[1], p, v),
                        s.setViewRect(f.x, f.y, g, m),
                        s.setCenter(t.get(Ji)),
                        s.setZoom(t.get("zoom"))
                    }
                }),
                a
            }
        }),
        e("echarts/chart/treemap/TreemapSeries", [Tr, le, "../../data/Tree", Ar, W, G],
        function(t) {
            function e(t, i) {
                var n = 0;
                a.each(t.children,
                function(t) {
                    e(t, i);
                    var r = t.value;
                    a[An](r) && (r = r[0]),
                    n += r
                });
                var r = t.value;
                i >= 0 && (a[An](r) ? r = r[0] : t.value = new Array(i)),
                (null == r || isNaN(r)) && (r = n),
                0 > r && (r = 0),
                i >= 0 ? t.value[0] = r: t.value = r
            }
            function i(t, e) {
                var i = e.get("color");
                if (i) {
                    t = t || [];
                    var n;
                    if (a.each(t,
                    function(t) {
                        var e = new o(t),
                        i = e.get("color"); (e.get("itemStyle.normal.color") || i && "none" !== i) && (n = !0)
                    }), !n) {
                        var r = t[0] || (t[0] = {});
                        r.color = i.slice()
                    }
                    return t
                }
            }
            var n = t(le),
            r = t("../../data/Tree"),
            a = t(Ar),
            o = t(W),
            s = t(G),
            l = s[Ve],
            u = s[ze];
            return n[jn]({
                type: "series.treemap",
                dependencies: ["grid", "polar"],
                _viewRoot: null,
                defaultOption: {
                    progressive: 0,
                    hoverLayerThreshold: 1 / 0,
                    left: "center",
                    top: "middle",
                    right: null,
                    bottom: null,
                    width: "80%",
                    height: "80%",
                    sort: !0,
                    clipWindow: "origin",
                    squareRatio: .5 * (1 + Math.sqrt(5)),
                    leafDepth: null,
                    drillDownIcon: "▶",
                    visualDimension: 0,
                    zoomToNodeRatio: .1024,
                    roam: !0,
                    nodeClick: "zoomToNode",
                    animation: !0,
                    animationDurationUpdate: 900,
                    animationEasing: "quinticInOut",
                    breadcrumb: {
                        show: !0,
                        height: 22,
                        left: "center",
                        top: "bottom",
                        emptyItemWidth: 25,
                        itemStyle: {
                            normal: {
                                color: "rgba(0,0,0,0.7)",
                                borderColor: "rgba(255,255,255,0.7)",
                                borderWidth: 1,
                                shadowColor: "rgba(150,150,150,1)",
                                shadowBlur: 3,
                                shadowOffsetX: 0,
                                shadowOffsetY: 0,
                                textStyle: {
                                    color: "#fff"
                                }
                            },
                            emphasis: {
                                textStyle: {}
                            }
                        }
                    },
                    label: {
                        normal: {
                            show: !0,
                            position: "inside",
                            textStyle: {
                                color: "#fff",
                                ellipsis: !0
                            }
                        }
                    },
                    itemStyle: {
                        normal: {
                            color: null,
                            colorAlpha: null,
                            colorSaturation: null,
                            borderWidth: 0,
                            gapWidth: 0,
                            borderColor: "#fff",
                            borderColorSaturation: null
                        },
                        emphasis: {}
                    },
                    color: [],
                    colorAlpha: null,
                    colorSaturation: null,
                    colorMappingBy: "index",
                    visibleMin: 10,
                    childrenVisibleMin: null,
                    levels: []
                },
                getInitialData: function(t, n) {
                    var o = t.data || [],
                    s = t.name;
                    null == s && (s = t.name);
                    var l = {
                        name: s,
                        children: t.data
                    },
                    u = (o[0] || {}).value;
                    e(l, a[An](u) ? u[Wn] : -1);
                    var c = t.levels || [];
                    return c = t.levels = i(c, n),
                    r.createTree(l, this, c).data
                },
                optionUpdated: function() {
                    this.resetViewRoot()
                },
                formatTooltip: function(t) {
                    var e = this[Kn](),
                    i = this[ke](t),
                    n = u(a[An](i) ? i[0] : i),
                    r = e[Ci](t);
                    return l(r) + ": " + n
                },
                getDataParams: function(t) {
                    for (var e = n[xr][In].apply(this, arguments), i = this[Kn](), r = i.tree.getNodeByDataIndex(t), a = e.treePathInfo = []; r;) {
                        var o = r[zn];
                        a.push({
                            name: r.name,
                            dataIndex: o,
                            value: this[ke](o)
                        }),
                        r = r[A]
                    }
                    return a[S](),
                    e
                },
                setLayoutInfo: function(t) {
                    this.layoutInfo = this.layoutInfo || {},
                    a[jn](this.layoutInfo, t)
                },
                mapIdToIndex: function(t) {
                    var e = this._idIndexMap;
                    e || (e = this._idIndexMap = {},
                    this._idIndexMapCount = 0);
                    var i = e[t];
                    return null == i && (e[t] = i = this._idIndexMapCount++),
                    i
                },
                getViewRoot: function() {
                    return this._viewRoot
                },
                resetViewRoot: function(t) {
                    t ? this._viewRoot = t: t = this._viewRoot;
                    var e = this[Kn]().tree.root; (!t || t !== e && !e.contains(t)) && (this._viewRoot = e)
                }
            })
        }),
        e("echarts/chart/graph/forceLayout", [Tr, "./forceHelper", qe, "./simpleLayoutHelper", "./circularLayoutHelper", wr, Ar],
        function(t) {
            var e = t("./forceHelper"),
            i = t(qe),
            n = t("./simpleLayoutHelper"),
            r = t("./circularLayoutHelper"),
            a = t(wr),
            o = t(Ar);
            return function(t) {
                t[dn]("graph",
                function(t) {
                    var s = t[ln];
                    if (!s || "view" === s.type) if ("force" === t.get(E)) {
                        var l = t.preservedPoints || {},
                        u = t.getGraph(),
                        c = u.data,
                        h = u.edgeData,
                        d = t[fr]("force"),
                        f = d.get("initLayout");
                        t.preservedPoints ? c.each(function(t) {
                            var e = c.getId(t);
                            c[He](t, l[e] || [0 / 0, 0 / 0])
                        }) : f && "none" !== f ? "circular" === f && r(t) : n(t);
                        var p = c[Fe]("value"),
                        v = h[Fe]("value"),
                        g = d.get("repulsion"),
                        m = d.get("edgeLength");
                        o[An](g) || (g = [g, g]),
                        o[An](m) || (m = [m, m]),
                        m = [m[1], m[0]];
                        var y = c[he]("value",
                        function(t, e) {
                            var n = c[bi](e),
                            r = i[Ge](t, p, g);
                            return isNaN(r) && (r = (g[0] + g[1]) / 2),
                            {
                                w: r,
                                rep: r,
                                p: !n || isNaN(n[0]) || isNaN(n[1]) ? null: n
                            }
                        }),
                        x = h[he]("value",
                        function(t, e) {
                            var n = u.getEdgeByIndex(e),
                            r = i[Ge](t, v, m);
                            return isNaN(r) && (r = (m[0] + m[1]) / 2),
                            {
                                n1: y[n.node1[zn]],
                                n2: y[n.node2[zn]],
                                d: r,
                                curveness: n[fr]().get("lineStyle.normal.curveness") || 0
                            }
                        }),
                        s = t[ln],
                        _ = s[en](),
                        w = e(y, x, {
                            rect: _,
                            gravity: d.get("gravity")
                        }),
                        b = w.step;
                        w.step = function(t) {
                            for (var e = 0,
                            i = y[Wn]; i > e; e++) y[e].fixed && a.copy(y[e].p, u.getNodeByIndex(e).getLayout());
                            b(function(e, i, n) {
                                for (var r = 0,
                                o = e[Wn]; o > r; r++) e[r].fixed || u.getNodeByIndex(r)[ue](e[r].p),
                                l[c.getId(r)] = e[r].p;
                                for (var r = 0,
                                o = i[Wn]; o > r; r++) {
                                    var s = i[r],
                                    h = u.getEdgeByIndex(r),
                                    d = s.n1.p,
                                    f = s.n2.p,
                                    p = h.getLayout();
                                    p = p ? p.slice() : [],
                                    p[0] = p[0] || [],
                                    p[1] = p[1] || [],
                                    a.copy(p[0], d),
                                    a.copy(p[1], f),
                                    +s.curveness && (p[2] = [(d[0] + f[0]) / 2 - (d[1] - f[1]) * s.curveness, (d[1] + f[1]) / 2 - (f[0] - d[0]) * s.curveness]),
                                    h[ue](p)
                                }
                                t && t(n)
                            })
                        },
                        t.forceLayout = w,
                        t.preservedPoints = l,
                        w.step()
                    } else t.forceLayout = null
                })
            }
        }),
        e("echarts/chart/treemap/treemapAction", [Tr, Ei, "./helper"],
        function(t) {
            for (var e = t(Ei), i = t("./helper"), n = function() {},
            r = ["treemapZoomToNode", "treemapRender", "treemapMove"], a = 0; a < r[Wn]; a++) e[Mn]({
                type: r[a],
                update: "updateView"
            },
            n);
            e[Mn]({
                type: "treemapRootToNode",
                update: "updateView"
            },
            function(t, e) {
                function n(e) {
                    var n = i.retrieveTargetInfo(t, e);
                    if (n) {
                        var r = e.getViewRoot();
                        r && (t.direction = i.aboveViewRoot(r, n.node) ? "rollUp": "drillDown"),
                        e.resetViewRoot(n.node)
                    }
                }
                e[or]({
                    mainType: "series",
                    subType: "treemap",
                    query: t
                },
                n)
            })
        }),
        e("echarts/chart/treemap/treemapVisual", [Tr, "../../visual/VisualMapping", Mr, Ar],
        function(t) {
            function e(t, a, s, u, c, d) {
                var p = t[fr](),
                v = t.getLayout();
                if (v && !v[M] && v.isInView) {
                    var g, m = t[fr](f),
                    y = s[t.depth],
                    x = i(m, a, y, u),
                    _ = m.get(N),
                    w = m.get("borderColorSaturation");
                    null != w && (g = n(x, t), _ = r(w, g)),
                    t[hn](N, _);
                    var b = t.viewChildren;
                    if (b && b[Wn]) {
                        var S = o(t, p, v, m, x, b);
                        h.each(b,
                        function(t, i) {
                            if (t.depth >= c[Wn] || t === c[t.depth]) {
                                var n = l(p, x, t, i, S, d);
                                e(t, n, s, u, c, d)
                            }
                        })
                    } else g = n(x, t),
                    t[hn]("color", g)
                }
            }
            function i(t, e, i, n) {
                var r = h[jn]({},
                e);
                return h.each(["color", "colorAlpha", "colorSaturation"],
                function(a) {
                    var o = t.get(a, !0);
                    null == o && i && (o = i[a]),
                    null == o && (o = e[a]),
                    null == o && (o = n.get(a)),
                    null != o && (r[a] = o)
                }),
                r
            }
            function n(t) {
                var e = a(t, "color");
                if (e) {
                    var i = a(t, "colorAlpha"),
                    n = a(t, "colorSaturation");
                    return n && (e = c.modifyHSL(e, null, null, n)),
                    i && (e = c.modifyAlpha(e, i)),
                    e
                }
            }
            function r(t, e) {
                return null != e ? c.modifyHSL(e, null, null, t) : null
            }
            function a(t, e) {
                var i = t[e];
                return null != i && "none" !== i ? i: void 0
            }
            function o(t, e, i, n, r, a) {
                if (a && a[Wn]) {
                    var o = s(e, "color") || null != r.color && "none" !== r.color && (s(e, "colorAlpha") || s(e, "colorSaturation"));
                    if (o) {
                        var l = e.get("colorMappingBy"),
                        c = {
                            type: o.name,
                            dataExtent: i.dataExtent,
                            visual: o.range
                        };
                        "color" !== c.type || "index" !== l && "id" !== l ? c.mappingMethod = b: (c.mappingMethod = te, c.loop = !0);
                        var h = new u(c);
                        return h.__drColorMappingBy = l,
                        h
                    }
                }
            }
            function s(t, e) {
                var i = t.get(e);
                return d(i) && i[Wn] ? {
                    name: e,
                    range: i
                }: null
            }
            function l(t, e, i, n, r, a) {
                var o = h[jn]({},
                e);
                if (r) {
                    var s = r.type,
                    l = "color" === s && r.__drColorMappingBy,
                    u = "index" === l ? n: "id" === l ? a.mapIdToIndex(i.getId()) : i.getValue(t.get("visualDimension"));
                    o[s] = r.mapValueToVisual(u)
                }
                return o
            }
            var u = t("../../visual/VisualMapping"),
            c = t(Mr),
            h = t(Ar),
            d = h[An],
            f = F;
            return function(t, i, n) {
                var r = {
                    mainType: "series",
                    subType: "treemap",
                    query: n
                };
                t[or](r,
                function(t) {
                    var i = t[Kn]().tree,
                    n = i.root,
                    r = t[fr](f);
                    if (!n.isRemoved()) {
                        var a = h.map(i.levelModels,
                        function(t) {
                            return t ? t.get(f) : null
                        });
                        e(n, {},
                        a, r, t.getViewRoot().getAncestors(), t)
                    }
                })
            }
        }),
        e("echarts/chart/treemap/TreemapView", [Tr, Ar, Si, "../../data/DataDiffer", "./helper", "./Breadcrumb", "../../component/helper/RoamController", Me, br, "../../util/animation", Ei],
        function(t) {
            function e() {
                return {
                    nodeGroup: [],
                    background: [],
                    content: []
                }
            }
            function i(t, e, i, o, s, l, u, c, h, d) {
                function f(e) {
                    E[zn] = u[zn],
                    E[Dn] = t[Dn];
                    var i = C.borderWidth,
                    n = Math.max(k - 2 * i, 0),
                    r = Math.max(P - 2 * i, 0);
                    E.culling = !0,
                    E[ci]({
                        x: i,
                        y: i,
                        width: n,
                        height: r
                    });
                    var o = u[ce]("color", !0);
                    g(E,
                    function() {
                        var t = {
                            fill: o
                        },
                        e = u[fr](H)[sn]();
                        m(t, e, o, n, r),
                        E[Ln](t),
                        a[ri](E, e)
                    }),
                    e.add(E)
                }
                function g(t, e) {
                    I ? !t[M] && l.push(t) : (e(), t.__tmWillVisible || (t[M] = !1))
                }
                function m(e, i, n, r, a) {
                    var o = u[fr](),
                    s = o.get("name");
                    if (C.isLeafRoot) {
                        var l = t.get("drillDownIcon", !0);
                        s = l ? l + " " + s: test
                    }
                    _(s, e, o, y, n, r, a),
                    _(s, i, o, x, n, r, a)
                }
                function _(t, e, i, n, r, o, s) {
                    var l = i[fr](n),
                    u = l[fr](on);
                    a[me](e, l, r),
                    e[an] = u.get("align"),
                    e.textVerticalAlign = u.get("baseline");
                    var c = u.getTextRect(t);
                    e.text = !l[Ce]("show") || c[nr] > s ? "": c.width > o ? u.get("ellipsis") ? u.truncateText(t, o, null, {
                        minChar: 2
                    }) : "": t
                }
                function w(t, r, a, o) {
                    var l = null != z && i[t][z],
                    u = s[t];
                    return l ? (i[t][z] = null, b(u, l, t)) : I || (l = new r({
                        z: n(a, o)
                    }), l.__tmDepth = a, l.__tmStorageName = t, T(u, l, t)),
                    e[t][D] = l
                }
                function b(t, e, i) {
                    var n = t[D] = {};
                    n.old = "nodeGroup" === i ? e[$i].slice() : r[jn]({},
                    e.shape)
                }
                function T(t, e, i) {
                    var n = t[D] = {},
                    r = u[A];
                    if (r && (!o || "drillDown" === o.direction)) {
                        var a = 0,
                        l = 0,
                        c = s.background[r[je]()]; ! o && c && c.old && (a = c.old.width, l = c.old[nr]),
                        n.old = "nodeGroup" === i ? [0, l] : {
                            x: a,
                            y: l,
                            width: 0,
                            height: 0
                        }
                    }
                    n.fadein = "nodeGroup" !== i
                }
                if (u) {
                    var C = u.getLayout();
                    if (C && C.isInView) {
                        var k = C.width,
                        P = C[nr],
                        I = C[M],
                        D = u[je](),
                        z = c && c[je](),
                        V = w("nodeGroup", p);
                        if (V) {
                            if (h.add(V), V.attr($i, [C.x || 0, C.y || 0]), V.__tmNodeWidth = k, V.__tmNodeHeight = P, C.isAboveViewRoot) return V;
                            var R = w("background", v, d, S);
                            R && (R[ci]({
                                x: 0,
                                y: 0,
                                width: k,
                                height: P
                            }), g(R,
                            function() {
                                R[Ln]("fill", u[ce](N, !0))
                            }), V.add(R));
                            var O = u.viewChildren;
                            if (!O || !O[Wn]) {
                                var E = w("content", v, d, L);
                                E && f(V)
                            }
                            return V
                        }
                    }
                }
            }
            function n(t, e) {
                var i = t * b + e;
                return (i - 1) / i
            }
            var r = t(Ar),
            a = t(Si),
            o = t("../../data/DataDiffer"),
            s = t("./helper"),
            l = t("./Breadcrumb"),
            u = t("../../component/helper/RoamController"),
            c = t(Me),
            h = t(br),
            d = t("../../util/animation"),
            f = r.bind,
            p = a.Group,
            v = a.Rect,
            g = r.each,
            m = 3,
            y = ["label", ki],
            x = ["label", Li],
            b = 10,
            S = 1,
            L = 2;
            return t(Ei)[xn]({
                type: "treemap",
                init: function() {
                    this._containerGroup,
                    this._storage = e(),
                    this._oldTree,
                    this._breadcrumb,
                    this._controller,
                    this._state = "ready",
                    this._mayClick
                },
                render: function(t, e, i, n) {
                    var a = e.findComponents({
                        mainType: "series",
                        subType: "treemap",
                        query: n
                    });
                    if (! (r[gn](a, t) < 0)) {
                        this.seriesModel = t,
                        this.api = i,
                        this[Te] = e;
                        var o = s.retrieveTargetInfo(n, t),
                        l = n && n.type,
                        u = t.layoutInfo,
                        c = !this._oldTree,
                        h = this._storage,
                        d = "treemapRootToNode" === l && o && h ? {
                            rootNodeGroup: h.nodeGroup[o.node[je]()],
                            direction: n.direction
                        }: null,
                        f = this._giveContainerGroup(u),
                        p = this._doRender(f, t, d);
                        c || l && "treemapZoomToNode" !== l && "treemapRootToNode" !== l ? p.renderFinally() : this._doAnimation(f, p, t, d),
                        this._resetController(i),
                        this._renderBreadcrumb(t, i, o)
                    }
                },
                _giveContainerGroup: function(t) {
                    var e = this._containerGroup;
                    return e || (e = this._containerGroup = new p, this._initEvents(e), this.group.add(e)),
                    e.attr($i, [t.x, t.y]),
                    e
                },
                _doRender: function(t, n, a) {
                    function s(t, e, i, n, a) {
                        function l(t) {
                            return t.getId()
                        }
                        function u(r, o) {
                            var l = null != r ? t[r] : null,
                            u = null != o ? e[o] : null,
                            c = m(l, u, i, a);
                            c && s(l && l.viewChildren || [], u && u.viewChildren || [], c, n, a + 1)
                        }
                        n ? (e = t, g(t,
                        function(t, e) { ! t.isRemoved() && u(e, e)
                        })) : new o(e, t, l, l).add(u)[er](u)[Xn](r.curry(u, null))[Qe]()
                    }
                    function l(t) {
                        var i = e();
                        return t && g(t,
                        function(t, e) {
                            var n = i[e];
                            g(t,
                            function(t) {
                                t && (n.push(t), t.__tmWillDelete = 1)
                            })
                        }),
                        i
                    }
                    function u() {
                        g(y,
                        function(t) {
                            g(t,
                            function(t) {
                                t[pe] && t[pe][Xn](t)
                            })
                        }),
                        g(v,
                        function(t) {
                            t[M] = !0,
                            t.dirty()
                        })
                    }
                    var c = n[Kn]().tree,
                    h = this._oldTree,
                    d = e(),
                    f = e(),
                    p = this._storage,
                    v = [],
                    m = r.curry(i, n, f, p, a, d, v);
                    s(c.root ? [c.root] : [], h && h.root ? [h.root] : [], t, c === h || !h, 0);
                    var y = l(p);
                    return this._oldTree = c,
                    this._storage = f,
                    {
                        lastsForAnimation: d,
                        willDeleteEls: y,
                        renderFinally: u
                    }
                },
                _doAnimation: function(t, e, i, n) {
                    if (i.get(vr)) {
                        var a = i.get("animationDurationUpdate"),
                        o = i.get("animationEasing"),
                        s = d.createWrap();
                        g(e.willDeleteEls,
                        function(t, e) {
                            g(t,
                            function(t) {
                                if (!t[M]) {
                                    var i, r = t[pe];
                                    if (n && "drillDown" === n.direction) i = r === n.rootNodeGroup ? {
                                        shape: {
                                            x: 0,
                                            y: 0,
                                            width: r.__tmNodeWidth,
                                            height: r.__tmNodeHeight
                                        },
                                        style: {
                                            opacity: 0
                                        }
                                    }: {
                                        style: {
                                            opacity: 0
                                        }
                                    };
                                    else {
                                        var l = 0,
                                        u = 0;
                                        r.__tmWillDelete || (l = r.__tmNodeWidth / 2, u = r.__tmNodeHeight / 2),
                                        i = "nodeGroup" === e ? {
                                            position: [l, u],
                                            style: {
                                                opacity: 0
                                            }
                                        }: {
                                            shape: {
                                                x: l,
                                                y: u,
                                                width: 0,
                                                height: 0
                                            },
                                            style: {
                                                opacity: 0
                                            }
                                        }
                                    }
                                    i && s.add(t, i, a, o)
                                }
                            })
                        }),
                        g(this._storage,
                        function(t, i) {
                            g(t,
                            function(t, n) {
                                var l = e.lastsForAnimation[i][n],
                                u = {};
                                l && ("nodeGroup" === i ? l.old && (u[$i] = t[$i].slice(), t.attr($i, l.old)) : (l.old && (u.shape = r[jn]({},
                                t.shape), t[ci](l.old)), l.fadein ? (t[Ln](Yi, 0), u.style = {
                                    opacity: 1
                                }) : 1 !== t.style[Yi] && (u.style = {
                                    opacity: 1
                                })), s.add(t, u, a, o))
                            })
                        },
                        this),
                        this._state = "animating",
                        s.done(f(function() {
                            this._state = "ready",
                            e.renderFinally()
                        },
                        this)).start()
                    }
                },
                _resetController: function(t) {
                    var e = this._controller;
                    e || (e = this._controller = new u(t.getZr()), e.enable(this.seriesModel.get("roam")), e.on("pan", f(this._onPan, this)), e.on("zoom", f(this._onZoom, this)));
                    var i = new c(0, 0, t[dr](), t[hr]());
                    e[T] = function() {
                        return i
                    }
                },
                _clearController: function() {
                    var t = this._controller;
                    t && (t.off("pan").off("zoom"), t = null)
                },
                _onPan: function(t, e) {
                    if (this._mayClick = !1, "animating" !== this._state && (Math.abs(t) > m || Math.abs(e) > m)) {
                        var i = this.seriesModel[Kn]().tree.root;
                        if (!i) return;
                        var n = i.getLayout();
                        if (!n) return;
                        this.api[Un]({
                            type: "treemapMove",
                            from: this.uid,
                            seriesId: this.seriesModel.id,
                            rootRect: {
                                x: n.x + t,
                                y: n.y + e,
                                width: n.width,
                                height: n[nr]
                            }
                        })
                    }
                },
                _onZoom: function(t, e, i) {
                    if (this._mayClick = !1, "animating" !== this._state) {
                        var n = this.seriesModel[Kn]().tree.root;
                        if (!n) return;
                        var r = n.getLayout();
                        if (!r) return;
                        var a = new c(r.x, r.y, r.width, r[nr]),
                        o = this.seriesModel.layoutInfo;
                        e -= o.x,
                        i -= o.y;
                        var s = h[ir]();
                        h.translate(s, s, [ - e, -i]),
                        h.scale(s, s, [t, t]),
                        h.translate(s, s, [e, i]),
                        a[_e](s),
                        this.api[Un]({
                            type: "treemapRender",
                            from: this.uid,
                            seriesId: this.seriesModel.id,
                            rootRect: {
                                x: a.x,
                                y: a.y,
                                width: a.width,
                                height: a[nr]
                            }
                        })
                    }
                },
                _initEvents: function(t) {
                    function e(t) {
                        var e = this.seriesModel.get("nodeClick", !0);
                        if (e) {
                            var i = this.findTarget(t[w], t[_]);
                            if (i) {
                                var n = i.node;
                                if (n.getLayout().isLeafRoot) this._rootToNode(i);
                                else if ("zoomToNode" === e) this._zoomToNode(i);
                                else if ("link" === e) {
                                    var r = n.hostTree.data[hi](n[zn]),
                                    a = r.get("link", !0),
                                    o = r.get(Vn, !0) || "blank";
                                    a && window.open(a, o)
                                }
                            }
                        }
                    }
                    t.on("mousedown",
                    function() {
                        "ready" === this._state && (this._mayClick = !0)
                    },
                    this),
                    t.on("mouseup",
                    function(t) {
                        this._mayClick && (this._mayClick = !1, "ready" === this._state && e.call(this, t))
                    },
                    this)
                },
                _renderBreadcrumb: function(t, e, i) {
                    function n(e) {
                        "animating" !== this._state && (s.aboveViewRoot(t.getViewRoot(), e) ? this._rootToNode({
                            node: e
                        }) : this._zoomToNode({
                            node: e
                        }))
                    }
                    i || (i = this.findTarget(e[dr]() / 2, e[hr]() / 2), i || (i = {
                        node: t[Kn]().tree.root
                    })),
                    (this._breadcrumb || (this._breadcrumb = new l(this.group, f(n, this))))[Bn](t, e, i.node)
                },
                remove: function() {
                    this._clearController(),
                    this._containerGroup && this._containerGroup[cn](),
                    this._storage = e(),
                    this._state = "ready",
                    this._breadcrumb && this._breadcrumb[Xn]()
                },
                dispose: function() {
                    this._clearController()
                },
                _zoomToNode: function(t) {
                    this.api[Un]({
                        type: "treemapZoomToNode",
                        from: this.uid,
                        seriesId: this.seriesModel.id,
                        targetNode: t.node
                    })
                },
                _rootToNode: function(t) {
                    this.api[Un]({
                        type: "treemapRootToNode",
                        from: this.uid,
                        seriesId: this.seriesModel.id,
                        targetNode: t.node
                    })
                },
                findTarget: function(t, e) {
                    var i, n = this.seriesModel.getViewRoot();
                    return n[C]({
                        attr: "viewChildren",
                        order: "preorder"
                    },
                    function(n) {
                        var r = this._storage.background[n[je]()];
                        if (r) {
                            var a = r.transformCoordToLocal(t, e),
                            o = r.shape;
                            if (! (o.x <= a[0] && a[0] <= o.x + o.width && o.y <= a[1] && a[1] <= o.y + o[nr])) return ! 1;
                            i = {
                                node: n,
                                offsetX: a[0],
                                offsetY: a[1]
                            }
                        }
                    },
                    this),
                    i
                }
            })
        }),
        e("echarts/chart/treemap/treemapLayout", [Tr, Ar, qe, re, "./helper", Me],
        function(t) {
            function e(t, e, n) {
                var r = {
                    mainType: "series",
                    subType: "treemap",
                    query: n
                };
                t[or](r,
                function(t) {
                    var r = e[dr](),
                    a = e[hr](),
                    o = t[zi],
                    s = o.size || [],
                    l = x(_(o.width, s[0]), r),
                    f = x(_(o[nr], s[1]), a),
                    m = p[Ki](t[tn](), {
                        width: e[dr](),
                        height: e[hr]()
                    }),
                    y = n && n.type,
                    b = v.retrieveTargetInfo(n, t),
                    M = "treemapRender" === y || "treemapMove" === y ? n.rootRect: null,
                    S = t.getViewRoot(),
                    A = v.getPathToRoot(S);
                    if ("treemapMove" !== y) {
                        var T = "treemapZoomToNode" === y ? u(t, b, S, l, f) : M ? [M.width, M[nr]] : [l, f],
                        C = o.sort;
                        C && "asc" !== C && "desc" !== C && (C = "desc");
                        var L = {
                            squareRatio: o.squareRatio,
                            sort: C,
                            leafDepth: o.leafDepth
                        };
                        S.hostTree.clearLayouts();
                        var k = {
                            x: 0,
                            y: 0,
                            width: T[0],
                            height: T[1],
                            area: T[0] * T[1]
                        };
                        S[ue](k),
                        i(S, L, !1, 0);
                        var k = S.getLayout();
                        w(A,
                        function(t, e) {
                            var i = (A[e + 1] || S).getValue();
                            t[ue](d[jn]({
                                dataExtent: [i, i],
                                borderWidth: 0
                            },
                            k))
                        })
                    }
                    var P = t[Kn]().tree.root;
                    P[ue](c(m, M, b), !0),
                    t.setLayoutInfo(m),
                    h(P, new g( - m.x, -m.y, r, a), A, S, 0)
                })
            }
            function i(t, e, r, a) {
                var o, u;
                if (!t.isRemoved()) {
                    var c = t.getLayout();
                    o = c.width,
                    u = c[nr];
                    var h = t[fr](F),
                    d = h.get("borderWidth"),
                    f = h.get("gapWidth") / 2,
                    p = d - f,
                    v = t[fr]();
                    t[ue]({
                        borderWidth: d
                    },
                    !0),
                    o = m(o - 2 * p, 0),
                    u = m(u - 2 * p, 0);
                    var g = o * u,
                    x = n(t, v, g, e, r, a);
                    if (x[Wn]) {
                        var _ = {
                            x: p,
                            y: p,
                            width: o,
                            height: u
                        },
                        w = y(o, u),
                        b = 1 / 0,
                        M = [];
                        M.area = 0;
                        for (var S = 0,
                        A = x[Wn]; A > S;) {
                            var T = x[S];
                            M.push(T),
                            M.area += T.getLayout().area;
                            var C = s(M, w, e.squareRatio);
                            b >= C ? (S++, b = C) : (M.area -= M.pop().getLayout().area, l(M, w, _, f, !1), w = y(_.width, _[nr]), M[Wn] = M.area = 0, b = 1 / 0)
                        }
                        if (M[Wn] && l(M, w, _, f, !0), !r) {
                            var L = v.get("childrenVisibleMin");
                            null != L && L > g && (r = !0)
                        }
                        for (var S = 0,
                        A = x[Wn]; A > S; S++) i(x[S], e, r, a + 1)
                    }
                }
            }
            function n(t, e, i, n, s, l) {
                var u = t.children || [],
                c = n.sort;
                "asc" !== c && "desc" !== c && (c = null);
                var h = null != n.leafDepth && n.leafDepth <= l;
                if (s && !h) return t.viewChildren = [];
                u = d[mn](u,
                function(t) {
                    return ! t.isRemoved()
                }),
                a(u, c);
                var f = o(e, u, c);
                if (0 === f.sum) return t.viewChildren = [];
                if (f.sum = r(e, i, f.sum, c, u), 0 === f.sum) return t.viewChildren = [];
                for (var p = 0,
                v = u[Wn]; v > p; p++) {
                    var g = u[p].getValue() / f.sum * i;
                    u[p][ue]({
                        area: g
                    })
                }
                return h && (u[Wn] && t[ue]({
                    isLeafRoot: !0
                },
                !0), u[Wn] = 0),
                t.viewChildren = u,
                t[ue]({
                    dataExtent: f.dataExtent
                },
                !0),
                u
            }
            function r(t, e, i, n, r) {
                if (!n) return i;
                for (var a = t.get("visibleMin"), o = r[Wn], s = o, l = o - 1; l >= 0; l--) {
                    var u = r["asc" === n ? o - l - 1 : l].getValue();
                    a > u / i * e && (s = l, i -= u)
                }
                return "asc" === n ? r[Gn](0, o - s) : r[Gn](s, o - s),
                i
            }
            function a(t, e) {
                return e && t.sort(function(t, i) {
                    return "asc" === e ? t.getValue() - i.getValue() : i.getValue() - t.getValue()
                }),
                t
            }
            function o(t, e, i) {
                for (var n = 0,
                r = 0,
                a = e[Wn]; a > r; r++) n += e[r].getValue();
                var o, s = t.get("visualDimension");
                if (e && e[Wn]) if ("value" === s && i) o = [e[e[Wn] - 1].getValue(), e[0].getValue()],
                "asc" === i && o[S]();
                else {
                    var o = [1 / 0, -1 / 0];
                    w(e,
                    function(t) {
                        var e = t.getValue(s);
                        e < o[0] && (o[0] = e),
                        e > o[1] && (o[1] = e)
                    })
                } else o = [0 / 0, 0 / 0];
                return {
                    sum: n,
                    dataExtent: o
                }
            }
            function s(t, e, i) {
                for (var n, r = 0,
                a = 1 / 0,
                o = 0,
                s = t[Wn]; s > o; o++) n = t[o].getLayout().area,
                n && (a > n && (a = n), n > r && (r = n));
                var l = t.area * t.area,
                u = e * e * i;
                return l ? m(u * r / l, l / (u * a)) : 1 / 0
            }
            function l(t, e, i, n, r) {
                var a = e === i.width ? 0 : 1,
                o = 1 - a,
                s = ["x", "y"],
                l = ["width", nr],
                u = i[s[a]],
                c = e ? t.area / e: 0; (r || c > i[l[o]]) && (c = i[l[o]]);
                for (var h = 0,
                d = t[Wn]; d > h; h++) {
                    var f = t[h],
                    p = {},
                    v = c ? f.getLayout().area / c: 0,
                    g = p[l[o]] = m(c - 2 * n, 0),
                    x = i[s[a]] + i[l[a]] - u,
                    _ = h === d - 1 || v > x ? x: v,
                    w = p[l[a]] = m(_ - 2 * n, 0);
                    p[s[o]] = i[s[o]] + y(n, g / 2),
                    p[s[a]] = u + y(n, w / 2),
                    u += _,
                    f[ue](p, !0)
                }
                i[s[o]] += c,
                i[l[o]] -= c
            }
            function u(t, e, i, n, r) {
                var a = (e || {}).node,
                o = [n, r];
                if (!a || a === i) return o;
                for (var s, l = n * r,
                u = l * t[zi].zoomToNodeRatio; s = a[A];) {
                    for (var c = 0,
                    h = s.children,
                    d = 0,
                    p = h[Wn]; p > d; d++) c += h[d].getValue();
                    var v = a.getValue();
                    if (0 === v) return o;
                    u *= c / v;
                    var g = s[fr](F).get("borderWidth");
                    isFinite(g) && (u += 4 * g * g + 4 * g * Math.pow(u, .5)),
                    u > f.MAX_SAFE_INTEGER && (u = f.MAX_SAFE_INTEGER),
                    a = s
                }
                l > u && (u = l);
                var m = Math.pow(u / l, .5);
                return [n * m, r * m]
            }
            function c(t, e, i) {
                if (e) return {
                    x: e.x,
                    y: e.y
                };
                var n = {
                    x: 0,
                    y: 0
                };
                if (!i) return n;
                var r = i.node,
                a = r.getLayout();
                if (!a) return n;
                for (var o = [a.width / 2, a[nr] / 2], s = r; s;) {
                    var l = s.getLayout();
                    o[0] += l.x,
                    o[1] += l.y,
                    s = s[A]
                }
                return {
                    x: t.width / 2 - o[0],
                    y: t[nr] / 2 - o[1]
                }
            }
            function h(t, e, i, n, r) {
                var a = t.getLayout(),
                o = i[r],
                s = o && o === t;
                if (! (o && !s || r === i[Wn] && t !== n)) {
                    t[ue]({
                        isInView: !0,
                        invisible: !s && !e.intersect(a),
                        isAboveViewRoot: s
                    },
                    !0);
                    var l = new g(e.x - a.x, e.y - a.y, e.width, e[nr]);
                    w(t.viewChildren || [],
                    function(t) {
                        h(t, l, i, n, r + 1)
                    })
                }
            }
            var d = t(Ar),
            f = t(qe),
            p = t(re),
            v = t("./helper"),
            g = t(Me),
            v = t("./helper"),
            m = Math.max,
            y = Math.min,
            x = f[We],
            _ = d[vi],
            w = d.each;
            return e
        }),
        e("echarts/chart/map/MapSeries", [Tr, Gi, le, Ar, Ni, G, "../../component/helper/selectableMixin", "../../coord/geo/geoCreator"],
        function(t) {
            var e = t(Gi),
            i = t(le),
            n = t(Ar),
            r = t(Ni),
            a = t(G),
            o = a[Ve],
            s = a[ze],
            l = t("../../component/helper/selectableMixin"),
            u = t("../../coord/geo/geoCreator"),
            c = i[jn]({
                type: "series.map",
                layoutMode: "box",
                needsDrawMap: !1,
                seriesGroup: [],
                init: function(t) {
                    t = this._fillOption(t, t.map),
                    this[zi] = t,
                    c[Oi](this, "init", arguments),
                    this.updateSelectedMap(t.data)
                },
                getInitialData: function(t) {
                    var i = r(["value"], t.data || []),
                    n = new e(i, this);
                    return n[Di](t.data),
                    n
                },
                mergeOption: function(t) {
                    t.data && (t = this._fillOption(t, this[zi].map)),
                    c[Ri](this, Vi, t),
                    this.updateSelectedMap(this[zi].data)
                },
                _fillOption: function(t, e) {
                    return t = n[jn]({},
                    t),
                    t.data = u.getFilledRegions(t.data, e),
                    t
                },
                getRawValue: function(t) {
                    return this._data.get("value", t)
                },
                getRegionModel: function(t) {
                    var e = this[Kn]();
                    return e[hi](e[Ae](t))
                },
                formatTooltip: function(t) {
                    for (var e = this[Kn](), i = s(this[ke](t)), n = e[Ci](t), r = this.seriesGroup, a = [], l = 0; l < r[Wn]; l++) {
                        var u = r[l].originalData[Ae](n);
                        isNaN(r[l].originalData.get("value", u)) || a.push(o(r[l].name))
                    }
                    return a.join(", ") + Le + n + " : " + i
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: "geo",
                    map: "china",
                    left: "center",
                    top: "center",
                    aspectScale: .75,
                    showLegendSymbol: !0,
                    dataRangeHoverLink: !0,
                    center: null,
                    zoom: 1,
                    scaleLimit: null,
                    label: {
                        normal: {
                            show: !1,
                            textStyle: {
                                color: "#000"
                            }
                        },
                        emphasis: {
                            show: !0,
                            textStyle: {
                                color: "rgb(100,0,0)"
                            }
                        }
                    },
                    itemStyle: {
                        normal: {
                            borderWidth: .5,
                            borderColor: "#444",
                            areaColor: "#eee"
                        },
                        emphasis: {
                            areaColor: "rgba(255,215,0,0.8)"
                        }
                    }
                },
                setZoom: function(t) {
                    this[zi].zoom = t
                },
                setCenter: function(t) {
                    this[zi][Ji] = t
                }
            });
            return n.mixin(c, l),
            c
        }),
        e("echarts/chart/map/MapView", [Tr, Si, "../../component/helper/MapDraw", Ei],
        function(t) {
            var e = t(Si),
            i = t("../../component/helper/MapDraw");
            t(Ei)[xn]({
                type: "map",
                render: function(t, e, n, r) {
                    if (!r || "mapToggleSelect" !== r.type || r.from !== this.uid) {
                        var a = this.group;
                        if (a[cn](), r && "geoRoam" === r.type && r.componentType === Fn && r.seriesId === t.id) {
                            var o = this._mapDraw;
                            o && a.add(o.group)
                        } else if (t.needsDrawMap) {
                            var o = this._mapDraw || new i(n, !0);
                            a.add(o.group),
                            o.draw(t, e, n, this, r),
                            this._mapDraw = o
                        } else this._mapDraw && this._mapDraw[Xn](),
                        this._mapDraw = null;
                        t.get("showLegendSymbol") && e[Re]("legend") && this._renderSymbols(t, e, n)
                    }
                },
                remove: function() {
                    this._mapDraw && this._mapDraw[Xn](),
                    this._mapDraw = null,
                    this.group[cn]()
                },
                _renderSymbols: function(t) {
                    var i = t.originalData,
                    n = this.group;
                    i.each("value",
                    function(r, a) {
                        if (!isNaN(r)) {
                            var o = i[bi](a);
                            if (o && o.point) {
                                var s = o.point,
                                l = o.offset,
                                u = new e[be]({
                                    style: {
                                        fill: t[Kn]()[ce]("color")
                                    },
                                    shape: {
                                        cx: s[0] + 9 * l,
                                        cy: s[1],
                                        r: 3
                                    },
                                    silent: !0,
                                    z2: 10
                                });
                                if (!l) {
                                    var c = t.mainSeries[Kn](),
                                    h = i[Ci](a),
                                    d = h,
                                    f = c[Ae](h),
                                    p = i[hi](a),
                                    v = p[fr](ii),
                                    g = p[fr](ei),
                                    m = v[fr](on),
                                    y = g[fr](on),
                                    x = c[Mi](f);
                                    u[Ln]({
                                        textPosition: "bottom"
                                    });
                                    var _ = function() {
                                        u[Ln]({
                                            text: g.get("show") ? d: "",
                                            textFill: y[nn](),
                                            textFont: y[rn]()
                                        })
                                    },
                                    w = function() {
                                        u[Ln]({
                                            text: v.get("show") ? d: "",
                                            textFill: m[nn](),
                                            textFont: m[rn]()
                                        })
                                    };
                                    x.on(En, _).on(On, w).on(Li, _).on(ki, w),
                                    w()
                                }
                                n.add(u)
                            }
                        }
                    })
                }
            })
        }),
        e("echarts/action/geoRoam", [Tr, Ar, "./roamHelper", "../echarts"],
        function(t) {
            var e = t(Ar),
            i = t("./roamHelper"),
            n = t("../echarts");
            n[Mn]({
                type: "geoRoam",
                event: "geoRoam",
                update: "updateLayout"
            },
            function(t, n) {
                var r = t.componentType || Fn;
                n[or]({
                    mainType: r,
                    query: t
                },
                function(n) {
                    var a = n[ln];
                    if ("geo" === a.type) {
                        var o = i.updateCenterAndZoom(a, t, n.get("scaleLimit"));
                        n.setCenter && n.setCenter(o[Ji]),
                        n.setZoom && n.setZoom(o.zoom),
                        r === Fn && e.each(n.seriesGroup,
                        function(t) {
                            t.setCenter(o[Ji]),
                            t.setZoom(o.zoom)
                        })
                    }
                })
            })
        }),
        e("echarts/coord/geo/geoCreator", [Tr, "./Geo", re, Ar, qe, Ei],
        function(t) {
            function e(t, e) {
                var i, n = this[en](),
                a = t.get("layoutCenter"),
                s = t.get("layoutSize"),
                l = e[dr](),
                u = e[hr](),
                c = t.get("aspectScale") || .75,
                h = n.width / n[nr] * c,
                d = !1;
                a && s && (a = [o[We](a[0], l), o[We](a[1], u)], s = o[We](s, Math.min(l, u)), isNaN(a[0]) || isNaN(a[1]) || isNaN(s) || (d = !0));
                var f;
                if (d) {
                    var f = {};
                    h > 1 ? (f.width = s, f[nr] = s / h) : (f[nr] = s, f.width = s * h),
                    f.y = a[1] - f[nr] / 2,
                    f.x = a[0] - f.width / 2
                } else i = t[tn](),
                i.aspect = h,
                f = r[Ki](i, {
                    width: l,
                    height: u
                });
                this.setViewRect(f.x, f.y, f.width, f[nr]),
                this.setCenter(t.get(Ji)),
                this.setZoom(t.get("zoom"))
            }
            function i(t, e) {
                a.each(e.get("geoCoord"),
                function(e, i) {
                    t.addGeoCoord(i, e)
                })
            }
            var n = t("./Geo"),
            r = t(re),
            a = t(Ar),
            o = t(qe),
            s = {},
            l = {
                dimensions: n[xr][de],
                create: function(t, r) {
                    var o = [];
                    t[or]("geo",
                    function(t, a) {
                        var l = t.get("map"),
                        u = s[l],
                        c = new n(l + a, l, u && u.geoJson, u && u.specialAreas, t.get("nameMap"));
                        c.zoomLimit = t.get("scaleLimit"),
                        o.push(c),
                        i(c, t),
                        t[ln] = c,
                        c.model = t,
                        c[gr] = e,
                        c[gr](t, r)
                    }),
                    t[tr](function(t) {
                        var e = t.get(ln);
                        if ("geo" === e) {
                            var i = t.get("geoIndex") || 0;
                            t[ln] = o[i]
                        }
                    });
                    var l = {};
                    return t[dn]("map",
                    function(t) {
                        var e = t.get("map");
                        l[e] = l[e] || [],
                        l[e].push(t)
                    }),
                    a.each(l,
                    function(t, l) {
                        var u = s[l],
                        c = a.map(t,
                        function(t) {
                            return t.get("nameMap")
                        }),
                        h = new n(l, l, u && u.geoJson, u && u.specialAreas, a.mergeAll(c));
                        h.zoomLimit = a[vi].apply(null, a.map(t,
                        function(t) {
                            return t.get("scaleLimit")
                        })),
                        o.push(h),
                        h[gr] = e,
                        h[gr](t[0], r),
                        a.each(t,
                        function(t) {
                            t[ln] = h,
                            i(h, t)
                        })
                    }),
                    o
                },
                registerMap: function(t, e, i) {
                    e.geoJson && !e.features && (i = e.specialAreas, e = e.geoJson),
                    typeof e === yr && (e = typeof JSON !== Be && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")()),
                    s[t] = {
                        geoJson: e,
                        specialAreas: i
                    }
                },
                getMap: function(t) {
                    return s[t]
                },
                getFilledRegions: function(t, e) {
                    var i = (t || []).slice(),
                    n = l.getMap(e),
                    r = n && n.geoJson;
                    if (!r) return t;
                    for (var a = {},
                    o = r.features,
                    s = 0; s < i[Wn]; s++) a[i[s].name] = i[s];
                    for (var s = 0; s < o[Wn]; s++) {
                        var u = o[s].properties.name;
                        a[u] || i.push({
                            name: u
                        })
                    }
                    return i
                }
            },
            u = t(Ei);
            return u.registerMap = l.registerMap,
            u.getMap = l.getMap,
            u.loadMap = function() {},
            u.registerCoordinateSystem("geo", l),
            l
        }),
        e("echarts/chart/map/mapSymbolLayout", [Tr, Ar],
        function(t) {
            var e = t(Ar);
            return function(t) {
                var i = {};
                t[dn]("map",
                function(n) {
                    var r = n.get("map");
                    if (!i[r]) {
                        var a = {};
                        e.each(n.seriesGroup,
                        function(e) {
                            var i = e[ln],
                            n = e.originalData;
                            e.get("showLegendSymbol") && t[Re]("legend") && n.each("value",
                            function(t, e) {
                                var r = n[Ci](e),
                                o = i.getRegion(r);
                                if (o && !isNaN(t)) {
                                    var s = a[r] || 0,
                                    l = i[ae](o[Ji]);
                                    a[r] = s + 1,
                                    n[He](e, {
                                        point: l,
                                        offset: s
                                    })
                                }
                            })
                        });
                        var o = n[Kn]();
                        o.each(function(t) {
                            var e = o[Ci](t),
                            i = o[bi](t) || {};
                            i.showLabel = !a[e],
                            o[He](t, i)
                        }),
                        i[r] = !0
                    }
                })
            }
        }),
        e("echarts/chart/map/backwardCompat", [Tr, Ar],
        function(t) {
            var e = t(Ar);
            return function(t) {
                var i = [];
                e.each(t[Fn],
                function(t) {
                    "map" === t.type && i.push(t)
                }),
                e.each(i,
                function(t) {
                    t.map = t.map || t.mapType,
                    e[qn](t, t.mapLocation)
                })
            }
        }),
        e("echarts/chart/map/mapDataStatistic", [Tr, Ar],
        function(t) {
            function e(t, e) {
                for (var i = {},
                n = ["value"], r = 0; r < t[Wn]; r++) t[r].each(n,
                function(e, n) {
                    var a = t[r][Ci](n);
                    i[a] = i[a] || [],
                    isNaN(e) || i[a].push(e)
                });
                return t[0].map(n,
                function(n, r) {
                    for (var a = t[0][Ci](r), o = 0, s = 1 / 0, l = -1 / 0, u = i[a][Wn], c = 0; u > c; c++) s = Math.min(s, i[a][c]),
                    l = Math.max(l, i[a][c]),
                    o += i[a][c];
                    var h;
                    return h = "min" === e ? s: "max" === e ? l: "average" === e ? o / u: o,
                    0 === u ? 0 / 0 : h
                })
            }
            var i = t(Ar);
            return function(t) {
                var n = {};
                t[dn]("map",
                function(t) {
                    var e = t.get("map");
                    n[e] = n[e] || [],
                    n[e].push(t)
                }),
                i.each(n,
                function(t) {
                    for (var n = e(i.map(t,
                    function(t) {
                        return t[Kn]()
                    }), t[0].get("mapValueCalculation")), r = 0; r < t[Wn]; r++) t[r].originalData = t[r][Kn]();
                    for (var r = 0; r < t[Wn]; r++) t[r].seriesGroup = t,
                    t[r].needsDrawMap = 0 === r,
                    t[r].setData(n.cloneShallow()),
                    t[r].mainSeries = t[0]
                })
            }
        }),
        e("echarts/chart/map/mapVisual", [Tr],
        function() {
            return function(t) {
                t[dn]("map",
                function(t) {
                    var e = t.get("color"),
                    i = t[fr](F),
                    n = i.get("areaColor"),
                    r = i.get("color") || e[t[Dn] % e[Wn]];
                    t[Kn]()[hn]({
                        areaColor: n,
                        color: r
                    })
                })
            }
        }),
        e("echarts/chart/lines/LinesView", [Tr, "../helper/LineDraw", "../helper/EffectLine", "../helper/Line", "../helper/Polyline", "../helper/EffectPolyline", "../helper/LargeLineDraw", Ei],
        function(t) {
            var e = t("../helper/LineDraw"),
            i = t("../helper/EffectLine"),
            n = t("../helper/Line"),
            r = t("../helper/Polyline"),
            a = t("../helper/EffectPolyline"),
            o = t("../helper/LargeLineDraw");
            t(Ei)[xn]({
                type: "lines",
                init: function() {},
                render: function(t, s, l) {
                    var u = t[Kn](),
                    c = this._lineDraw,
                    h = t.get("effect.show"),
                    d = t.get("polyline"),
                    f = t.get("large") && u.count() >= t.get("largeThreshold"); (h !== this._hasEffet || d !== this._isPolyline || f !== this._isLarge) && (c && c[Xn](), c = this._lineDraw = f ? new o: new e(d ? h ? a: r: h ? i: n), this._hasEffet = h, this._isPolyline = d, this._isLarge = f);
                    var p = t.get(Cn),
                    v = t.get("effect.trailLength"),
                    g = l.getZr();
                    if (g.painter.getLayer(p).clear(!0), null != this._lastZlevel && g.configLayer(this._lastZlevel, {
                        motionBlur: !1
                    }), h && v) {
                        g.configLayer(p, {
                            motionBlur: !0,
                            lastFrameAlpha: Math.max(Math.min(v / 10 + .9, 1), 0)
                        })
                    }
                    this.group.add(c.group),
                    c[yi](u),
                    this._lastZlevel = p
                },
                updateLayout: function(t, e, i) {
                    this._lineDraw[Qn](t);
                    var n = i.getZr();
                    n.painter.getLayer(this._lastZlevel).clear(!0)
                },
                remove: function(t, e) {
                    this._lineDraw && this._lineDraw[Xn](e, !0)
                }
            })
        }),
        e("echarts/chart/lines/LinesSeries", [Tr, le, Gi, Ar, ne],
        function(t) {
            function e(t) {
                var e = t.data;
                e && e[0] && e[0][0] && e[0][0].coord && (t.data = r.map(e,
                function(t) {
                    var e = [t[0].coord, t[1].coord],
                    i = {
                        coords: e
                    };
                    return t[0].name && (i.fromName = t[0].name),
                    t[1].name && (i.toName = t[1].name),
                    r.mergeAll([i, t[0], t[1]])
                }))
            }
            var i = t(le),
            n = t(Gi),
            r = t(Ar),
            a = (t(ne), i[jn]({
                type: "series.lines",
                dependencies: ["grid", "polar"],
                visualColorAccessPath: "lineStyle.normal.color",
                init: function(t) {
                    e(t),
                    a[Oi](this, "init", arguments)
                },
                mergeOption: function(t) {
                    e(t),
                    a[Oi](this, Vi, arguments)
                },
                getInitialData: function(t) {
                    var e = new n(["value"], this);
                    return e[fe] = !1,
                    e[Di](t.data, [],
                    function(t, i, n, r) {
                        if (t instanceof Array) return 0 / 0;
                        e[fe] = !0;
                        var a = t.value;
                        return a ? a instanceof Array ? a[r] : a: void 0
                    }),
                    e
                },
                formatTooltip: function(t) {
                    var e = this[Kn](),
                    i = e[hi](t),
                    n = i.get("name");
                    if (n) return n;
                    var r = i.get("fromName"),
                    a = i.get("toName");
                    return r + " > " + a
                },
                defaultOption: {
                    coordinateSystem: "geo",
                    zlevel: 0,
                    z: 2,
                    legendHoverLink: !0,
                    hoverAnimation: !0,
                    xAxisIndex: 0,
                    yAxisIndex: 0,
                    geoIndex: 0,
                    effect: {
                        show: !1,
                        period: 4,
                        constantSpeed: 0,
                        symbol: "circle",
                        symbolSize: 3,
                        loop: !0,
                        trailLength: .2
                    },
                    large: !1,
                    largeThreshold: 2e3,
                    polyline: !1,
                    label: {
                        normal: {
                            show: !1,
                            position: "end"
                        }
                    },
                    lineStyle: {
                        normal: {
                            opacity: .5
                        }
                    }
                }
            }))
        }),
        e("echarts/chart/lines/linesLayout", [Tr],
        function() {
            return function(t) {
                t[dn]("lines",
                function(t) {
                    var e = t[ln],
                    i = t[Kn]();
                    i.each(function(n) {
                        var r = i[hi](n),
                        a = r[zi] instanceof Array ? r[zi] : r.get("coords"),
                        o = [];
                        if (t.get("polyline")) for (var s = 0; s < a[Wn]; s++) o.push(e[ae](a[s]));
                        else {
                            o[0] = e[ae](a[0]),
                            o[1] = e[ae](a[1]);
                            var l = r.get("lineStyle.normal.curveness"); + l && (o[2] = [(o[0][0] + o[1][0]) / 2 - (o[0][1] - o[1][1]) * l, (o[0][1] + o[1][1]) / 2 - (o[1][0] - o[0][0]) * l])
                        }
                        i[He](n, o)
                    })
                })
            }
        }),
        e("echarts/chart/boxplot/BoxplotView", [Tr, Ar, "../../view/Chart", Si, "../helper/whiskerBoxCommon"],
        function(t) {
            function e(t, e, i) {
                var n = e[hi](i),
                a = n[fr](s),
                o = e[gi](i, "color"),
                u = a[sn]([N]),
                c = t[di](t.whiskerIndex);
                c.style.set(u),
                c.style[ye] = o,
                c.dirty();
                var h = t[di](t.bodyIndex);
                h.style.set(u),
                h.style[ye] = o,
                h.dirty();
                var d = n[fr](l)[sn]();
                r[ri](t, d)
            }
            var i = t(Ar),
            n = t("../../view/Chart"),
            r = t(Si),
            a = t("../helper/whiskerBoxCommon"),
            o = n[jn]({
                type: "boxplot",
                getStyleUpdater: function() {
                    return e
                }
            });
            i.mixin(o, a.viewMixin, !0);
            var s = [li, ki],
            l = [li, Li];
            return o
        }),
        e("echarts/chart/boxplot/BoxplotSeries", [Tr, Ar, le, "../helper/whiskerBoxCommon"],
        function(t) {
            var e = t(Ar),
            i = t(le),
            n = t("../helper/whiskerBoxCommon"),
            r = i[jn]({
                type: "series.boxplot",
                dependencies: ["xAxis", "yAxis", "grid"],
                valueDimensions: ["min", "Q1", "median", "Q3", "max"],
                dimensions: null,
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: "cartesian2d",
                    legendHoverLink: !0,
                    hoverAnimation: !0,
                    layout: null,
                    boxWidth: [7, 50],
                    itemStyle: {
                        normal: {
                            color: "#fff",
                            borderWidth: 1
                        },
                        emphasis: {
                            borderWidth: 2,
                            shadowBlur: 5,
                            shadowOffsetX: 2,
                            shadowOffsetY: 2,
                            shadowColor: "rgba(0,0,0,0.4)"
                        }
                    },
                    animationEasing: "elasticOut",
                    animationDuration: 800
                }
            });
            return e.mixin(r, n.seriesModelMixin, !0),
            r
        }),
        e("echarts/component/parallel", [Tr, "../coord/parallel/parallelCreator", "../coord/parallel/ParallelModel", "./parallelAxis", "../echarts", Ar, "../coord/parallel/parallelPreprocessor"],
        function(t) {
            t("../coord/parallel/parallelCreator"),
            t("../coord/parallel/ParallelModel"),
            t("./parallelAxis");
            var e = t("../echarts"),
            i = t(Ar),
            n = 5;
            e[_n]({
                type: "parallel",
                render: function(t, e, r) {
                    var a = r.getZr();
                    if (!this.__onMouseDown) {
                        var o;
                        a.on("mousedown", this.__onMouseDown = function(t) {
                            o = [t[w], t[_]]
                        }),
                        a.on("mouseup", this.__onMouseUp = function(e) {
                            var a = [e[w], e[_]],
                            s = Math.pow(o[0] - a[0], 2) + Math.pow(o[1] - a[1], 2);
                            if (t.get("axisExpandable") && !(s > n)) {
                                var l = t[ln],
                                u = l.findClosestAxisDim(a);
                                if (u) {
                                    var c = i[gn](l[de], u);
                                    r[Un]({
                                        type: "parallelAxisExpand",
                                        axisExpandCenter: c
                                    })
                                }
                            }
                        })
                    }
                },
                dispose: function(t, e) {
                    e.getZr().off(this.__onMouseDown),
                    e.getZr().off(this.__onMouseUp)
                }
            }),
            e.registerPreprocessor(t("../coord/parallel/parallelPreprocessor"))
        }),
        e("echarts/chart/boxplot/boxplotVisual", [Tr],
        function() {
            var t = [li, ki, N];
            return function(e) {
                var i = e.get("color");
                e.eachRawSeriesByType("boxplot",
                function(n) {
                    var r = i[n[Dn] % i[Wn]],
                    a = n[Kn]();
                    a[hn]({
                        legendSymbol: "roundRect",
                        color: n.get(t) || r
                    }),
                    e.isSeriesFiltered(n) || a.each(function(e) {
                        var i = a[hi](e);
                        a[Ue](e, {
                            color: i.get(t, !0)
                        })
                    })
                })
            }
        }),
        e("echarts/chart/boxplot/boxplotLayout", [Tr, Ar, qe],
        function(t) {
            function e(t) {
                var e = [],
                i = [];
                return t[dn]("boxplot",
                function(t) {
                    var n = t[Ie](),
                    a = r[gn](i, n);
                    0 > a && (a = i[Wn], i[a] = n, e[a] = {
                        axis: n,
                        seriesModels: []
                    }),
                    e[a].seriesModels.push(t)
                }),
                e
            }
            function i(t) {
                var e, i, n = t.axis,
                a = t.seriesModels,
                l = a[Wn],
                u = t.boxWidthList = [],
                c = t.boxOffsetList = [],
                h = [];
                if (n.type === te) i = n.getBandWidth();
                else {
                    var d = 0;
                    s(a,
                    function(t) {
                        d = Math.max(d, t[Kn]().count())
                    }),
                    e = n[Fi](),
                    Math.abs(e[1] - e[0]) / d
                }
                s(a,
                function(t) {
                    var e = t.get("boxWidth");
                    r[An](e) || (e = [e, e]),
                    h.push([o(e[0], i) || 0, o(e[1], i) || 0])
                });
                var f = .8 * i - 2,
                p = f / l * .3,
                v = (f - p * (l - 1)) / l,
                g = v / 2 - f / 2;
                s(a,
                function(t, e) {
                    c.push(g),
                    g += p + v,
                    u.push(Math.min(Math.max(v, h[e][0]), h[e][1]))
                })
            }
            function n(t, e, i) {
                var n = t[ln],
                r = t[Kn](),
                a = t[de],
                o = t.get(E),
                s = i / 2;
                r.each(a,
                function() {
                    function t(t) {
                        var i = [];
                        i[f] = h,
                        i[p] = t;
                        var r;
                        return isNaN(h) || isNaN(t) ? r = [0 / 0, 0 / 0] : (r = n[ae](i), r[f] += e),
                        r
                    }
                    function i(t, e) {
                        var i = t.slice(),
                        n = t.slice();
                        i[f] += s,
                        n[f] -= s,
                        e ? x.push(i, n) : x.push(n, i)
                    }
                    function l(t) {
                        var e = [t.slice(), t.slice()];
                        e[0][f] -= s,
                        e[1][f] += s,
                        y.push(e)
                    }
                    var u = arguments,
                    c = a[Wn],
                    h = u[0],
                    d = u[c],
                    f = o === O ? 0 : 1,
                    p = 1 - f,
                    v = t(u[3]),
                    g = t(u[1]),
                    m = t(u[5]),
                    y = [[g, t(u[2])], [m, t(u[4])]];
                    l(g),
                    l(m),
                    l(v);
                    var x = [];
                    i(y[0][1], 0),
                    i(y[1][1], 1),
                    r[He](d, {
                        chartLayout: o,
                        initBaseline: v[p],
                        median: v,
                        bodyEnds: x,
                        whiskerEnds: y
                    })
                })
            }
            var r = t(Ar),
            a = t(qe),
            o = a[We],
            s = r.each;
            return function(t) {
                var r = e(t);
                s(r,
                function(t) {
                    var e = t.seriesModels;
                    e[Wn] && (i(t), s(e,
                    function(e, i) {
                        n(e, t.boxOffsetList[i], t.boxWidthList[i])
                    }))
                })
            }
        }),
        e("echarts/chart/parallel/ParallelSeries", [Tr, Gi, Ar, le, Ni],
        function(t) {
            function e(t, e, n) {
                var r = t.get("data"),
                o = i(e);
                r && r[Wn] && a.each(n,
                function(t) {
                    if (t) {
                        var e = a[gn](r, t[o]);
                        t[o] = e >= 0 ? e: 0 / 0
                    }
                })
            }
            function i(t) {
                return + t[Tn]("dim", "")
            }
            function n(t, e) {
                var n = 0;
                a.each(t,
                function(t) {
                    var e = i(t);
                    e > n && (n = e)
                });
                var r = e[0];
                r && r[Wn] - 1 > n && (n = r[Wn] - 1);
                for (var o = [], s = 0; n >= s; s++) o.push("dim" + s);
                return o
            }
            var r = t(Gi),
            a = t(Ar),
            o = t(le),
            s = t(Ni);
            return o[jn]({
                type: "series.parallel",
                dependencies: ["parallel"],
                getInitialData: function(t, i) {
                    var o = i[Re]("parallel", this.get("parallelIndex")),
                    l = o.parallelAxisIndex,
                    u = t.data,
                    c = o[de],
                    h = n(c, u),
                    d = a.map(h,
                    function(t, n) {
                        var r = a[gn](c, t),
                        o = r >= 0 && i[Re]("parallelAxis", l[r]);
                        return o && o.get("type") === te ? (e(o, t, u), {
                            name: t,
                            type: "ordinal"
                        }) : 0 > r && s.guessOrdinal(u, n) ? {
                            name: t,
                            type: "ordinal"
                        }: t
                    }),
                    f = new r(d, this);
                    return f[Di](u),
                    this[zi].progressive && (this[zi][vr] = !1),
                    f
                },
                getRawIndicesByActiveState: function(t) {
                    var e = this[ln],
                    i = this[Kn](),
                    n = [];
                    return e.eachActiveState(i,
                    function(e, r) {
                        t === e && n.push(i[je](r))
                    }),
                    n
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: "parallel",
                    parallelIndex: 0,
                    label: {
                        normal: {
                            show: !1
                        },
                        emphasis: {
                            show: !1
                        }
                    },
                    inactiveOpacity: .05,
                    activeOpacity: 1,
                    lineStyle: {
                        normal: {
                            width: 1,
                            opacity: .45,
                            type: "solid"
                        }
                    },
                    progressive: !1,
                    smooth: !1,
                    animationEasing: "linear"
                }
            })
        }),
        e("echarts/chart/parallel/ParallelView", [Tr, Si, Ar, "../../view/Chart"],
        function(t) {
            function e(t, e, i) {
                var n = t.model,
                r = t[un](),
                a = new o.Rect({
                    shape: {
                        x: r.x,
                        y: r.y,
                        width: r.width,
                        height: r[nr]
                    }
                }),
                s = n.get(E) === O ? "width": nr;
                return a[ci](s, 0),
                o[Xe](a, {
                    shape: {
                        width: r.width,
                        height: r[nr]
                    }
                },
                e, i),
                a
            }
            function i(t, e, i, n) {
                for (var r = [], o = 0; o < i[Wn]; o++) {
                    var s = i[o],
                    l = t.get(s, e);
                    a(l, n[J](s).type) || r.push(n[ae](l, s))
                }
                return r
            }
            function n(t, e, n, r, a) {
                var s = i(t, n, r, a),
                l = new o[xi]({
                    shape: {
                        points: s
                    },
                    silent: !0,
                    z2: 10
                });
                e.add(l),
                t[$e](n, l)
            }
            function r(t, e) {
                var i = t[fi][fr]("lineStyle.normal"),
                n = i[ti]();
                t[Se](function(r, a) {
                    if (t[fe]) {
                        var o = t[hi](a),
                        l = o[fr]("lineStyle.normal", i);
                        n = l[ti]()
                    }
                    r[si](s[jn](n, {
                        fill: null,
                        stroke: t[gi](a, "color"),
                        opacity: t[gi](a, Yi)
                    })),
                    r.shape.smooth = e
                })
            }
            function a(t, e) {
                return e === te ? null == t: null == t || isNaN(t)
            }
            var o = t(Si),
            s = t(Ar),
            l = .3,
            u = t("../../view/Chart")[jn]({
                type: "parallel",
                init: function() {
                    this._dataGroup = new o.Group,
                    this.group.add(this._dataGroup),
                    this._data
                },
                render: function(t) {
                    this._renderForNormal(t)
                },
                _renderForNormal: function(t) {
                    function a(t) {
                        n(h, c, t, p, f, null, g)
                    }
                    function s(e, n) {
                        var r = d[Mi](n),
                        a = i(h, e, p, f);
                        h[$e](e, r),
                        o[ui](r, {
                            shape: {
                                points: a
                            }
                        },
                        t, e)
                    }
                    function u(t) {
                        var e = d[Mi](t);
                        c[Xn](e)
                    }
                    var c = this._dataGroup,
                    h = t[Kn](),
                    d = this._data,
                    f = t[ln],
                    p = f[de],
                    v = t[zi],
                    g = v.smooth ? l: null;
                    if (h.diff(d).add(a)[er](s)[Xn](u)[Qe](), r(h, g), !this._data) {
                        var m = e(f, t,
                        function() {
                            setTimeout(function() {
                                c.removeClipPath()
                            })
                        });
                        c.setClipPath(m)
                    }
                    this._data = h
                },
                remove: function() {
                    this._dataGroup && this._dataGroup[cn](),
                    this._data = null
                }
            });
            return u
        }),
        e("echarts/chart/parallel/parallelVisual", [Tr],
        function() {
            return function(t) {
                t[dn]("parallel",
                function(e) {
                    var i = e[fr](F),
                    n = e[fr]("lineStyle.normal"),
                    r = t.get("color"),
                    a = n.get("color") || i.get("color") || r[e[Dn] % r[Wn]],
                    o = e.get("inactiveOpacity"),
                    s = e.get("activeOpacity"),
                    l = e[fr]("lineStyle.normal")[ti](),
                    u = e[ln],
                    c = e[Kn](),
                    h = {
                        normal: l[Yi],
                        active: s,
                        inactive: o
                    };
                    u.eachActiveState(c,
                    function(t, e) {
                        c[Ue](e, Yi, h[t])
                    }),
                    c[hn]("color", a)
                })
            }
        }),
        e("echarts/chart/gauge/GaugeSeries", [Tr, Gi, le, Ar],
        function(t) {
            var e = t(Gi),
            i = t(le),
            n = t(Ar),
            r = i[jn]({
                type: "series.gauge",
                getInitialData: function(t) {
                    var i = new e(["value"], this),
                    r = t.data || [];
                    return n[An](r) || (r = [r]),
                    i[Di](r),
                    i
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    center: ["50%", "50%"],
                    legendHoverLink: !0,
                    radius: "75%",
                    startAngle: 225,
                    endAngle: -45,
                    clockwise: !0,
                    min: 0,
                    max: 100,
                    splitNumber: 10,
                    axisLine: {
                        show: !0,
                        lineStyle: {
                            color: [[.2, "#91c7ae"], [.8, "#63869e"], [1, "#c23531"]],
                            width: 30
                        }
                    },
                    splitLine: {
                        show: !0,
                        length: 30,
                        lineStyle: {
                            color: "#eee",
                            width: 2,
                            type: "solid"
                        }
                    },
                    axisTick: {
                        show: !0,
                        splitNumber: 5,
                        length: 8,
                        lineStyle: {
                            color: "#eee",
                            width: 1,
                            type: "solid"
                        }
                    },
                    axisLabel: {
                        show: !0,
                        distance: 5,
                        textStyle: {
                            color: "auto"
                        }
                    },
                    pointer: {
                        show: !0,
                        length: "80%",
                        width: 8
                    },
                    itemStyle: {
                        normal: {
                            color: "auto"
                        }
                    },
                    title: {
                        show: !0,
                        offsetCenter: [0, "-40%"],
                        textStyle: {
                            color: "#333",
                            fontSize: 15
                        }
                    },
                    detail: {
                        show: !0,
                        backgroundColor: "rgba(0,0,0,0)",
                        borderWidth: 0,
                        borderColor: "#ccc",
                        width: 100,
                        height: 40,
                        offsetCenter: [0, "40%"],
                        textStyle: {
                            color: "auto",
                            fontSize: 30
                        }
                    }
                }
            });
            return r
        }),
        e("echarts/chart/gauge/GaugeView", [Tr, "./PointerPath", Si, qe, "../../view/Chart"],
        function(t) {
            function e(t, e) {
                var i = t.get(Ji),
                n = e[dr](),
                r = e[hr](),
                a = Math.min(n, r),
                s = o(i[0], e[dr]()),
                l = o(i[1], e[hr]()),
                u = o(t.get(Ze), a / 2);
                return {
                    cx: s,
                    cy: l,
                    r: u
                }
            }
            function i(t, e) {
                return e && (typeof e === yr ? t = e[Tn]("{value}", t) : typeof e === Sn && (t = e(t))),
                t
            }
            var n = t("./PointerPath"),
            r = t(Si),
            a = t(qe),
            o = a[We],
            s = 2 * Math.PI,
            l = t("../../view/Chart")[jn]({
                type: "gauge",
                render: function(t, i, n) {
                    this.group[cn]();
                    var r = t.get("axisLine.lineStyle.color"),
                    a = e(t, n);
                    this._renderMain(t, i, n, r, a)
                },
                _renderMain: function(t, e, i, n, a) {
                    for (var o = this.group,
                    l = t[fr](x), u = l[fr](Ke), c = t.get(Ye), h = -t.get("startAngle") / 180 * Math.PI, d = -t.get("endAngle") / 180 * Math.PI, f = (d - h) % s, p = h, v = u.get("width"), g = 0; g < n[Wn]; g++) {
                        var m = Math.min(Math.max(n[g][0], 0), 1),
                        d = h + f * m,
                        y = new r[_i]({
                            shape: {
                                startAngle: p,
                                endAngle: d,
                                cx: a.cx,
                                cy: a.cy,
                                clockwise: c,
                                r0: a.r - v,
                                r: a.r
                            },
                            silent: !0
                        });
                        y[Ln]({
                            fill: n[g][1]
                        }),
                        y[Ln](u[ti](["color", "borderWidth", N])),
                        o.add(y),
                        p = d
                    }
                    var _ = function(t) {
                        if (0 >= t) return n[0][1];
                        for (var e = 0; e < n[Wn]; e++) if (n[e][0] >= t && (0 === e ? 0 : n[e - 1][0]) < t) return n[e][1];
                        return n[e - 1][1]
                    };
                    if (!c) {
                        var w = h;
                        h = d,
                        d = w
                    }
                    this._renderTicks(t, e, i, _, a, h, d, c),
                    this._renderPointer(t, e, i, _, a, h, d, c),
                    this._renderTitle(t, e, i, _, a),
                    this._renderDetail(t, e, i, _, a)
                },
                _renderTicks: function(t, e, n, s, l, u, c) {
                    for (var h = this.group,
                    d = l.cx,
                    f = l.cy,
                    p = l.r,
                    x = t.get("min"), _ = t.get("max"), w = t[fr](y), b = t[fr](m), M = t[fr](g), S = t.get("splitNumber"), A = b.get("splitNumber"), T = o(w.get(Wn), p), C = o(b.get(Wn), p), L = u, k = (c - u) / S, P = k / A, I = w[fr](Ke)[ti](), D = b[fr](Ke)[ti](), z = M[fr](on), V = 0; S >= V; V++) {
                        var R = Math.cos(L),
                        O = Math.sin(L);
                        if (w.get("show")) {
                            var E = new r.Line({
                                shape: {
                                    x1: R * p + d,
                                    y1: O * p + f,
                                    x2: R * (p - T) + d,
                                    y2: O * (p - T) + f
                                },
                                style: I,
                                silent: !0
                            });
                            "auto" === I[ye] && E[Ln]({
                                stroke: s(V / S)
                            }),
                            h.add(E)
                        }
                        if (M.get("show")) {
                            var N = i(a.round(V / S * (_ - x) + x), M.get(v)),
                            B = M.get(ge),
                            G = new r.Text({
                                style: {
                                    text: N,
                                    x: R * (p - T - B) + d,
                                    y: O * (p - T - B) + f,
                                    fill: z[nn](),
                                    textFont: z[rn](),
                                    textVerticalAlign: -.4 > O ? "top": O > .4 ? rr: Qi,
                                    textAlign: -.4 > R ? "left": R > .4 ? "right": Ji
                                },
                                silent: !0
                            });
                            "auto" === G.style.fill && G[Ln]({
                                fill: s(V / S)
                            }),
                            h.add(G)
                        }
                        if (b.get("show") && V !== S) {
                            for (var H = 0; A >= H; H++) {
                                var R = Math.cos(L),
                                O = Math.sin(L),
                                F = new r.Line({
                                    shape: {
                                        x1: R * p + d,
                                        y1: O * p + f,
                                        x2: R * (p - C) + d,
                                        y2: O * (p - C) + f
                                    },
                                    silent: !0,
                                    style: D
                                });
                                "auto" === D[ye] && F[Ln]({
                                    stroke: s((V + H / A) / S)
                                }),
                                h.add(F),
                                L += P
                            }
                            L -= P
                        } else L += k
                    }
                },
                _renderPointer: function(t, e, i, s, l, u, c, h) {
                    var d = [ + t.get("min"), +t.get("max")],
                    f = [u, c];
                    h || (f = f[S]());
                    var p = t[Kn](),
                    v = this._data,
                    g = this.group;
                    p.diff(v).add(function(e) {
                        var i = new n({
                            shape: {
                                angle: u
                            }
                        });
                        r[ui](i, {
                            shape: {
                                angle: a[Ge](p.get("value", e), d, f, !0)
                            }
                        },
                        t),
                        g.add(i),
                        p[$e](e, i)
                    })[er](function(e, i) {
                        var n = v[Mi](i);
                        r[ui](n, {
                            shape: {
                                angle: a[Ge](p.get("value", e), d, f, !0)
                            }
                        },
                        t),
                        g.add(n),
                        p[$e](e, n)
                    })[Xn](function(t) {
                        var e = v[Mi](t);
                        g[Xn](e)
                    })[Qe](),
                    p[Se](function(t, e) {
                        var i = p[hi](e),
                        n = i[fr]("pointer");
                        t[ci]({
                            x: l.cx,
                            y: l.cy,
                            width: o(n.get("width"), l.r),
                            r: o(n.get(Wn), l.r)
                        }),
                        t[si](i[fr](F)[sn]()),
                        "auto" === t.style.fill && t[Ln]("fill", s((p.get("value", e) - d[0]) / (d[1] - d[0]))),
                        r[ri](t, i[fr](H)[sn]())
                    }),
                    this._data = p
                },
                _renderTitle: function(t, e, i, n, a) {
                    var s = t[fr]("title");
                    if (s.get("show")) {
                        var l = s[fr](on),
                        u = s.get("offsetCenter"),
                        c = a.cx + o(u[0], a.r),
                        h = a.cy + o(u[1], a.r),
                        d = new r.Text({
                            style: {
                                x: c,
                                y: h,
                                text: t[Kn]()[Ci](0),
                                fill: l[nn](),
                                textFont: l[rn](),
                                textAlign: "center",
                                textVerticalAlign: "middle"
                            }
                        });
                        this.group.add(d)
                    }
                },
                _renderDetail: function(t, e, n, s, l) {
                    var u = t[fr]("detail"),
                    c = t.get("min"),
                    h = t.get("max");
                    if (u.get("show")) {
                        var d = u[fr](on),
                        f = u.get("offsetCenter"),
                        p = l.cx + o(f[0], l.r),
                        g = l.cy + o(f[1], l.r),
                        m = o(u.get("width"), l.r),
                        y = o(u.get(nr), l.r),
                        x = t[Kn]().get("value", 0),
                        _ = new r.Rect({
                            shape: {
                                x: p - m / 2,
                                y: g - y / 2,
                                width: m,
                                height: y
                            },
                            style: {
                                text: i(x, u.get(v)),
                                fill: u.get(ur),
                                textFill: d[nn](),
                                textFont: d[rn]()
                            }
                        });
                        "auto" === _.style.textFill && _[Ln]("textFill", s(a[Ge](x, [c, h], [0, 1], !0))),
                        _[Ln](u[sn](["color"])),
                        this.group.add(_)
                    }
                }
            });
            return l
        }),
        e("echarts/chart/funnel/FunnelSeries", [Tr, Gi, Bi, Ni, Ei],
        function(t) {
            var e = t(Gi),
            i = t(Bi),
            n = t(Ni),
            r = t(Ei).extendSeriesModel({
                type: "series.funnel",
                init: function(t) {
                    r[Oi](this, "init", arguments),
                    this.legendDataProvider = function() {
                        return this._dataBeforeProcessed
                    },
                    this._defaultLabelLine(t)
                },
                getInitialData: function(t) {
                    var i = n(["value"], t.data),
                    r = new e(i, this);
                    return r[Di](t.data),
                    r
                },
                _defaultLabelLine: function(t) {
                    i[Pi](t.labelLine, ["show"]);
                    var e = t.labelLine[ki],
                    n = t.labelLine[Li];
                    e.show = e.show && t.label[ki].show,
                    n.show = n.show && t.label[Li].show
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    legendHoverLink: !0,
                    left: 80,
                    top: 60,
                    right: 80,
                    bottom: 60,
                    minSize: "0%",
                    maxSize: "100%",
                    sort: "descending",
                    gap: 0,
                    funnelAlign: "center",
                    label: {
                        normal: {
                            show: !0,
                            position: "outer"
                        },
                        emphasis: {
                            show: !0
                        }
                    },
                    labelLine: {
                        normal: {
                            show: !0,
                            length: 20,
                            lineStyle: {
                                width: 1,
                                type: "solid"
                            }
                        },
                        emphasis: {}
                    },
                    itemStyle: {
                        normal: {
                            borderColor: "#fff",
                            borderWidth: 1
                        },
                        emphasis: {}
                    }
                }
            });
            return r
        }),
        e("echarts/chart/funnel/FunnelView", [Tr, Si, Ar, "../../view/Chart"],
        function(t) {
            function e(t, e) {
                function i() {
                    o[ar] = o.hoverIgnore,
                    s[ar] = s.hoverIgnore
                }
                function r() {
                    o[ar] = o.normalIgnore,
                    s[ar] = s.normalIgnore
                }
                n.Group.call(this);
                var a = new n[we],
                o = new n[xi],
                s = new n.Text;
                this.add(a),
                this.add(o),
                this.add(s),
                this[yi](t, e, !0),
                this.on(Li, i).on(ki, r).on(En, i).on(On, r)
            }
            function i(t, e, i, n) {
                var a = n[fr](on),
                o = n.get($i),
                s = o === mi || "inner" === o || o === Ji;
                return {
                    fill: a[nn]() || (s ? "#fff": t[gi](e, "color")),
                    textFont: a[rn](),
                    text: r[vi](t[fi][pi](e, i), t[Ci](e))
                }
            }
            var n = t(Si),
            r = t(Ar),
            a = e[xr],
            o = [li, ki, Yi];
            a[yi] = function(t, e, i) {
                var a = this[di](0),
                s = t[fi],
                l = t[hi](e),
                u = t[bi](e),
                c = t[hi](e).get(o);
                c = null == c ? 1 : c,
                a[si]({}),
                i ? (a[ci]({
                    points: u[z]
                }), a[Ln]({
                    opacity: 0
                }), n[Xe](a, {
                    style: {
                        opacity: c
                    }
                },
                s, e)) : n[ui](a, {
                    style: {
                        opacity: c
                    },
                    shape: {
                        points: u[z]
                    }
                },
                s, e);
                var h = l[fr](li),
                d = t[gi](e, "color");
                a[Ln](r[qn]({
                    lineJoin: "round",
                    fill: d
                },
                h[fr](ki)[sn]([Yi]))),
                a[oi] = h[fr](Li)[sn](),
                this._updateLabel(t, e),
                n[ri](this)
            },
            a._updateLabel = function(t, e) {
                var r = this[di](1),
                a = this[di](2),
                o = t[fi],
                s = t[hi](e),
                l = t[bi](e),
                u = l.label,
                c = t[gi](e, "color");
                n[ui](r, {
                    shape: {
                        points: u.linePoints || u.linePoints
                    }
                },
                o, e),
                n[ui](a, {
                    style: {
                        x: u.x,
                        y: u.y
                    }
                },
                o, e),
                a.attr({
                    style: {
                        textAlign: u[an],
                        textVerticalAlign: u.verticalAlign,
                        textFont: u.font
                    },
                    rotation: u[ni],
                    origin: [u.x, u.y],
                    z2: 10
                });
                var h = s[fr](ii),
                d = s[fr](ei),
                f = s[fr]("labelLine.normal"),
                p = s[fr]("labelLine.emphasis");
                a[Ln](i(t, e, ki, h)),
                a[ar] = a.normalIgnore = !h.get("show"),
                a.hoverIgnore = !d.get("show"),
                r[ar] = r.normalIgnore = !f.get("show"),
                r.hoverIgnore = !p.get("show"),
                r[Ln]({
                    stroke: c
                }),
                r[Ln](f[fr](Ke)[ti]()),
                a[oi] = i(t, e, Li, d),
                r[oi] = p[fr](Ke)[ti]()
            },
            r[vn](e, n.Group);
            var s = t("../../view/Chart")[jn]({
                type: "funnel",
                render: function(t) {
                    var i = t[Kn](),
                    n = this._data,
                    r = this.group;
                    i.diff(n).add(function(t) {
                        var n = new e(i, t);
                        i[$e](t, n),
                        r.add(n)
                    })[er](function(t, e) {
                        var a = n[Mi](e);
                        a[yi](i, t),
                        r.add(a),
                        i[$e](t, a)
                    })[Xn](function(t) {
                        var e = n[Mi](t);
                        r[Xn](e)
                    })[Qe](),
                    this._data = i
                },
                remove: function() {
                    this.group[cn](),
                    this._data = null
                }
            });
            return s
        }),
        e("echarts/chart/funnel/funnelLayout", [Tr, re, qe],
        function(t) {
            function e(t, e) {
                return r[Ki](t[tn](), {
                    width: e[dr](),
                    height: e[hr]()
                })
            }
            function i(t, e) {
                for (var i = t[he]("value",
                function(t) {
                    return t
                }), n = [], r = "ascending" === e, a = 0, o = t.count(); o > a; a++) n[a] = a;
                return n.sort(function(t, e) {
                    return r ? i[t] - i[e] : i[e] - i[t]
                }),
                n
            }
            function n(t) {
                t.each(function(e) {
                    var i, n, r, a, o = t[hi](e),
                    s = o[fr](ii),
                    l = s.get($i),
                    u = o[fr]("labelLine.normal"),
                    c = t[bi](e),
                    h = c[z],
                    d = "inner" === l || l === mi || l === Ji;
                    if (d) n = (h[0][0] + h[1][0] + h[2][0] + h[3][0]) / 4,
                    r = (h[0][1] + h[1][1] + h[2][1] + h[3][1]) / 4,
                    i = Ji,
                    a = [[n, r], [n, r]];
                    else {
                        var f, p, v, g = u.get(Wn);
                        "left" === l ? (f = (h[3][0] + h[0][0]) / 2, p = (h[3][1] + h[0][1]) / 2, v = f - g, n = v - 5, i = "right") : (f = (h[1][0] + h[2][0]) / 2, p = (h[1][1] + h[2][1]) / 2, v = f + g, n = v + 5, i = "left");
                        var m = p;
                        a = [[f, p], [v, m]],
                        r = m
                    }
                    c.label = {
                        linePoints: a,
                        x: n,
                        y: r,
                        verticalAlign: "middle",
                        textAlign: i,
                        inside: d
                    }
                })
            }
            var r = t(re),
            a = t(qe),
            o = a[We];
            return function(t, r) {
                t[dn]("funnel",
                function(t) {
                    var s = t[Kn](),
                    l = t.get("sort"),
                    u = e(t, r),
                    c = i(s, l),
                    h = [o(t.get("minSize"), u.width), o(t.get("maxSize"), u.width)],
                    d = s[Fe]("value"),
                    f = t.get("min"),
                    p = t.get("max");
                    null == f && (f = Math.min(d[0], 0)),
                    null == p && (p = d[1]);
                    var v = t.get("funnelAlign"),
                    g = t.get("gap"),
                    m = (u[nr] - g * (s.count() - 1)) / s.count(),
                    y = u.y,
                    x = function(t, e) {
                        var i, n = s.get("value", t) || 0,
                        r = a[Ge](n, [f, p], h, !0);
                        switch (v) {
                        case "left":
                            i = u.x;
                            break;
                        case Ji:
                            i = u.x + (u.width - r) / 2;
                            break;
                        case "right":
                            i = u.x + u.width - r
                        }
                        return [[i, e], [i + r, e]]
                    };
                    "ascending" === l && (m = -m, g = -g, y += u[nr], c = c[S]());
                    for (var _ = 0; _ < c[Wn]; _++) {
                        var w = c[_],
                        b = c[_ + 1],
                        M = x(w, y),
                        A = x(b, y + m);
                        y += m + g,
                        s[He](w, {
                            points: M[Ai](A.slice()[S]())
                        })
                    }
                    n(s)
                })
            }
        }),
        e("echarts/chart/sankey/SankeySeries", [Tr, le, "../helper/createGraphFromNodeEdge"],
        function(t) {
            var e = t(le),
            i = t("../helper/createGraphFromNodeEdge"),
            n = e[jn]({
                type: "series.sankey",
                layoutInfo: null,
                getInitialData: function(t) {
                    var e = t.edges || t.links,
                    n = t.data || t.nodes;
                    if (n && e) {
                        var r = i(n, e, this, !0);
                        return r.data
                    }
                },
                getGraph: function() {
                    return this[Kn]().graph
                },
                getEdgeData: function() {
                    return this.getGraph().edgeData
                },
                formatTooltip: function(t, e, i) {
                    if ("edge" === i) {
                        var r = this[In](t, i),
                        a = r.data,
                        o = a.source + " -- " + a[Vn];
                        return r.value && (o += " : " + r.value),
                        o
                    }
                    return n[Ri](this, "formatTooltip", t, e)
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: "view",
                    layout: null,
                    left: "5%",
                    top: "5%",
                    right: "20%",
                    bottom: "5%",
                    nodeWidth: 20,
                    nodeGap: 8,
                    layoutIterations: 32,
                    label: {
                        normal: {
                            show: !0,
                            position: "right",
                            textStyle: {
                                color: "#000",
                                fontSize: 12
                            }
                        },
                        emphasis: {
                            show: !0
                        }
                    },
                    itemStyle: {
                        normal: {
                            borderWidth: 1,
                            borderColor: "#333"
                        }
                    },
                    lineStyle: {
                        normal: {
                            color: "#314656",
                            opacity: .2,
                            curveness: .5
                        },
                        emphasis: {
                            opacity: .6
                        }
                    },
                    animationEasing: "linear",
                    animationDuration: 1e3
                }
            });
            return n
        }),
        e("echarts/chart/sankey/SankeyView", [Tr, Si, Ar, Ei],
        function(t) {
            function e(t, e, n) {
                var r = new i.Rect({
                    shape: {
                        x: t.x - 10,
                        y: t.y - 10,
                        width: 0,
                        height: t[nr] + 20
                    }
                });
                return i[Xe](r, {
                    shape: {
                        width: t.width + 20,
                        height: t[nr] + 20
                    }
                },
                e, n),
                r
            }
            var i = t(Si),
            n = t(Ar),
            r = i.extendShape({
                shape: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                    cpx1: 0,
                    cpy1: 0,
                    cpx2: 0,
                    cpy2: 0,
                    extent: 0
                },
                buildPath: function(t, e) {
                    var i = e.extent / 2;
                    t[p](e.x1, e.y1 - i),
                    t[f](e.cpx1, e.cpy1 - i, e.cpx2, e.cpy2 - i, e.x2, e.y2 - i),
                    t[d](e.x2, e.y2 + i),
                    t[f](e.cpx2, e.cpy2 + i, e.cpx1, e.cpy1 + i, e.x1, e.y1 + i),
                    t[h]()
                }
            });
            return t(Ei)[xn]({
                type: "sankey",
                _model: null,
                render: function(t) {
                    var a = t.getGraph(),
                    o = this.group,
                    s = t.layoutInfo,
                    l = t[Kn](),
                    u = t[Kn]("edge");
                    this[pr] = t,
                    o[cn](),
                    o[$i] = [s.x, s.y],
                    a.eachEdge(function(e) {
                        var n = new r;
                        n[zn] = e[zn],
                        n[Dn] = t[Dn],
                        n[Pn] = "edge";
                        var a = e[fr]("lineStyle.normal"),
                        s = a.get("curveness"),
                        l = e.node1.getLayout(),
                        c = e.node2.getLayout(),
                        h = e.getLayout();
                        n.shape.extent = Math.max(1, h.dy);
                        var d = l.x + l.dx,
                        f = l.y + h.sy + h.dy / 2,
                        p = c.x,
                        v = c.y + h.ty + h.dy / 2,
                        g = d * (1 - s) + p * s,
                        m = f,
                        y = d * s + p * (1 - s),
                        x = v;
                        switch (n[ci]({
                            x1: d,
                            y1: f,
                            x2: p,
                            y2: v,
                            cpx1: g,
                            cpy1: m,
                            cpx2: y,
                            cpy2: x
                        }), n[Ln](a[sn]()), n.style.fill) {
                        case "source":
                            n.style.fill = e.node1[ce]("color");
                            break;
                        case Vn:
                            n.style.fill = e.node2[ce]("color")
                        }
                        i[ri](n, e[fr]("lineStyle.emphasis")[sn]()),
                        o.add(n),
                        u[$e](e[zn], n)
                    }),
                    a[C](function(e) {
                        var r = e.getLayout(),
                        a = e[fr](),
                        s = a[fr](ii),
                        u = s[fr](on),
                        c = a[fr](ei),
                        h = c[fr](on),
                        d = new i.Rect({
                            shape: {
                                x: r.x,
                                y: r.y,
                                width: e.getLayout().dx,
                                height: e.getLayout().dy
                            },
                            style: {
                                text: s.get("show") ? t[pi](e[zn], ki) || e.id: "",
                                textFont: u[rn](),
                                textFill: u[nn](),
                                textPosition: s.get($i)
                            }
                        });
                        d[Ln](n[qn]({
                            fill: e[ce]("color")
                        },
                        a[fr](F)[sn]())),
                        i[ri](d, n[jn](e[fr](H), {
                            text: c.get("show") ? t[pi](e[zn], Li) || e.id: "",
                            textFont: h[rn](),
                            textFill: h[nn](),
                            textPosition: c.get($i)
                        })),
                        o.add(d),
                        l[$e](e[zn], d),
                        d[Pn] = "node"
                    }),
                    !this._data && t.get(vr) && o.setClipPath(e(o[en](), t,
                    function() {
                        o.removeClipPath()
                    })),
                    this._data = t[Kn]()
                }
            })
        }),
        e("echarts/chart/sankey/sankeyLayout", [Tr, re, "../../util/array/nest", Ar],
        function(t) {
            function e(t, e) {
                return b[Ki](t[tn](), {
                    width: e[dr](),
                    height: e[hr]()
                })
            }
            function i(t, e, i, n, a, o, l) {
                r(t, i, a),
                s(t, e, o, n, l),
                p(t)
            }
            function n(t) {
                A.each(t,
                function(t) {
                    var e = m(t.outEdges, w),
                    i = m(t.inEdges, w),
                    n = Math.max(e, i);
                    t[ue]({
                        value: n
                    },
                    !0)
                })
            }
            function r(t, e, i) {
                for (var n = t,
                r = null,
                s = 0,
                l = 0; n[Wn];) {
                    r = [];
                    for (var u = 0,
                    c = n[Wn]; c > u; u++) {
                        var h = n[u];
                        h[ue]({
                            x: s
                        },
                        !0),
                        h[ue]({
                            dx: e
                        },
                        !0);
                        for (var d = 0,
                        f = h.outEdges[Wn]; f > d; d++) r.push(h.outEdges[d].node2)
                    }
                    n = r,
                    ++s
                }
                a(t, s),
                l = (i - e) / (s - 1),
                o(t, l)
            }
            function a(t, e) {
                A.each(t,
                function(t) {
                    t.outEdges[Wn] || t[ue]({
                        x: e - 1
                    },
                    !0)
                })
            }
            function o(t, e) {
                A.each(t,
                function(t) {
                    var i = t.getLayout().x * e;
                    t[ue]({
                        x: i
                    },
                    !0)
                })
            }
            function s(t, e, i, n, r) {
                var a = M().key(function(t) {
                    return t.getLayout().x
                }).sortKeys(_).entries(t).map(function(t) {
                    return t.values
                });
                l(t, a, e, i, n),
                u(a, n, i);
                for (var o = 1; r > 0; r--) o *= .99,
                c(a, o),
                u(a, n, i),
                d(a, o),
                u(a, n, i)
            }
            function l(t, e, i, n, r) {
                var a = [];
                A.each(e,
                function(t) {
                    var e = t[Wn],
                    i = 0;
                    A.each(t,
                    function(t) {
                        i += t.getLayout().value
                    });
                    var o = (n - (e - 1) * r) / i;
                    a.push(o)
                }),
                a.sort(function(t, e) {
                    return t - e
                });
                var o = a[0];
                A.each(e,
                function(t) {
                    A.each(t,
                    function(t, e) {
                        t[ue]({
                            y: e
                        },
                        !0);
                        var i = t.getLayout().value * o;
                        t[ue]({
                            dy: i
                        },
                        !0)
                    })
                }),
                A.each(i,
                function(t) {
                    var e = +t.getValue() * o;
                    t[ue]({
                        dy: e
                    },
                    !0)
                })
            }
            function u(t, e, i) {
                A.each(t,
                function(t) {
                    var n, r, a, o = 0,
                    s = t[Wn];
                    for (t.sort(x), a = 0; s > a; a++) {
                        if (n = t[a], r = o - n.getLayout().y, r > 0) {
                            var l = n.getLayout().y + r;
                            n[ue]({
                                y: l
                            },
                            !0)
                        }
                        o = n.getLayout().y + n.getLayout().dy + e
                    }
                    if (r = o - e - i, r > 0) {
                        var l = n.getLayout().y - r;
                        for (n[ue]({
                            y: l
                        },
                        !0), o = n.getLayout().y, a = s - 2; a >= 0; --a) n = t[a],
                        r = n.getLayout().y + n.getLayout().dy + e - o,
                        r > 0 && (l = n.getLayout().y - r, n[ue]({
                            y: l
                        },
                        !0)),
                        o = n.getLayout().y
                    }
                })
            }
            function c(t, e) {
                A.each(t.slice()[S](),
                function(t) {
                    A.each(t,
                    function(t) {
                        if (t.outEdges[Wn]) {
                            var i = m(t.outEdges, h) / m(t.outEdges, w),
                            n = t.getLayout().y + (i - y(t)) * e;
                            t[ue]({
                                y: n
                            },
                            !0)
                        }
                    })
                })
            }
            function h(t) {
                return y(t.node2) * t.getValue()
            }
            function d(t, e) {
                A.each(t,
                function(t) {
                    A.each(t,
                    function(t) {
                        if (t.inEdges[Wn]) {
                            var i = m(t.inEdges, f) / m(t.inEdges, w),
                            n = t.getLayout().y + (i - y(t)) * e;
                            t[ue]({
                                y: n
                            },
                            !0)
                        }
                    })
                })
            }
            function f(t) {
                return y(t.node1) * t.getValue()
            }
            function p(t) {
                A.each(t,
                function(t) {
                    t.outEdges.sort(v),
                    t.inEdges.sort(g)
                }),
                A.each(t,
                function(t) {
                    var e = 0,
                    i = 0;
                    A.each(t.outEdges,
                    function(t) {
                        t[ue]({
                            sy: e
                        },
                        !0),
                        e += t.getLayout().dy
                    }),
                    A.each(t.inEdges,
                    function(t) {
                        t[ue]({
                            ty: i
                        },
                        !0),
                        i += t.getLayout().dy
                    })
                })
            }
            function v(t, e) {
                return t.node2.getLayout().y - e.node2.getLayout().y
            }
            function g(t, e) {
                return t.node1.getLayout().y - e.node1.getLayout().y
            }
            function m(t, e) {
                for (var i = 0,
                n = t[Wn], r = -1; ++r < n;) {
                    var a = +e.call(t, t[r], r);
                    isNaN(a) || (i += a)
                }
                return i
            }
            function y(t) {
                return t.getLayout().y + t.getLayout().dy / 2
            }
            function x(t, e) {
                return t.getLayout().y - e.getLayout().y
            }
            function _(t, e) {
                return e > t ? -1 : t > e ? 1 : t === e ? 0 : 0 / 0
            }
            function w(t) {
                return t.getValue()
            }
            var b = t(re),
            M = t("../../util/array/nest"),
            A = t(Ar);
            return function(t, r) {
                t[dn]("sankey",
                function(t) {
                    var a = t.get("nodeWidth"),
                    o = t.get("nodeGap"),
                    s = e(t, r);
                    t.layoutInfo = s;
                    var l = s.width,
                    u = s[nr],
                    c = t.getGraph(),
                    h = c.nodes,
                    d = c.edges;
                    n(h);
                    var f = h[mn](function(t) {
                        return 0 === t.getLayout().value
                    }),
                    p = 0 !== f[Wn] ? 0 : t.get("layoutIterations");
                    i(h, d, a, o, l, u, p)
                })
            }
        }),
        e("echarts/chart/effectScatter/EffectScatterSeries", [Tr, "../helper/createListFromArray", le],
        function(t) {
            var e = t("../helper/createListFromArray"),
            i = t(le);
            return i[jn]({
                type: "series.effectScatter",
                dependencies: ["grid", "polar"],
                getInitialData: function(t, i) {
                    var n = e(t.data, this, i);
                    return n
                },
                brushSelector: "point",
                defaultOption: {
                    coordinateSystem: "cartesian2d",
                    zlevel: 0,
                    z: 2,
                    legendHoverLink: !0,
                    effectType: "ripple",
                    showEffectOn: "render",
                    rippleEffect: {
                        period: 4,
                        scale: 2.5,
                        brushType: "fill"
                    },
                    symbolSize: 10
                }
            })
        }),
        e("echarts/chart/sankey/sankeyVisual", [Tr, "../../visual/VisualMapping"],
        function(t) {
            var e = t("../../visual/VisualMapping");
            return function(t) {
                t[dn]("sankey",
                function(t) {
                    var i = t.getGraph(),
                    n = i.nodes;
                    n.sort(function(t, e) {
                        return t.getLayout().value - e.getLayout().value
                    });
                    var r = n[0].getLayout().value,
                    a = n[n[Wn] - 1].getLayout().value;
                    n.forEach(function(i) {
                        var n = new e({
                            type: "color",
                            mappingMethod: "linear",
                            dataExtent: [r, a],
                            visual: t.get("color")
                        }),
                        o = n.mapValueToVisual(i.getLayout().value);
                        i[hn]("color", o);
                        var s = i[fr](),
                        l = s.get("itemStyle.normal.color");
                        null != l && i[hn]("color", l)
                    })
                })
            }
        }),
        e("echarts/chart/effectScatter/EffectScatterView", [Tr, "../helper/SymbolDraw", "../helper/EffectSymbol", Ei],
        function(t) {
            var e = t("../helper/SymbolDraw"),
            i = t("../helper/EffectSymbol");
            t(Ei)[xn]({
                type: "effectScatter",
                init: function() {
                    this._symbolDraw = new e(i)
                },
                render: function(t) {
                    var e = t[Kn](),
                    i = this._symbolDraw;
                    i[yi](e),
                    this.group.add(i.group)
                },
                updateLayout: function() {
                    this._symbolDraw[Qn]()
                },
                remove: function(t, e) {
                    this._symbolDraw && this._symbolDraw[Xn](e)
                }
            })
        }),
        e("echarts/coord/polar/polarCreator", [Tr, "./Polar", qe, Ar, "../../coord/axisHelper", "./PolarModel", ne],
        function(t) {
            function e(t, e) {
                var i = t.get(Ji),
                n = t.get(Ze),
                r = e[dr](),
                o = e[hr](),
                s = a[We];
                this.cx = s(i[0], r),
                this.cy = s(i[1], o);
                var l = this.getRadiusAxis(),
                u = Math.min(r, o) / 2;
                l[Zi](0, s(n, u))
            }
            function i(t) {
                var e = this,
                i = e.getAngleAxis(),
                n = e.getRadiusAxis();
                if (i.scale[Zi](1 / 0, -1 / 0), n.scale[Zi](1 / 0, -1 / 0), t[tr](function(t) {
                    if (t[ln] === e) {
                        var r = t[Kn]();
                        n.scale[Hi](r[Fe](Ze, n.type !== te)),
                        i.scale[Hi](r[Fe]("angle", i.type !== te))
                    }
                }), s(i, i.model), s(n, n.model), i.type === te && !i[Y]) {
                    var r = i[Fi](),
                    a = 360 / i.scale.count();
                    i[Q] ? r[1] += a: r[1] -= a,
                    i[Zi](r[0], r[1])
                }
            }
            function n(t, e) {
                if (t.type = e.get("type"), t.scale = o[$](e), t[Y] = e.get(X) && t.type === te, "angleAxis" === e[Ne]) {
                    var i = e.get("startAngle");
                    t[Q] = e.get(Q) ^ e.get(Ye),
                    t[Zi](i, i + (t[Q] ? -360 : 360))
                }
                e.axis = t,
                t.model = e
            }
            var r = t("./Polar"),
            a = t(qe),
            o = (t(Ar), t("../../coord/axisHelper")),
            s = o[ie];
            t("./PolarModel");
            var l = {
                dimensions: r[xr][de],
                create: function(t, a) {
                    var o = [];
                    return t[or]("polar",
                    function(t, s) {
                        var l = new r(s);
                        l[gr] = e,
                        l[er] = i;
                        var u = l.getRadiusAxis(),
                        c = l.getAngleAxis(),
                        h = t.findAxisModel("radiusAxis"),
                        d = t.findAxisModel("angleAxis");
                        n(u, h),
                        n(c, d),
                        l[gr](t, a),
                        o.push(l),
                        t[ln] = l
                    }),
                    t[tr](function(e) {
                        if ("polar" === e.get(ln)) {
                            var i = t[Ee]({
                                mainType: "polar",
                                index: e.get(D),
                                id: e.get("polarId")
                            })[0];
                            e[ln] = i[ln]
                        }
                    }),
                    o
                }
            };
            t(ne)[bn]("polar", l)
        }),
        e("echarts/component/axis", [Tr, "../coord/cartesian/AxisModel", "./axis/AxisView"],
        function(t) {
            t("../coord/cartesian/AxisModel"),
            t("./axis/AxisView")
        }),
        e("echarts/component/radiusAxis", [Tr, "../coord/polar/polarCreator", "./axis/RadiusAxisView"],
        function(t) {
            t("../coord/polar/polarCreator"),
            t("./axis/RadiusAxisView")
        }),
        e("echarts/coord/geo/GeoModel", [Tr, Bi, c, W, Ar, "../../component/helper/selectableMixin", "./geoCreator"],
        function(t) {
            var e = t(Bi),
            i = t(c),
            n = t(W),
            r = t(Ar),
            a = t("../../component/helper/selectableMixin"),
            o = t("./geoCreator"),
            s = i[jn]({
                type: "geo",
                coordinateSystem: null,
                layoutMode: "box",
                init: function(t) {
                    i[xr].init.apply(this, arguments),
                    e[Pi](t.label, [$i, "show", on, ge, v])
                },
                optionUpdated: function() {
                    var t = this[zi],
                    e = this;
                    t.regions = o.getFilledRegions(t.regions, t.map),
                    this._optionModelMap = r.reduce(t.regions || [],
                    function(t, i) {
                        return i.name && (t[i.name] = new n(i, e)),
                        t
                    },
                    {}),
                    this.updateSelectedMap(t.regions)
                },
                defaultOption: {
                    zlevel: 0,
                    z: 0,
                    show: !0,
                    left: "center",
                    top: "center",
                    aspectScale: .75,
                    silent: !1,
                    map: "",
                    center: null,
                    zoom: 1,
                    scaleLimit: null,
                    label: {
                        normal: {
                            show: !1,
                            textStyle: {
                                color: "#000"
                            }
                        },
                        emphasis: {
                            show: !0,
                            textStyle: {
                                color: "rgb(100,0,0)"
                            }
                        }
                    },
                    itemStyle: {
                        normal: {
                            borderWidth: .5,
                            borderColor: "#444",
                            color: "#eee"
                        },
                        emphasis: {
                            color: "rgba(255,215,0,0.8)"
                        }
                    },
                    regions: []
                },
                getRegionModel: function(t) {
                    return this._optionModelMap[t]
                },
                getFormattedLabel: function(t, e) {
                    var i = this.get("label." + e + ".formatter"),
                    n = {
                        name: t
                    };
                    return typeof i === Sn ? (n.status = e, i(n)) : typeof i === yr ? i[Tn]("{a}", n.seriesName) : void 0
                },
                setZoom: function(t) {
                    this[zi].zoom = t
                },
                setCenter: function(t) {
                    this[zi][Ji] = t
                }
            });
            return r.mixin(s, a),
            s
        }),
        e("echarts/component/angleAxis", [Tr, "../coord/polar/polarCreator", "./axis/AngleAxisView"],
        function(t) {
            t("../coord/polar/polarCreator"),
            t("./axis/AngleAxisView")
        }),
        e("echarts/component/geo/GeoView", [Tr, "../helper/MapDraw", Ei],
        function(t) {
            var e = t("../helper/MapDraw");
            return t(Ei)[_n]({
                type: "geo",
                init: function(t, i) {
                    var n = new e(i, !0);
                    this._mapDraw = n,
                    this.group.add(n.group)
                },
                render: function(t, e, i, n) {
                    if (!n || "geoToggleSelect" !== n.type || n.from !== this.uid) {
                        var r = this._mapDraw;
                        t.get("show") ? r.draw(t, e, i, this, n) : this._mapDraw.group[cn](),
                        this.group[Nn] = t.get(Nn)
                    }
                }
            })
        }),
        e("echarts/coord/single/singleCreator", [Tr, "./Single", ne],
        function(t) {
            function e(t, e) {
                var n = [];
                return t[or]("singleAxis",
                function(r, a) {
                    var o = new i(r, t, e);
                    o.name = "single_" + a,
                    o[gr](r, e),
                    r[ln] = o,
                    n.push(o)
                }),
                t[tr](function(e) {
                    if ("singleAxis" === e.get(ln)) {
                        var i = t[Ee]({
                            mainType: "singleAxis",
                            index: e.get("singleAxisIndex"),
                            id: e.get("singleAxisId")
                        })[0];
                        e[ln] = i[ln]
                    }
                }),
                n
            }
            var i = t("./Single");
            t(ne)[bn]("single", {
                create: e,
                dimensions: i[xr][de]
            })
        }),
        e("echarts/coord/single/AxisModel", [Tr, c, "../axisModelCreator", Ar, "../axisModelCommonMixin"],
        function(t) {
            function e(t, e) {
                return e.type || (e.data ? te: "value")
            }
            var i = t(c),
            n = t("../axisModelCreator"),
            r = t(Ar),
            a = i[jn]({
                type: "singleAxis",
                layoutMode: "box",
                axis: null,
                coordinateSystem: null
            }),
            o = {
                left: "5%",
                top: "5%",
                right: "5%",
                bottom: "5%",
                type: "value",
                position: "bottom",
                orient: "horizontal",
                axisLine: {
                    show: !0,
                    lineStyle: {
                        width: 2,
                        type: "solid"
                    }
                },
                axisTick: {
                    show: !0,
                    length: 6,
                    lineStyle: {
                        width: 2
                    }
                },
                axisLabel: {
                    show: !0,
                    interval: "auto"
                },
                splitLine: {
                    show: !0,
                    lineStyle: {
                        type: "dashed",
                        opacity: .2
                    }
                }
            };
            return r.merge(a[xr], t("../axisModelCommonMixin")),
            n("single", a, e, o),
            a
        }),
        e("echarts/component/axis/SingleAxisView", [Tr, "./AxisBuilder", Ar, Si, Ei],
        function(t) {
            function e(t) {
                var e = t[ln],
                i = t.axis,
                n = {},
                r = i[$i],
                a = i[l],
                u = e[un](),
                c = [u.x, u.x + u.width, u.y, u.y + u[nr]],
                h = {
                    horizontal: {
                        top: c[2],
                        bottom: c[3]
                    },
                    vertical: {
                        left: c[0],
                        right: c[1]
                    }
                };
                n[$i] = [a === s ? h[s][r] : c[0], a === O ? h[O][r] : c[3]];
                var d = {
                    horizontal: 0,
                    vertical: 1
                };
                n[ni] = Math.PI / 2 * d[a];
                var f = {
                    top: -1,
                    bottom: 1,
                    right: 1,
                    left: -1
                };
                n.labelDirection = n.tickDirection = n.nameDirection = f[r],
                t[fr](m).get(mi) && (n.tickDirection = -n.tickDirection),
                t[fr](g).get(mi) && (n.labelDirection = -n.labelDirection);
                var p = t[fr](g).get(o);
                return n.labelRotation = "top" === r ? -p: p,
                n.labelInterval = i.getLabelInterval(),
                n.z2 = 1,
                n
            }
            var i = t("./AxisBuilder"),
            n = t(Ar),
            r = t(Si),
            a = i.getInterval,
            c = i.ifIgnoreOnTick,
            h = [x, g, m, u],
            d = y,
            f = t(Ei)[_n]({
                type: "singleAxis",
                render: function(t) {
                    var r = this.group;
                    r[cn]();
                    var a = e(t),
                    o = new i(t, a);
                    n.each(h, o.add, o),
                    r.add(o.getGroup()),
                    t.get(d + ".show") && this["_" + d](t, a.labelInterval)
                },
                _splitLine: function(t, e) {
                    var i = t.axis,
                    n = t[fr](y),
                    o = n[fr](Ke),
                    s = o.get("width"),
                    l = o.get("color"),
                    u = a(n, e);
                    l = l instanceof Array ? l: [l];
                    for (var h = t[ln][un](), d = i[K](), f = [], p = 0, v = i.getTicksCoords(), g = [], m = [], x = 0; x < v[Wn]; ++x) if (!c(i, x, u)) {
                        var _ = i[U](v[x]);
                        d ? (g[0] = _, g[1] = h.y, m[0] = _, m[1] = h.y + h[nr]) : (g[0] = h.x, g[1] = _, m[0] = h.x + h.width, m[1] = _);
                        var w = p++%l[Wn];
                        f[w] = f[w] || [],
                        f[w].push(new r.Line(r.subPixelOptimizeLine({
                            shape: {
                                x1: g[0],
                                y1: g[1],
                                x2: m[0],
                                y2: m[1]
                            },
                            style: {
                                lineWidth: s
                            },
                            silent: !0
                        })))
                    }
                    for (var x = 0; x < f[Wn]; ++x) this.group.add(r.mergePath(f[x], {
                        style: {
                            stroke: l[x % l[Wn]],
                            lineDash: o.getLineDash(),
                            lineWidth: s
                        },
                        silent: !0
                    }))
                }
            });
            return f
        }),
        e("echarts/component/legend/legendAction", [Tr, Ei, Ar],
        function(t) {
            function e(t, e, i) {
                var r, a = {},
                o = "toggleSelected" === t;
                return i[or]("legend",
                function(i) {
                    o && null != r ? i[r ? "select": "unSelect"](e.name) : (i[t](e.name), r = i.isSelected(e.name));
                    var s = i[Kn]();
                    n.each(s,
                    function(t) {
                        var e = t.get("name");
                        if ("\n" !== e && "" !== e) {
                            var n = i.isSelected(e);
                            a[e] = e in a ? a[e] && n: n
                        }
                    })
                }),
                {
                    name: e.name,
                    selected: a
                }
            }
            var i = t(Ei),
            n = t(Ar);
            i[Mn]("legendToggleSelect", "legendselectchanged", n.curry(e, "toggleSelected")),
            i[Mn]("legendSelect", "legendselected", n.curry(e, "select")),
            i[Mn]("legendUnSelect", "legendunselected", n.curry(e, "unSelect"))
        }),
        e("echarts/component/legend/legendFilter", [],
        function() {
            return function(t) {
                var e = t.findComponents({
                    mainType: "legend"
                });
                e && e[Wn] && t.filterSeries(function(t) {
                    for (var i = 0; i < e[Wn]; i++) if (!e[i].isSelected(t.name)) return ! 1;
                    return ! 0
                })
            }
        }),
        e("echarts/component/legend/LegendView", [Tr, Ar, I, Si, "../helper/listComponent", Ei],
        function(t) {
            function e(t, e) {
                e[Un]({
                    type: "legendToggleSelect",
                    name: t
                })
            }
            function i(t, e, i) {
                var n = i.getZr()[lr].getDisplayList()[0];
                n && n.useHoverLayer || t.get("legendHoverLink") && i[Un]({
                    type: "highlight",
                    seriesName: t.name,
                    name: e
                })
            }
            function n(t, e, i) {
                var n = i.getZr()[lr].getDisplayList()[0];
                n && n.useHoverLayer || t.get("legendHoverLink") && i[Un]({
                    type: "downplay",
                    seriesName: t.name,
                    name: e
                })
            }
            var r = t(Ar),
            a = t(I),
            o = t(Si),
            u = t("../helper/listComponent"),
            c = r.curry;
            return t(Ei)[_n]({
                type: "legend",
                init: function() {
                    this._symbolTypeStore = {}
                },
                render: function(t, a, h) {
                    var d = this.group;
                    if (d[cn](), t.get("show")) {
                        var f = t.get("selectedMode"),
                        p = t.get("align");
                        "auto" === p && (p = "right" === t.get("left") && t.get(l) === s ? "right": "left");
                        var v = {};
                        r.each(t[Kn](),
                        function(r) {
                            var s = r.get("name");
                            if ("" === s || "\n" === s) return void d.add(new o.Group({
                                newline: !0
                            }));
                            var l = a.getSeriesByName(s)[0];
                            if (!v[s]) if (l) {
                                var u = l[Kn](),
                                g = u[ce]("color");
                                typeof g === Sn && (g = g(l[In](0)));
                                var m = u[ce]("legendSymbol") || "roundRect",
                                y = u[ce](se),
                                x = this._createItem(s, r, t, m, y, p, g, f);
                                x.on("click", c(e, s, h)).on(En, c(i, l, "", h)).on(On, c(n, l, "", h)),
                                v[s] = !0
                            } else a.eachRawSeries(function(a) {
                                if (!v[s] && a.legendDataProvider) {
                                    var o = a.legendDataProvider(),
                                    l = o[Ae](s);
                                    if (0 > l) return;
                                    var u = o[gi](l, "color"),
                                    d = "roundRect",
                                    g = this._createItem(s, r, t, d, null, p, u, f);
                                    g.on("click", c(e, s, h)).on(En, c(i, a, s, h)).on(On, c(n, a, s, h)),
                                    v[s] = !0
                                }
                            },
                            this)
                        },
                        this),
                        u[E](d, t, h),
                        u.addBackground(d, t)
                    }
                },
                _createItem: function(t, e, i, n, s, l, u, c) {
                    var h = i.get("itemWidth"),
                    d = i.get("itemHeight"),
                    f = i.get("inactiveColor"),
                    p = i.isSelected(t),
                    g = new o.Group,
                    m = e[fr](on),
                    y = e.get("icon"),
                    x = e[fr]("tooltip");
                    if (n = y || n, g.add(a[P](n, 0, 0, h, d, p ? u: f)), !y && s && (s !== n || "none" == s)) {
                        var _ = .8 * d;
                        "none" === s && (s = fn),
                        g.add(a[P](s, (h - _) / 2, (d - _) / 2, _, _, p ? u: f))
                    }
                    var w = "left" === l ? h + 5 : -5,
                    b = l,
                    M = i.get(v),
                    S = t;
                    typeof M === yr && M ? S = M[Tn]("{name}", t) : typeof M === Sn && (S = M(t));
                    var A = new o.Text({
                        style: {
                            text: S,
                            x: w,
                            y: d / 2,
                            fill: p ? m[nn]() : f,
                            textFont: m[rn](),
                            textAlign: b,
                            textVerticalAlign: "middle"
                        }
                    });
                    g.add(A);
                    var T = new o.Rect({
                        shape: g[en](),
                        invisible: !0,
                        tooltip: x.get("show") ? r[jn]({
                            content: t,
                            formatter: function() {
                                return t
                            },
                            formatterParams: {
                                componentType: "legend",
                                legendIndex: i[Oe],
                                name: t,
                                $vars: ["name"]
                            }
                        },
                        x[zi]) : null
                    });
                    return g.add(T),
                    g[Je](function(t) {
                        t[Nn] = !0
                    }),
                    T[Nn] = !c,
                    this.group.add(g),
                    o[ri](g),
                    g
                }
            })
        }),
        e("echarts/component/legend/LegendModel", [Tr, Ar, W, Ei],
        function(t) {
            var e = t(Ar),
            i = t(W),
            n = t(Ei)[wn]({
                type: "legend",
                dependencies: [Fn],
                layoutMode: {
                    type: "box",
                    ignoreSize: !0
                },
                init: function(t, e, i) {
                    this[De](t, i),
                    t[ai] = t[ai] || {}
                },
                mergeOption: function(t) {
                    n[Ri](this, Vi, t)
                },
                optionUpdated: function() {
                    this._updateData(this[Te]);
                    var t = this._data;
                    if (t[0] && "single" === this.get("selectedMode")) {
                        for (var e = !1,
                        i = 0; i < t[Wn]; i++) {
                            var n = t[i].get("name");
                            if (this.isSelected(n)) {
                                this.select(n),
                                e = !0;
                                break
                            }
                        } ! e && this.select(t[0].get("name"))
                    }
                },
                _updateData: function(t) {
                    var n = e.map(this.get("data") || [],
                    function(t) {
                        return (typeof t === yr || typeof t === yn) && (t = {
                            name: t
                        }),
                        new i(t, this, this[Te])
                    },
                    this);
                    this._data = n;
                    var r = e.map(t.getSeries(),
                    function(t) {
                        return t.name
                    });
                    t[tr](function(t) {
                        if (t.legendDataProvider) {
                            var e = t.legendDataProvider();
                            r = r[Ai](e[he](e[Ci]))
                        }
                    }),
                    this._availableNames = r
                },
                getData: function() {
                    return this._data
                },
                select: function(t) {
                    var i = this[zi][ai],
                    n = this.get("selectedMode");
                    if ("single" === n) {
                        var r = this._data;
                        e.each(r,
                        function(t) {
                            i[t.get("name")] = !1
                        })
                    }
                    i[t] = !0
                },
                unSelect: function(t) {
                    "single" !== this.get("selectedMode") && (this[zi][ai][t] = !1)
                },
                toggleSelected: function(t) {
                    var e = this[zi][ai];
                    t in e || (e[t] = !0),
                    this[e[t] ? "unSelect": "select"](t)
                },
                isSelected: function(t) {
                    var i = this[zi][ai];
                    return ! (t in i && !i[t]) && e[gn](this._availableNames, t) >= 0
                },
                defaultOption: {
                    zlevel: 0,
                    z: 4,
                    show: !0,
                    orient: "horizontal",
                    left: "center",
                    top: "top",
                    align: "auto",
                    backgroundColor: "rgba(0,0,0,0)",
                    borderColor: "#ccc",
                    borderWidth: 0,
                    padding: 5,
                    itemGap: 10,
                    itemWidth: 25,
                    itemHeight: 14,
                    inactiveColor: "#ccc",
                    textStyle: {
                        color: "#333"
                    },
                    selectedMode: !0,
                    tooltip: {
                        show: !1
                    }
                }
            });
            return n
        }),
        e("echarts/util/layout", [Tr, Ar, Me, "./number", "./format"],
        function(t) {
            function e(t, e, i, n, r) {
                var a = 0,
                o = 0;
                null == n && (n = 1 / 0),
                null == r && (r = 1 / 0);
                var s = 0;
                e[Je](function(l, u) {
                    var c, h, d = l[$i],
                    f = l[en](),
                    p = e[di](u + 1),
                    v = p && p[en]();
                    if (t === O) {
                        var g = f.width + (v ? -v.x + f.x: 0);
                        c = a + g,
                        c > n || l.newline ? (a = 0, c = g, o += s + i, s = f[nr]) : s = Math.max(s, f[nr])
                    } else {
                        var m = f[nr] + (v ? -v.y + f.y: 0);
                        h = o + m,
                        h > r || l.newline ? (a += s + i, o = 0, h = m, s = f.width) : s = Math.max(s, f.width)
                    }
                    l.newline || (d[0] = a, d[1] = o, t === O ? a = c + i: o = h + i)
                })
            }
            var i = t(Ar),
            n = t(Me),
            r = t("./number"),
            a = t("./format"),
            o = r[We],
            l = i.each,
            u = {},
            c = ["left", "right", "top", rr, "width", nr];
            return u.box = e,
            u.vbox = i.curry(e, s),
            u.hbox = i.curry(e, O),
            u.getAvailableSize = function(t, e, i) {
                var n = e.width,
                r = e[nr],
                s = o(t.x, n),
                l = o(t.y, r),
                u = o(t.x2, n),
                c = o(t.y2, r);
                return (isNaN(s) || isNaN(parseFloat(t.x))) && (s = 0),
                (isNaN(u) || isNaN(parseFloat(t.x2))) && (u = n),
                (isNaN(l) || isNaN(parseFloat(t.y))) && (l = 0),
                (isNaN(c) || isNaN(parseFloat(t.y2))) && (c = r),
                i = a.normalizeCssArray(i || 0),
                {
                    width: Math.max(u - s - i[1] - i[3], 0),
                    height: Math.max(c - l - i[0] - i[2], 0)
                }
            },
            u[Ki] = function(t, e, i) {
                i = a.normalizeCssArray(i || 0);
                var r = e.width,
                s = e[nr],
                l = o(t.left, r),
                u = o(t.top, s),
                c = o(t.right, r),
                h = o(t[rr], s),
                d = o(t.width, r),
                f = o(t[nr], s),
                p = i[2] + i[0],
                v = i[1] + i[3],
                g = t.aspect;
                switch (isNaN(d) && (d = r - c - v - l), isNaN(f) && (f = s - h - p - u), isNaN(d) && isNaN(f) && (g > r / s ? d = .8 * r: f = .8 * s), null != g && (isNaN(d) && (d = g * f), isNaN(f) && (f = d / g)), isNaN(l) && (l = r - c - d - v), isNaN(u) && (u = s - h - f - p), t.left || t.right) {
                case Ji:
                    l = r / 2 - d / 2 - i[3];
                    break;
                case "right":
                    l = r - d - v
                }
                switch (t.top || t[rr]) {
                case Qi:
                case Ji:
                    u = s / 2 - f / 2 - i[0];
                    break;
                case rr:
                    u = s - f - p
                }
                l = l || 0,
                u = u || 0,
                isNaN(d) && (d = r - l - (c || 0)),
                isNaN(f) && (f = s - u - (h || 0));
                var m = new n(l + i[3], u + i[0], d, f);
                return m.margin = i,
                m
            },
            u.positionGroup = function(t, e, n, r) {
                var a = t[en]();
                e = i[jn](i.clone(e), {
                    width: a.width,
                    height: a[nr]
                }),
                e = u[Ki](e, n, r),
                t.attr($i, [e.x - a.x, e.y - a.y])
            },
            u.mergeLayoutParam = function(t, e, n) {
                function r(i) {
                    var r = {},
                    s = 0,
                    u = {},
                    c = 0,
                    h = n.ignoreSize ? 1 : 2;
                    if (l(i,
                    function(e) {
                        u[e] = t[e]
                    }), l(i,
                    function(t) {
                        a(e, t) && (r[t] = u[t] = e[t]),
                        o(r, t) && s++,
                        o(u, t) && c++
                    }), c !== h && s) {
                        if (s >= h) return r;
                        for (var d = 0; d < i[Wn]; d++) {
                            var f = i[d];
                            if (!a(r, f) && a(t, f)) {
                                r[f] = t[f];
                                break
                            }
                        }
                        return r
                    }
                    return u
                }
                function a(t, e) {
                    return t.hasOwnProperty(e)
                }
                function o(t, e) {
                    return null != t[e] && "auto" !== t[e]
                }
                function s(t, e, i) {
                    l(t,
                    function(t) {
                        e[t] = i[t]
                    })
                } ! i[Yn](n) && (n = {});
                var u = ["width", "left", "right"],
                c = [nr, "top", rr],
                h = r(u),
                d = r(c);
                s(u, t, h),
                s(c, t, d)
            },
            u.getLayoutParams = function(t) {
                return u.copyLayoutParams({},
                t)
            },
            u.copyLayoutParams = function(t, e) {
                return e && t && l(c,
                function(i) {
                    e.hasOwnProperty(i) && (t[i] = e[i])
                }),
                t
            },
            u
        }),
        e("echarts/component/tooltip/TooltipModel", [Tr, Ei],
        function(t) {
            t(Ei)[wn]({
                type: "tooltip",
                defaultOption: {
                    zlevel: 0,
                    z: 8,
                    show: !0,
                    showContent: !0,
                    trigger: "item",
                    triggerOn: "mousemove",
                    alwaysShowContent: !1,
                    showDelay: 0,
                    hideDelay: 100,
                    transitionDuration: .4,
                    enterable: !1,
                    backgroundColor: "rgba(50,50,50,0.7)",
                    borderColor: "#333",
                    borderRadius: 4,
                    borderWidth: 0,
                    padding: 5,
                    extraCssText: "",
                    axisPointer: {
                        type: "line",
                        axis: "auto",
                        animation: !0,
                        animationDurationUpdate: 200,
                        animationEasingUpdate: "exponentialOut",
                        lineStyle: {
                            color: "#555",
                            width: 1,
                            type: "solid"
                        },
                        crossStyle: {
                            color: "#555",
                            width: 1,
                            type: "dashed",
                            textStyle: {}
                        },
                        shadowStyle: {
                            color: "rgba(150,150,150,0.3)"
                        }
                    },
                    textStyle: {
                        color: "#fff",
                        fontSize: 14
                    }
                }
            })
        }),
        e("echarts/component/tooltip/TooltipView", [Tr, "./TooltipContent", Si, Ar, G, qe, Sr, W, Ei],
        function(t) {
            function e(t, e) {
                if (!t || !e) return ! 1;
                var i = g.round;
                return i(t[0]) === i(e[0]) && i(t[1]) === i(e[1])
            }
            function i(t, e, i, n) {
                return {
                    x1: t,
                    y1: e,
                    x2: i,
                    y2: n
                }
            }
            function n(t, e, i, n) {
                return {
                    x: t,
                    y: e,
                    width: i,
                    height: n
                }
            }
            function r(t, e, i, n, r, a) {
                return {
                    cx: t,
                    cy: e,
                    r0: i,
                    r: n,
                    startAngle: r,
                    endAngle: a,
                    clockwise: !0
                }
            }
            function a(t, e, i, n, r) {
                var a = i.clientWidth,
                o = i.clientHeight,
                s = 20;
                return t + a + s > n ? t -= a + s: t += s,
                e + o + s > r ? e -= o + s: e += s,
                [t, e]
            }
            function o(t, e, i) {
                var n = i.clientWidth,
                r = i.clientHeight,
                a = 5,
                o = 0,
                s = 0,
                l = e.width,
                u = e[nr];
                switch (t) {
                case mi:
                    o = e.x + l / 2 - n / 2,
                    s = e.y + u / 2 - r / 2;
                    break;
                case "top":
                    o = e.x + l / 2 - n / 2,
                    s = e.y - r - a;
                    break;
                case rr:
                    o = e.x + l / 2 - n / 2,
                    s = e.y + u + a;
                    break;
                case "left":
                    o = e.x - n - a,
                    s = e.y + u / 2 - r / 2;
                    break;
                case "right":
                    o = e.x + l + a,
                    s = e.y + u / 2 - r / 2
                }
                return [o, s]
            }
            function s(t, e, i, n, r, s, l) {
                var u = l[dr](),
                c = l[hr](),
                h = s && s[en]().clone();
                if (s && h[_e](s[k]), typeof t === Sn && (t = t([e, i], r, n.el, h)), d[An](t)) e = m(t[0], u),
                i = m(t[1], c);
                else if (typeof t === yr && s) {
                    var f = o(t, h, n.el);
                    e = f[0],
                    i = f[1]
                } else {
                    var f = a(e, i, n.el, u, c);
                    e = f[0],
                    i = f[1]
                }
                n[p](e, i)
            }
            function u(t) {
                var e = t[ln],
                i = t.get("tooltip.trigger", !0);
                return ! (!e || e.type !== q && "polar" !== e.type && "singleAxis" !== e.type || "item" === i)
            }
            var c = t("./TooltipContent"),
            h = t(Si),
            d = t(Ar),
            f = t(G),
            g = t(qe),
            m = g[We],
            y = t(Sr),
            x = t(W);
            t(Ei)[_n]({
                type: "tooltip",
                _axisPointers: {},
                init: function(t, e) {
                    if (!y.node) {
                        var i = new c(e.getDom(), e);
                        this._tooltipContent = i,
                        e.on("showTip", this._manuallyShowTip, this),
                        e.on("hideTip", this._manuallyHideTip, this)
                    }
                },
                render: function(t, e, i) {
                    if (!y.node) {
                        this.group[cn](),
                        this._axisPointers = {},
                        this._tooltipModel = t,
                        this._ecModel = e,
                        this._api = i,
                        this._lastHover = {};
                        var n = this._tooltipContent;
                        n[er](),
                        n.enterable = t.get("enterable"),
                        this._alwaysShowContent = t.get("alwaysShowContent"),
                        this._seriesGroupByAxis = this._prepareAxisTriggerData(t, e);
                        var r = this._crossText;
                        if (r && this.group.add(r), null != this._lastX && null != this._lastY) {
                            var a = this;
                            clearTimeout(this._refreshUpdateTimeout),
                            this._refreshUpdateTimeout = setTimeout(function() {
                                a._manuallyShowTip({
                                    x: a._lastX,
                                    y: a._lastY
                                })
                            })
                        }
                        var o = this._api.getZr();
                        o.off("click", this._tryShow),
                        o.off(Rn, this._mousemove),
                        o.off(On, this._hide),
                        o.off("globalout", this._hide),
                        "click" === t.get("triggerOn") ? o.on("click", this._tryShow, this) : (o.on(Rn, this._mousemove, this), o.on(On, this._hide, this), o.on("globalout", this._hide, this))
                    }
                },
                _mousemove: function(t) {
                    var e = this._tooltipModel.get("showDelay"),
                    i = this;
                    clearTimeout(this._showTimeout),
                    e > 0 ? this._showTimeout = setTimeout(function() {
                        i._tryShow(t)
                    },
                    e) : this._tryShow(t)
                },
                _manuallyShowTip: function(t) {
                    if (t.from !== this.uid) {
                        var e = this._ecModel,
                        i = t[Dn],
                        n = t[zn],
                        r = e.getSeriesByIndex(i),
                        a = this._api;
                        if (null == t.x || null == t.y) {
                            if (r || e[tr](function(t) {
                                u(t) && !r && (r = t)
                            }), r) {
                                var o = r[Kn]();
                                null == n && (n = o[Ae](t.name));
                                var s, l, c = o[Mi](n),
                                h = r[ln];
                                if (h && h[ae]) {
                                    var f = h[ae](o.getValues(d.map(h[de],
                                    function(t) {
                                        return r[j](t)[0]
                                    }), n, !0));
                                    s = f && f[0],
                                    l = f && f[1]
                                } else if (c) {
                                    var p = c[en]().clone();
                                    p[_e](c[k]),
                                    s = p.x + p.width / 2,
                                    l = p.y + p[nr] / 2
                                }
                                null != s && null != l && this._tryShow({
                                    offsetX: s,
                                    offsetY: l,
                                    target: c,
                                    event: {}
                                })
                            }
                        } else {
                            var c = a.getZr().handler.findHover(t.x, t.y);
                            this._tryShow({
                                offsetX: t.x,
                                offsetY: t.y,
                                target: c,
                                event: {}
                            })
                        }
                    }
                },
                _manuallyHideTip: function(t) {
                    t.from !== this.uid && this._hide()
                },
                _prepareAxisTriggerData: function(t, e) {
                    var i = {};
                    return e[tr](function(t) {
                        if (u(t)) {
                            var e, n, r = t[ln];
                            r.type === q ? (e = r[Ie](), n = e.dim + e.index) : "singleAxis" === r.type ? (e = r[J](), n = e.dim + e.type) : (e = r[Ie](), n = e.dim + r.name),
                            i[n] = i[n] || {
                                coordSys: [],
                                series: []
                            },
                            i[n].coordSys.push(r),
                            i[n][Fn].push(t)
                        }
                    },
                    this),
                    i
                },
                _tryShow: function(t) {
                    var e = t[Vn],
                    i = this._tooltipModel,
                    n = i.get(Zn),
                    r = this._ecModel,
                    a = this._api;
                    if (i) if (this._lastX = t[w], this._lastY = t[_], e && null != e[zn]) {
                        var o = e.dataModel || r.getSeriesByIndex(e[Dn]),
                        s = e[zn],
                        l = o[Kn]()[hi](s);
                        "axis" === (l.get("tooltip.trigger") || n) ? this._showAxisTooltip(i, r, t) : (this._ticket = "", this._hideAxisPointer(), this._resetLastHover(), this._showItemTooltipContent(o, s, e[Pn], t)),
                        a[Un]({
                            type: "showTip",
                            from: this.uid,
                            dataIndex: e[zn],
                            seriesIndex: e[Dn]
                        })
                    } else if (e && e.tooltip) {
                        var u = e.tooltip;
                        if (typeof u === yr) {
                            var c = u;
                            u = {
                                content: c,
                                formatter: c
                            }
                        }
                        var h = new x(u, i),
                        d = h.get("content"),
                        f = Math.random();
                        this._showTooltipContent(h, d, h.get("formatterParams") || {},
                        f, t[w], t[_], e, a)
                    } else "item" === n ? this._hide() : this._showAxisTooltip(i, r, t),
                    "cross" === i.get("axisPointer.type") && a[Un]({
                        type: "showTip",
                        from: this.uid,
                        x: t[w],
                        y: t[_]
                    })
                },
                _showAxisTooltip: function(t, i, n) {
                    var r = t[fr]("axisPointer"),
                    a = r.get("type");
                    if ("cross" === a) {
                        var o = n[Vn];
                        if (o && null != o[zn]) {
                            var s = i.getSeriesByIndex(o[Dn]),
                            l = o[zn];
                            this._showItemTooltipContent(s, l, o[Pn], n)
                        }
                    }
                    this._showAxisPointer();
                    var u = !0;
                    d.each(this._seriesGroupByAxis,
                    function(t) {
                        var i = t.coordSys,
                        o = i[0],
                        s = [n[w], n[_]];
                        if (!o.containPoint(s)) return void this._hideAxisPointer(o.name);
                        u = !1;
                        var l = o[de],
                        c = o.pointToData(s, !0);
                        s = o[ae](c);
                        var h = o[Ie](),
                        f = r.get("axis");
                        "auto" === f && (f = h.dim);
                        var p = !1,
                        v = this._lastHover;
                        if ("cross" === a) e(v.data, c) && (p = !0),
                        v.data = c;
                        else {
                            var g = d[gn](l, f);
                            v.data === c[g] && (p = !0),
                            v.data = c[g]
                        }
                        o.type !== q || p ? "polar" !== o.type || p ? "singleAxis" !== o.type || p || this._showSinglePointer(r, o, f, s) : this._showPolarPointer(r, o, f, s) : this._showCartesianPointer(r, o, f, s),
                        "cross" !== a && this._dispatchAndShowSeriesTooltipContent(o, t[Fn], s, c, p)
                    },
                    this),
                    this._tooltipModel.get("show") || this._hideAxisPointer(),
                    u && this._hide()
                },
                _showCartesianPointer: function(t, e, r, a) {
                    function o(n, r, a) {
                        var o = "x" === n ? i(r[0], a[0], r[0], a[1]) : i(a[0], r[1], a[1], r[1]),
                        s = l._getPointerElement(e, t, n, o);
                        h.subPixelOptimizeLine({
                            shape: o,
                            style: s.style
                        }),
                        d ? h[ui](s, {
                            shape: o
                        },
                        t) : s.attr({
                            shape: o
                        })
                    }
                    function s(i, r, a) {
                        var o = e[J](i),
                        s = o.getBandWidth(),
                        u = a[1] - a[0],
                        c = "x" === i ? n(r[0] - s / 2, a[0], s, u) : n(a[0], r[1] - s / 2, u, s),
                        f = l._getPointerElement(e, t, i, c);
                        d ? h[ui](f, {
                            shape: c
                        },
                        t) : f.attr({
                            shape: c
                        })
                    }
                    var l = this,
                    u = t.get("type"),
                    c = e[Ie](),
                    d = "cross" !== u && c.type === te && c.getBandWidth() > 20;
                    if ("cross" === u) o("x", a, e[J]("y").getGlobalExtent()),
                    o("y", a, e[J]("x").getGlobalExtent()),
                    this._updateCrossText(e, a, t);
                    else {
                        var f = e[J]("x" === r ? "y": "x"),
                        p = f.getGlobalExtent();
                        e.type === q && ("line" === u ? o: s)(r, a, p)
                    }
                },
                _showSinglePointer: function(t, e, n, r) {
                    function a(n, r, a) {
                        var s = e[J](),
                        c = s[l],
                        d = c === O ? i(r[0], a[0], r[0], a[1]) : i(a[0], r[1], a[1], r[1]),
                        f = o._getPointerElement(e, t, n, d);
                        u ? h[ui](f, {
                            shape: d
                        },
                        t) : f.attr({
                            shape: d
                        })
                    }
                    var o = this,
                    s = t.get("type"),
                    u = "cross" !== s && e[Ie]().type === te,
                    c = e[un](),
                    d = [c.y, c.y + c[nr]];
                    a(n, r, d)
                },
                _showPolarPointer: function(t, e, n, a) {
                    function o(n, r, a) {
                        var o, s = e.pointToCoord(r);
                        if ("angle" === n) {
                            var u = e.coordToPoint([a[0], s[1]]),
                            c = e.coordToPoint([a[1], s[1]]);
                            o = i(u[0], u[1], c[0], c[1])
                        } else o = {
                            cx: e.cx,
                            cy: e.cy,
                            r: s[0]
                        };
                        var d = l._getPointerElement(e, t, n, o);
                        f ? h[ui](d, {
                            shape: o
                        },
                        t) : d.attr({
                            shape: o
                        })
                    }
                    function s(i, n, a) {
                        var o, s = e[J](i),
                        u = s.getBandWidth(),
                        c = e.pointToCoord(n),
                        d = Math.PI / 180;
                        o = "angle" === i ? r(e.cx, e.cy, a[0], a[1], ( - c[1] - u / 2) * d, ( - c[1] + u / 2) * d) : r(e.cx, e.cy, c[0] - u / 2, c[0] + u / 2, 0, 2 * Math.PI);
                        var p = l._getPointerElement(e, t, i, o);
                        f ? h[ui](p, {
                            shape: o
                        },
                        t) : p.attr({
                            shape: o
                        })
                    }
                    var l = this,
                    u = t.get("type"),
                    c = e.getAngleAxis(),
                    d = e.getRadiusAxis(),
                    f = "cross" !== u && e[Ie]().type === te;
                    if ("cross" === u) o("angle", a, d[Fi]()),
                    o(Ze, a, c[Fi]()),
                    this._updateCrossText(e, a, t);
                    else {
                        var p = e[J](n === Ze ? "angle": Ze),
                        v = p[Fi](); ("line" === u ? o: s)(n, a, v)
                    }
                },
                _updateCrossText: function(t, e, i) {
                    var n = i[fr]("crossStyle"),
                    r = n[fr](on),
                    a = this._tooltipModel,
                    o = this._crossText;
                    o || (o = this._crossText = new h.Text({
                        style: {
                            textAlign: "left",
                            textVerticalAlign: "bottom"
                        }
                    }), this.group.add(o));
                    var s = t.pointToData(e),
                    l = t[de];
                    s = d.map(s,
                    function(e, i) {
                        var n = t[J](l[i]);
                        return e = n.type === te || "time" === n.type ? n.scale[Wi](e) : f[ze](e[Ii](n.getPixelPrecision()))
                    }),
                    o[Ln]({
                        fill: r[nn]() || n.get("color"),
                        textFont: r[rn](),
                        text: s.join(", "),
                        x: e[0] + 5,
                        y: e[1] - 5
                    }),
                    o.z = a.get("z"),
                    o[Cn] = a.get(Cn)
                },
                _getPointerElement: function(t, e, i, n) {
                    var r = this._tooltipModel,
                    a = r.get("z"),
                    o = r.get(Cn),
                    s = this._axisPointers,
                    l = t.name;
                    if (s[l] = s[l] || {},
                    s[l][i]) return s[l][i];
                    var u = e.get("type"),
                    c = e[fr](u + "Style"),
                    d = "shadow" === u,
                    f = c[d ? V: ti](),
                    p = "polar" === t.type ? d ? _i: i === Ze ? be: "Line": d ? "Rect": "Line";
                    d ? f[ye] = null: f.fill = null;
                    var v = s[l][i] = new h[p]({
                        style: f,
                        z: a,
                        zlevel: o,
                        silent: !0,
                        shape: n
                    });
                    return this.group.add(v),
                    v
                },
                _dispatchAndShowSeriesTooltipContent: function(t, e, i, n, r) {
                    var a = this._tooltipModel,
                    o = t[Ie](),
                    l = "x" === o.dim || o.dim === Ze ? 0 : 1,
                    u = d.map(e,
                    function(t) {
                        return {
                            seriesIndex: t[Dn],
                            dataIndex: t.getAxisTooltipDataIndex ? t.getAxisTooltipDataIndex(t[j](o.dim), n, o) : t[Kn]().indexOfNearest(t[j](o.dim)[0], n[l], !1, o.type === te ? .5 : null)
                        }
                    }),
                    c = this._lastHover,
                    h = this._api;
                    if (c.payloadBatch && !r && h[Un]({
                        type: "downplay",
                        batch: c.payloadBatch
                    }), r || (h[Un]({
                        type: "highlight",
                        batch: u
                    }), c.payloadBatch = u), h[Un]({
                        type: "showTip",
                        dataIndex: u[0][zn],
                        seriesIndex: u[0][Dn],
                        from: this.uid
                    }), o && a.get("showContent") && a.get("show")) {
                        var f = d.map(e,
                        function(t, e) {
                            return t[In](u[e][zn])
                        });
                        if (r) s(a.get($i), i[0], i[1], this._tooltipContent, f, null, h);
                        else {
                            var p = u[0][zn],
                            v = "time" === o.type ? o.scale[Wi](n[l]) : e[0][Kn]()[Ci](p),
                            g = (v ? v + Le: "") + d.map(e,
                            function(t, e) {
                                return t.formatTooltip(u[e][zn], !0)
                            }).join(Le),
                            m = "axis_" + t.name + "_" + p;
                            this._showTooltipContent(a, g, f, m, i[0], i[1], null, h)
                        }
                    }
                },
                _showItemTooltipContent: function(t, e, i, n) {
                    var r = this._api,
                    a = t[Kn](i),
                    o = a[hi](e),
                    s = o.get("tooltip", !0);
                    if (typeof s === yr) {
                        var l = s;
                        s = {
                            formatter: l
                        }
                    }
                    var u = this._tooltipModel,
                    c = t[fr]("tooltip", u),
                    h = new x(s, c, c[Te]),
                    d = t[In](e, i),
                    f = t.formatTooltip(e, !1, i),
                    p = "item_" + t.name + "_" + e;
                    this._showTooltipContent(h, f, d, p, n[w], n[_], n[Vn], r)
                },
                _showTooltipContent: function(t, e, i, n, r, a, o, l) {
                    if (this._ticket = "", t.get("showContent") && t.get("show")) {
                        var u = this._tooltipContent,
                        c = t.get(v),
                        h = t.get($i),
                        d = e;
                        if (c) if (typeof c === yr) d = f.formatTpl(c, i);
                        else if (typeof c === Sn) {
                            var p = this,
                            g = n,
                            m = function(t, e) {
                                t === p._ticket && (u.setContent(e), s(h, r, a, u, i, o, l))
                            };
                            p._ticket = g,
                            d = c(i, g, m)
                        }
                        u.show(t),
                        u.setContent(d),
                        s(h, r, a, u, i, o, l)
                    }
                },
                _showAxisPointer: function(t) {
                    if (t) {
                        var e = this._axisPointers[t];
                        e && d.each(e,
                        function(t) {
                            t.show()
                        })
                    } else this.group[Je](function(t) {
                        t.show()
                    }),
                    this.group.show()
                },
                _resetLastHover: function() {
                    var t = this._lastHover;
                    t.payloadBatch && this._api[Un]({
                        type: "downplay",
                        batch: t.payloadBatch
                    }),
                    this._lastHover = {}
                },
                _hideAxisPointer: function(t) {
                    if (t) {
                        var e = this._axisPointers[t];
                        e && d.each(e,
                        function(t) {
                            t.hide()
                        })
                    } else this.group.children()[Wn] && this.group.hide()
                },
                _hide: function() {
                    clearTimeout(this._showTimeout),
                    this._hideAxisPointer(),
                    this._resetLastHover(),
                    this._alwaysShowContent || this._tooltipContent.hideLater(this._tooltipModel.get("hideDelay")),
                    this._api[Un]({
                        type: "hideTip",
                        from: this.uid
                    }),
                    this._lastX = this._lastY = null
                },
                dispose: function(t, e) {
                    if (!y.node) {
                        var i = e.getZr();
                        this._tooltipContent.hide(),
                        i.off("click", this._tryShow),
                        i.off(Rn, this._mousemove),
                        i.off(On, this._hide),
                        i.off("globalout", this._hide),
                        e.off("showTip", this._manuallyShowTip),
                        e.off("hideTip", this._manuallyHideTip)
                    }
                }
            })
        }),
        e("echarts/component/marker/MarkPointModel", [Tr, "./MarkerModel"],
        function(t) {
            return t("./MarkerModel")[jn]({
                type: "markPoint",
                defaultOption: {
                    zlevel: 0,
                    z: 5,
                    symbol: "pin",
                    symbolSize: 50,
                    tooltip: {
                        trigger: "item"
                    },
                    label: {
                        normal: {
                            show: !0,
                            position: "inside"
                        },
                        emphasis: {
                            show: !0
                        }
                    },
                    itemStyle: {
                        normal: {
                            borderWidth: 2
                        }
                    }
                }
            })
        }),
        e("echarts/component/marker/MarkPointView", [Tr, "../../chart/helper/SymbolDraw", Ar, qe, Gi, "./markerHelper", "./MarkerView"],
        function(t) {
            function e(t, e, i) {
                var n = e[ln];
                t.each(function(r) {
                    var o, s = t[hi](r),
                    l = a[We](s.get("x"), i[dr]()),
                    u = a[We](s.get("y"), i[hr]());
                    if (isNaN(l) || isNaN(u)) {
                        if (e.getMarkerPosition) o = e.getMarkerPosition(t.getValues(t[de], r));
                        else if (n) {
                            var c = t.get(n[de][0], r),
                            h = t.get(n[de][1], r);
                            o = n[ae]([c, h])
                        }
                    } else o = [l, u];
                    isNaN(l) || (o[0] = l),
                    isNaN(u) || (o[1] = u),
                    t[He](r, o)
                })
            }
            function i(t, e, i) {
                var n;
                n = t ? r.map(t && t[de],
                function(t) {
                    var i = e[Kn]().getDimensionInfo(e[j](t)[0]) || {};
                    return i.name = t,
                    i
                }) : [{
                    name: "value",
                    type: "float"
                }];
                var a = new o(n, i),
                l = r.map(i.get("data"), r.curry(s.dataTransform, e));
                return t && (l = r[mn](l, r.curry(s.dataFilter, t))),
                a[Di](l, null, t ? s.dimValueGetter: function(t) {
                    return t.value
                }),
                a
            }
            var n = t("../../chart/helper/SymbolDraw"),
            r = t(Ar),
            a = t(qe),
            o = t(Gi),
            s = t("./markerHelper");
            t("./MarkerView")[jn]({
                type: "markPoint",
                updateLayout: function(t, i, n) {
                    i[tr](function(t) {
                        var i = t.markPointModel;
                        i && (e(i[Kn](), t, n), this.markerGroupMap[t.name][Qn](i))
                    },
                    this)
                },
                renderSeries: function(t, r, a, o) {
                    var s = t[ln],
                    l = t.name,
                    u = t[Kn](),
                    c = this.markerGroupMap,
                    h = c[l];
                    h || (h = c[l] = new n);
                    var d = i(s, t, r);
                    r.setData(d),
                    e(r[Kn](), t, o),
                    d.each(function(t) {
                        var e = d[hi](t),
                        i = e[Ce](oe);
                        typeof i === Sn && (i = i(r[ke](t), r[In](t))),
                        d[Ue](t, {
                            symbolSize: i,
                            color: e.get("itemStyle.normal.color") || u[ce]("color"),
                            symbol: e[Ce](se)
                        })
                    }),
                    h[yi](d),
                    this.group.add(h.group),
                    d[Se](function(t) {
                        t[kn](function(t) {
                            t.dataModel = r
                        })
                    }),
                    h.__keep = !0,
                    h.group[Nn] = r.get(Nn) || t.get(Nn)
                }
            })
        }),
        e("echarts/component/marker/MarkLineModel", [Tr, "./MarkerModel"],
        function(t) {
            return t("./MarkerModel")[jn]({
                type: "markLine",
                defaultOption: {
                    zlevel: 0,
                    z: 5,
                    symbol: [fn, "arrow"],
                    symbolSize: [8, 16],
                    precision: 2,
                    tooltip: {
                        trigger: "item"
                    },
                    label: {
                        normal: {
                            show: !0,
                            position: "end"
                        },
                        emphasis: {
                            show: !0
                        }
                    },
                    lineStyle: {
                        normal: {
                            type: "dashed"
                        },
                        emphasis: {
                            width: 3
                        }
                    },
                    animationEasing: "linear"
                }
            })
        }),
        e("echarts/component/marker/MarkLineView", [Tr, Ar, Gi, qe, "./markerHelper", "../../chart/helper/LineDraw", "./MarkerView"],
        function(t) {
            function e(t) {
                return ! isNaN(t) && !isFinite(t)
            }
            function i(t, i, n, r) {
                var a = 1 - t,
                o = r[de][t];
                return e(i[a]) && e(n[a]) && i[t] === n[t] && r[J](o).containData(i[t])
            }
            function n(t, e) {
                if (t.type === q) {
                    var n = e[0].coord,
                    r = e[1].coord;
                    if (n && r && (i(1, n, r, t) || i(0, n, r, t))) return ! 0
                }
                return u.dataFilter(t, e[0]) && u.dataFilter(t, e[1])
            }
            function r(t, i, n, r, a) {
                var o, s = r[ln],
                u = t[hi](i),
                c = l[We](u.get("x"), a[dr]()),
                h = l[We](u.get("y"), a[hr]());
                if (isNaN(c) || isNaN(h)) {
                    if (r.getMarkerPosition) o = r.getMarkerPosition(t.getValues(t[de], i));
                    else {
                        var d = s[de],
                        f = t.get(d[0], i),
                        p = t.get(d[1], i);
                        o = s[ae]([f, p])
                    }
                    if (s.type === q) {
                        var v = s[J]("x"),
                        g = s[J]("y"),
                        d = s[de];
                        e(t.get(d[0], i)) ? o[0] = v[U](v[Fi]()[n ? 0 : 1]) : e(t.get(d[1], i)) && (o[1] = g[U](g[Fi]()[n ? 0 : 1]))
                    }
                    isNaN(c) || (o[0] = c),
                    isNaN(h) || (o[1] = h)
                } else o = [c, h];
                t[He](i, o)
            }
            function a(t, e, i) {
                var r;
                r = t ? o.map(t && t[de],
                function(t) {
                    var i = e[Kn]().getDimensionInfo(e[j](t)[0]) || {};
                    return i.name = t,
                    i
                }) : [{
                    name: "value",
                    type: "float"
                }];
                var a = new s(r, i),
                l = new s(r, i),
                c = new s([], i),
                d = o.map(i.get("data"), o.curry(h, e, t, i));
                t && (d = o[mn](d, o.curry(n, t)));
                var f = t ? u.dimValueGetter: function(t) {
                    return t.value
                };
                return a[Di](o.map(d,
                function(t) {
                    return t[0]
                }), null, f),
                l[Di](o.map(d,
                function(t) {
                    return t[1]
                }), null, f),
                c[Di](o.map(d,
                function(t) {
                    return t[2]
                })),
                c[fe] = !0,
                {
                    from: a,
                    to: l,
                    line: c
                }
            }
            var o = t(Ar),
            s = t(Gi),
            l = t(qe),
            u = t("./markerHelper"),
            c = t("../../chart/helper/LineDraw"),
            h = function(t, e, i, n) {
                var r = t[Kn](),
                a = n.type;
                if (!o[An](n) && ("min" === a || "max" === a || "average" === a || null != n.xAxis || null != n.yAxis)) {
                    var s, l, c;
                    if (null != n.yAxis || null != n.xAxis) l = null != n.yAxis ? "y": "x",
                    s = e[J](l),
                    c = o[vi](n.yAxis, n.xAxis);
                    else {
                        var h = u.getAxisInfo(n, r, e, t);
                        l = h.valueDataDim,
                        s = h.valueAxis,
                        c = u.numCalculate(r, l, a)
                    }
                    var d = "x" === l ? 0 : 1,
                    f = 1 - d,
                    p = o.clone(n),
                    v = {};
                    p.type = null,
                    p.coord = [],
                    v.coord = [],
                    p.coord[f] = -1 / 0,
                    v.coord[f] = 1 / 0;
                    var g = i.get("precision");
                    g >= 0 && (c = +c[Ii](g)),
                    p.coord[d] = v.coord[d] = c,
                    n = [p, v, {
                        type: a,
                        valueIndex: n.valueIndex,
                        value: c
                    }]
                }
                return n = [u.dataTransform(t, n[0]), u.dataTransform(t, n[1]), o[jn]({},
                n[2])],
                n[2].type = n[2].type || "",
                o.merge(n[2], n[0]),
                o.merge(n[2], n[1]),
                n
            };
            t("./MarkerView")[jn]({
                type: "markLine",
                updateLayout: function(t, e, i) {
                    e[tr](function(t) {
                        var e = t.markLineModel;
                        if (e) {
                            var n = e[Kn](),
                            a = e.__from,
                            o = e.__to;
                            a.each(function(e) {
                                r(a, e, !0, t, i),
                                r(o, e, !1, t, i)
                            }),
                            n.each(function(t) {
                                n[He](t, [a[bi](t), o[bi](t)])
                            }),
                            this.markerGroupMap[t.name][Qn]()
                        }
                    },
                    this)
                },
                renderSeries: function(t, e, i, n) {
                    function s(e, i, a) {
                        var o = e[hi](i);
                        r(e, i, a, t, n),
                        e[Ue](i, {
                            symbolSize: o.get(oe) || x[a ? 0 : 1],
                            symbol: o.get(se, !0) || y[a ? 0 : 1],
                            color: o.get("itemStyle.normal.color") || h[ce]("color")
                        })
                    }
                    var l = t[ln],
                    u = t.name,
                    h = t[Kn](),
                    d = this.markerGroupMap,
                    f = d[u];
                    f || (f = d[u] = new c),
                    this.group.add(f.group);
                    var p = a(l, t, e),
                    v = p.from,
                    g = p.to,
                    m = p.line;
                    e.__from = v,
                    e.__to = g,
                    e.setData(m);
                    var y = e.get(se),
                    x = e.get(oe);
                    o[An](y) || (y = [y, y]),
                    typeof x === yn && (x = [x, x]),
                    p.from.each(function(t) {
                        s(v, t, !0),
                        s(g, t, !1)
                    }),
                    m.each(function(t) {
                        var e = m[hi](t).get("lineStyle.normal.color");
                        m[Ue](t, {
                            color: e || v[gi](t, "color")
                        }),
                        m[He](t, [v[bi](t), g[bi](t)]),
                        m[Ue](t, {
                            fromSymbolSize: v[gi](t, oe),
                            fromSymbol: v[gi](t, se),
                            toSymbolSize: g[gi](t, oe),
                            toSymbol: g[gi](t, se)
                        })
                    }),
                    f[yi](m),
                    p.line[Se](function(t) {
                        t[kn](function(t) {
                            t.dataModel = e
                        })
                    }),
                    f.__keep = !0,
                    f.group[Nn] = e.get(Nn) || t.get(Nn)
                }
            })
        }),
        e("echarts/component/marker/MarkAreaModel", [Tr, "./MarkerModel"],
        function(t) {
            return t("./MarkerModel")[jn]({
                type: "markArea",
                defaultOption: {
                    zlevel: 0,
                    z: 1,
                    tooltip: {
                        trigger: "item"
                    },
                    animation: !1,
                    label: {
                        normal: {
                            show: !0,
                            position: "top"
                        },
                        emphasis: {
                            show: !0,
                            position: "top"
                        }
                    },
                    itemStyle: {
                        normal: {
                            borderWidth: 0
                        }
                    }
                }
            })
        }),
        e("echarts/component/marker/MarkAreaView", [Tr, Ar, Gi, qe, Si, Mr, "./markerHelper", "./MarkerView"],
        function(t) {
            function e(t) {
                return ! isNaN(t) && !isFinite(t)
            }
            function i(t, i, n) {
                var r = 1 - t;
                return e(i[r]) && e(n[r])
            }
            function n(t, e) {
                var n = e.coord[0],
                r = e.coord[1];
                return t.type === q && n && r && (i(1, n, r, t) || i(0, n, r, t)) ? !0 : h.dataFilter(t, {
                    coord: n,
                    x: e.x0,
                    y: e.y0
                }) || h.dataFilter(t, {
                    coord: r,
                    x: e.x1,
                    y: e.y1
                })
            }
            function r(t, i, n, r, a) {
                var o, s = r[ln],
                u = t[hi](i),
                c = l[We](u.get(n[0]), a[dr]()),
                h = l[We](u.get(n[1]), a[hr]());
                if (isNaN(c) || isNaN(h)) {
                    if (r.getMarkerPosition) o = r.getMarkerPosition(t.getValues(n, i));
                    else {
                        var d = t.get(n[0], i),
                        f = t.get(n[1], i);
                        o = s[ae]([d, f], !0)
                    }
                    if (s.type === q) {
                        var p = s[J]("x"),
                        v = s[J]("y"),
                        d = t.get(n[0], i),
                        f = t.get(n[1], i);
                        e(d) ? o[0] = p[U](p[Fi]()["x0" === n[0] ? 0 : 1]) : e(f) && (o[1] = v[U](v[Fi]()["y0" === n[1] ? 0 : 1]))
                    }
                    isNaN(c) || (o[0] = c),
                    isNaN(h) || (o[1] = h)
                } else o = [c, h];
                return o
            }
            function a(t, e, i) {
                var r, a, l = ["x0", "y0", "x1", "y1"];
                t ? (r = o.map(t && t[de],
                function(t) {
                    var i = e[Kn]().getDimensionInfo(e[j](t)[0]) || {};
                    return i.name = t,
                    i
                }), a = new s(o.map(l,
                function(t, e) {
                    return {
                        name: t,
                        type: r[e % 2].type
                    }
                }), i)) : (r = [{
                    name: "value",
                    type: "float"
                }], a = new s(r, i));
                var u = o.map(i.get("data"), o.curry(d, e, t, i));
                t && (u = o[mn](u, o.curry(n, t)));
                var c = t ?
                function(t, e, i, n) {
                    return t.coord[Math.floor(n / 2)][n % 2]
                }: function(t) {
                    return t.value
                };
                return a[Di](u, null, c),
                a[fe] = !0,
                a
            }
            var o = t(Ar),
            s = t(Gi),
            l = t(qe),
            u = t(Si),
            c = t(Mr),
            h = t("./markerHelper"),
            d = function(t, e, i, n) {
                var r = h.dataTransform(t, n[0]),
                a = h.dataTransform(t, n[1]),
                s = o[vi],
                l = r.coord,
                u = a.coord;
                l[0] = s(l[0], -1 / 0),
                l[1] = s(l[1], -1 / 0),
                u[0] = s(u[0], 1 / 0),
                u[1] = s(u[1], 1 / 0);
                var c = o.mergeAll([{},
                r, a]);
                return c.coord = [r.coord, a.coord],
                c.x0 = r.x,
                c.y0 = r.y,
                c.x1 = a.x,
                c.y1 = a.y,
                c
            },
            f = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
            t("./MarkerView")[jn]({
                type: "markArea",
                updateLayout: function(t, e, i) {
                    e[tr](function(t) {
                        var e = t.markAreaModel;
                        if (e) {
                            var n = e[Kn]();
                            n.each(function(e) {
                                var a = o.map(f,
                                function(a) {
                                    return r(n, e, a, t, i)
                                });
                                n[He](e, a);
                                var s = n[Mi](e);
                                s[ci](z, a)
                            })
                        }
                    },
                    this)
                },
                renderSeries: function(t, e, i, n) {
                    var s = t[ln],
                    l = t.name,
                    h = t[Kn](),
                    d = this.markerGroupMap,
                    p = d[l];
                    p || (p = d[l] = {
                        group: new u.Group
                    }),
                    this.group.add(p.group),
                    p.__keep = !0;
                    var v = a(s, t, e);
                    e.setData(v),
                    v.each(function(e) {
                        v[He](e, o.map(f,
                        function(i) {
                            return r(v, e, i, t, n)
                        })),
                        v[Ue](e, {
                            color: h[ce]("color")
                        })
                    }),
                    v.diff(p.__data).add(function(t) {
                        var e = new u[we]({
                            shape: {
                                points: v[bi](t)
                            }
                        });
                        v[$e](t, e),
                        p.group.add(e)
                    })[er](function(t, i) {
                        var n = p.__data[Mi](i);
                        u[ui](n, {
                            shape: {
                                points: v[bi](t)
                            }
                        },
                        e, t),
                        p.group.add(n),
                        v[$e](t, n)
                    })[Xn](function(t) {
                        var e = p.__data[Mi](t);
                        p.group[Xn](e)
                    })[Qe](),
                    v[Se](function(t, i) {
                        var n = v[hi](i),
                        r = n[fr](ii),
                        a = n[fr](ei),
                        s = v[gi](i, "color");
                        t[si](o[qn](n[fr](F)[sn](), {
                            fill: c.modifyAlpha(s, .4),
                            stroke: s
                        })),
                        t[oi] = n[fr](F)[sn]();
                        var l = v[Ci](i) || "",
                        h = s || t.style.fill;
                        u[me](t.style, r, h),
                        t.style.text = o[vi](e[pi](i, ki), l),
                        u[me](t[oi], a, h),
                        t[oi].text = o[vi](e[pi](i, Li), l),
                        u[ri](t, {}),
                        t.dataModel = e
                    }),
                    p.__data = v,
                    p.group[Nn] = e.get(Nn) || t.get(Nn)
                }
            })
        }),
        e("echarts/component/timeline/preprocessor", [Tr, Ar],
        function(t) {
            function e(t) {
                var e = t.type,
                a = {
                    number: "value",
                    time: "time"
                };
                if (a[e] && (t.axisType = a[e], delete t.type), i(t), n(t, "controlPosition")) {
                    var o = t.controlStyle || (t.controlStyle = {});
                    n(o, $i) || (o[$i] = t.controlPosition),
                    "none" !== o[$i] || n(o, "show") || (o.show = !1, delete o[$i]),
                    delete t.controlPosition
                }
                r.each(t.data || [],
                function(t) {
                    r[Yn](t) && !r[An](t) && (!n(t, "value") && n(t, "name") && (t.value = t.name), i(t))
                })
            }
            function i(t) {
                var e = t[li] || (t[li] = {}),
                i = e[Li] || (e[Li] = {}),
                a = t.label || t.label || {},
                o = a[ki] || (a[ki] = {}),
                s = {
                    normal: 1,
                    emphasis: 1
                };
                r.each(a,
                function(t, e) {
                    s[e] || n(o, e) || (o[e] = t)
                }),
                i.label && !n(a, Li) && (a[Li] = i.label, delete i.label)
            }
            function n(t, e) {
                return t.hasOwnProperty(e)
            }
            var r = t(Ar);
            return function(t) {
                var i = t && t.timeline;
                r[An](i) || (i = i ? [i] : []),
                r.each(i,
                function(t) {
                    t && e(t)
                })
            }
        }),
        e("echarts/component/timeline/typeDefaulter", [Tr, c],
        function(t) {
            t(c).registerSubTypeDefaulter("timeline",
            function() {
                return "slider"
            })
        }),
        e("echarts/component/timeline/timelineAction", [Tr, Ei],
        function(t) {
            var e = t(Ei);
            e[Mn]({
                type: "timelineChange",
                event: "timelineChanged",
                update: "prepareAndUpdate"
            },
            function(t, e) {
                var i = e[Re]("timeline");
                i && null != t.currentIndex && (i.setCurrentIndex(t.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.setPlayState(!1)),
                e.resetOption("timeline")
            }),
            e[Mn]({
                type: "timelinePlayChange",
                event: "timelinePlayChanged",
                update: "update"
            },
            function(t, e) {
                var i = e[Re]("timeline");
                i && null != t.playState && i.setPlayState(t.playState)
            })
        }),
        e("echarts/component/timeline/SliderTimelineModel", [Tr, "./TimelineModel", Ar, Bi],
        function(t) {
            var e = t("./TimelineModel"),
            i = t(Ar),
            n = t(Bi),
            r = e[jn]({
                type: "timeline.slider",
                defaultOption: {
                    backgroundColor: "rgba(0,0,0,0)",
                    borderColor: "#ccc",
                    borderWidth: 0,
                    orient: "horizontal",
                    inverse: !1,
                    tooltip: {
                        trigger: "item"
                    },
                    symbol: "emptyCircle",
                    symbolSize: 10,
                    lineStyle: {
                        show: !0,
                        width: 2,
                        color: "#304654"
                    },
                    label: {
                        position: "auto",
                        normal: {
                            show: !0,
                            interval: "auto",
                            rotate: 0,
                            textStyle: {
                                color: "#304654"
                            }
                        },
                        emphasis: {
                            show: !0,
                            textStyle: {
                                color: "#c23531"
                            }
                        }
                    },
                    itemStyle: {
                        normal: {
                            color: "#304654",
                            borderWidth: 1
                        },
                        emphasis: {
                            color: "#c23531"
                        }
                    },
                    checkpointStyle: {
                        symbol: "circle",
                        symbolSize: 13,
                        color: "#c23531",
                        borderWidth: 5,
                        borderColor: "rgba(194,53,49, 0.5)",
                        animation: !0,
                        animationDuration: 300,
                        animationEasing: "quinticInOut"
                    },
                    controlStyle: {
                        show: !0,
                        showPlayBtn: !0,
                        showPrevBtn: !0,
                        showNextBtn: !0,
                        itemSize: 22,
                        itemGap: 12,
                        position: "left",
                        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
                        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
                        nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z",
                        prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z",
                        normal: {
                            color: "#304654",
                            borderColor: "#304654",
                            borderWidth: 1
                        },
                        emphasis: {
                            color: "#c23531",
                            borderColor: "#c23531",
                            borderWidth: 2
                        }
                    },
                    data: []
                }
            });
            return i.mixin(r, n.dataFormatMixin),
            r
        }),
        e("echarts/component/dataZoom/typeDefaulter", [Tr, c],
        function(t) {
            t(c).registerSubTypeDefaulter("dataZoom",
            function() {
                return "slider"
            })
        }),
        e("echarts/component/timeline/SliderTimelineView", [Tr, Ar, Si, re, "./TimelineView", "./TimelineAxis", I, "../../coord/axisHelper", Me, br, qe, G],
        function(t) {
            function e(t, e) {
                return c[Ki](t[tn](), {
                    width: e[dr](),
                    height: e[hr]()
                },
                t.get("padding"))
            }
            function i(t, e, i, n) {
                var r = u.makePath(t.get(e)[Tn](/^path:\/\//, ""), a.clone(n || {}), new g(i[0], i[1], i[2], i[3]), Ji);
                return r
            }
            function n(t, e, i, n, r, o) {
                var s = t.get(se),
                l = e.get("color"),
                u = t.get(oe),
                c = u / 2,
                h = e[sn](["color", se, oe]);
                return r ? (r[Ln](h), r.setColor(l), i.add(r), o && o.onUpdate(r)) : (r = f[P](s, -c, -c, u, u, l), i.add(r), o && o.onCreate(r)),
                n = a.merge({
                    rectHover: !0,
                    style: h,
                    z2: 100
                },
                n, !0),
                r.attr(n),
                r
            }
            function r(t, e, i, n, r) {
                if (!t.dragging) {
                    var a = n[fr]("checkpointStyle"),
                    o = i[B](n[Kn]().get(["value"], e));
                    r || !a.get(vr, !0) ? t.attr({
                        position: [o, 0]
                    }) : (t[sr](!0), t.animateTo({
                        position: [o, 0]
                    },
                    a.get("animationDuration", !0), a.get("animationEasing", !0)))
                }
            }
            var a = t(Ar),
            u = t(Si),
            c = t(re),
            h = t("./TimelineView"),
            d = t("./TimelineAxis"),
            f = t(I),
            p = t("../../coord/axisHelper"),
            g = t(Me),
            m = t(br),
            y = t(qe),
            x = t(G),
            b = x[Ve],
            M = a.bind,
            A = a.each,
            T = Math.PI;
            return h[jn]({
                type: "timeline.slider",
                init: function(t, e) {
                    this.api = e,
                    this._axis,
                    this._viewRect,
                    this._timer,
                    this._currentPointer,
                    this._mainGroup,
                    this._labelGroup
                },
                render: function(t, e, i) {
                    if (this.model = t, this.api = i, this[Te] = e, this.group[cn](), t.get("show", !0)) {
                        var n = this._layout(t, i),
                        r = this._createGroup("mainGroup"),
                        a = this._createGroup("labelGroup"),
                        o = this._axis = this._createAxis(n, t);
                        t.formatTooltip = function(t) {
                            return b(o.scale[Wi](t))
                        },
                        A(["AxisLine", "AxisTick", "Control", "CurrentPointer"],
                        function(e) {
                            this["_render" + e](n, r, o, t)
                        },
                        this),
                        this._renderAxisLabel(n, a, o, t),
                        this._position(n, t)
                    }
                    this._doPlayStop()
                },
                remove: function() {
                    this._clearTimer(),
                    this.group[cn]()
                },
                dispose: function() {
                    this._clearTimer()
                },
                _layout: function(t, i) {
                    var n = t.get("label.normal.position"),
                    r = t.get(l),
                    a = e(t, i);
                    null == n || "auto" === n ? n = r === O ? a.y + a[nr] / 2 < i[hr]() / 2 ? "-": "+": a.x + a.width / 2 < i[dr]() / 2 ? "+": "-": isNaN(n) && (n = {
                        horizontal: {
                            top: "-",
                            bottom: "+"
                        },
                        vertical: {
                            left: "-",
                            right: "+"
                        }
                    } [r][n]);
                    var o = {
                        horizontal: "center",
                        vertical: n >= 0 || "+" === n ? "left": "right"
                    },
                    u = {
                        horizontal: n >= 0 || "+" === n ? "top": rr,
                        vertical: "middle"
                    },
                    c = {
                        horizontal: 0,
                        vertical: T / 2
                    },
                    h = r === s ? a[nr] : a.width,
                    d = t[fr]("controlStyle"),
                    f = d.get("show"),
                    p = f ? d.get("itemSize") : 0,
                    v = f ? d.get("itemGap") : 0,
                    g = p + v,
                    m = t.get("label.normal.rotate") || 0;
                    m = m * T / 180;
                    var y, x, _, w, b = d.get($i, !0),
                    f = d.get("show", !0),
                    M = f && d.get("showPlayBtn", !0),
                    A = f && d.get("showPrevBtn", !0),
                    C = f && d.get("showNextBtn", !0),
                    L = 0,
                    k = h;
                    return "left" === b || b === rr ? (M && (y = [0, 0], L += g), A && (x = [L, 0], L += g), C && (_ = [k - p, 0], k -= g)) : (M && (y = [k - p, 0], k -= g), A && (x = [0, 0], L += g), C && (_ = [k - p, 0], k -= g)),
                    w = [L, k],
                    t.get(Q) && w[S](),
                    {
                        viewRect: a,
                        mainLength: h,
                        orient: r,
                        rotation: c[r],
                        labelRotation: m,
                        labelPosOpt: n,
                        labelAlign: o[r],
                        labelBaseline: u[r],
                        playPosition: y,
                        prevBtnPosition: x,
                        nextBtnPosition: _,
                        axisExtent: w,
                        controlSize: p,
                        controlGap: v
                    }
                },
                _position: function(t) {
                    function e(t) {
                        var e = t[$i];
                        t.origin = [f[0][0] - e[0], f[1][0] - e[1]]
                    }
                    function i(t) {
                        return [[t.x, t.x + t.width], [t.y, t.y + t[nr]]]
                    }
                    function n(t, e, i, n, r) {
                        t[n] += i[n][r] - e[n][r]
                    }
                    var r = this._mainGroup,
                    a = this._labelGroup,
                    u = t.viewRect;
                    if (t[l] === s) {
                        var c = m[ir](),
                        h = u.x,
                        d = u.y + u[nr];
                        m.translate(c, c, [ - h, -d]),
                        m[o](c, c, -T / 2),
                        m.translate(c, c, [h, d]),
                        u = u.clone(),
                        u[_e](c)
                    }
                    var f = i(u),
                    p = i(r[en]()),
                    v = i(a[en]()),
                    g = r[$i],
                    y = a[$i];
                    y[0] = g[0] = f[0][0];
                    var x = t.labelPosOpt;
                    if (isNaN(x)) {
                        var _ = "+" === x ? 0 : 1;
                        n(g, p, f, 1, _),
                        n(y, v, f, 1, 1 - _)
                    } else {
                        var _ = x >= 0 ? 0 : 1;
                        n(g, p, f, 1, _),
                        y[1] = g[1] + x
                    }
                    r.attr($i, g),
                    a.attr($i, y),
                    r[ni] = a[ni] = t[ni],
                    e(r),
                    e(a)
                },
                _createAxis: function(t, e) {
                    var i = e[Kn](),
                    n = e.get("axisType"),
                    r = p[$](e, n),
                    a = i[Fe]("value");
                    r[Zi](a[0], a[1]),
                    this._customizeScale(r, i),
                    r.niceTicks();
                    var o = new d("value", r, t.axisExtent, n);
                    return o.model = e,
                    o
                },
                _customizeScale: function(t, e) {
                    t[qi] = function() {
                        return e[he](["value"],
                        function(t) {
                            return t
                        })
                    },
                    t.getTicksLabels = function() {
                        return a.map(this[qi](), t[Wi], t)
                    }
                },
                _createGroup: function(t) {
                    var e = this["_" + t] = new u.Group;
                    return this.group.add(e),
                    e
                },
                _renderAxisLine: function(t, e, i, n) {
                    var r = i[Fi]();
                    n.get("lineStyle.show") && e.add(new u.Line({
                        shape: {
                            x1: r[0],
                            y1: 0,
                            x2: r[1],
                            y2: 0
                        },
                        style: a[jn]({
                            lineCap: "round"
                        },
                        n[fr](Ke)[ti]()),
                        silent: !0,
                        z2: 1
                    }))
                },
                _renderAxisTick: function(t, e, i, r) {
                    var a = r[Kn](),
                    o = i.scale[qi]();
                    A(o,
                    function(t, o) {
                        var s = i[B](t),
                        l = a[hi](o),
                        c = l[fr](F),
                        h = l[fr](H),
                        d = {
                            position: [s, 0],
                            onclick: M(this._changeTimeline, this, o)
                        },
                        f = n(l, c, e, d);
                        u[ri](f, h[sn]()),
                        l.get("tooltip") ? (f[zn] = o, f.dataModel = r) : f[zn] = f.dataModel = null
                    },
                    this)
                },
                _renderAxisLabel: function(t, e, i, n) {
                    var r = n[fr](ii);
                    if (r.get("show")) {
                        var a = n[Kn](),
                        o = i.scale[qi](),
                        s = p[ee](i, r.get(v)),
                        l = i.getLabelInterval();
                        A(o,
                        function(n, r) {
                            if (!i.isLabelIgnored(r, l)) {
                                var o = a[hi](r),
                                c = o[fr]("label.normal.textStyle"),
                                h = o[fr]("label.emphasis.textStyle"),
                                d = i[B](n),
                                f = new u.Text({
                                    style: {
                                        text: s[r],
                                        textAlign: t.labelAlign,
                                        textVerticalAlign: t.labelBaseline,
                                        textFont: c[rn](),
                                        fill: c[nn]()
                                    },
                                    position: [d, 0],
                                    rotation: t.labelRotation - t[ni],
                                    onclick: M(this._changeTimeline, this, r),
                                    silent: !1
                                });
                                e.add(f),
                                u[ri](f, h[sn]())
                            }
                        },
                        this)
                    }
                },
                _renderControl: function(t, e, n, r) {
                    function a(t, n, a, d) {
                        if (t) {
                            var f = {
                                position: t,
                                origin: [o / 2, 0],
                                rotation: d ? -s: 0,
                                rectHover: !0,
                                style: l,
                                onclick: a
                            },
                            p = i(r, n, h, f);
                            e.add(p),
                            u[ri](p, c)
                        }
                    }
                    var o = t.controlSize,
                    s = t[ni],
                    l = r[fr]("controlStyle.normal")[sn](),
                    c = r[fr]("controlStyle.emphasis")[sn](),
                    h = [0, -o / 2, o, o],
                    d = r.getPlayState(),
                    f = r.get(Q, !0);
                    a(t.nextBtnPosition, "controlStyle.nextIcon", M(this._changeTimeline, this, f ? "-": "+")),
                    a(t.prevBtnPosition, "controlStyle.prevIcon", M(this._changeTimeline, this, f ? "+": "-")),
                    a(t.playPosition, "controlStyle." + (d ? "stopIcon": "playIcon"), M(this._handlePlayClick, this, !d), !0)
                },
                _renderCurrentPointer: function(t, e, i, a) {
                    var o = a[Kn](),
                    s = a.getCurrentIndex(),
                    l = o[hi](s)[fr]("checkpointStyle"),
                    u = this,
                    c = {
                        onCreate: function(t) {
                            t[L] = !0,
                            t.drift = M(u._handlePointerDrag, u),
                            t.ondragend = M(u._handlePointerDragend, u),
                            r(t, s, i, a, !0)
                        },
                        onUpdate: function(t) {
                            r(t, s, i, a)
                        }
                    };
                    this._currentPointer = n(l, l, this._mainGroup, {},
                    this._currentPointer, c)
                },
                _handlePlayClick: function(t) {
                    this._clearTimer(),
                    this.api[Un]({
                        type: "timelinePlayChange",
                        playState: t,
                        from: this.uid
                    })
                },
                _handlePointerDrag: function(t, e, i) {
                    this._clearTimer(),
                    this._pointerChangeTimeline([i[w], i[_]])
                },
                _handlePointerDragend: function(t) {
                    this._pointerChangeTimeline([t[w], t[_]], !0)
                },
                _pointerChangeTimeline: function(t, e) {
                    var i = this._toAxisCoord(t)[0],
                    n = this._axis,
                    r = y.asc(n[Fi]().slice());
                    i > r[1] && (i = r[1]),
                    i < r[0] && (i = r[0]),
                    this._currentPointer[$i][0] = i,
                    this._currentPointer.dirty();
                    var a = this._findNearestTick(i),
                    o = this.model; (e || a !== o.getCurrentIndex() && o.get("realtime")) && this._changeTimeline(a)
                },
                _doPlayStop: function() {
                    function t() {
                        var t = this.model;
                        this._changeTimeline(t.getCurrentIndex() + (t.get("rewind", !0) ? -1 : 1))
                    }
                    this._clearTimer(),
                    this.model.getPlayState() && (this._timer = setTimeout(M(t, this), this.model.get("playInterval")))
                },
                _toAxisCoord: function(t) {
                    var e = this._mainGroup[ve]();
                    return u[_e](t, e, !0)
                },
                _findNearestTick: function(t) {
                    var e, i = this.model[Kn](),
                    n = 1 / 0,
                    r = this._axis;
                    return i.each(["value"],
                    function(i, a) {
                        var o = r[B](i),
                        s = Math.abs(o - t);
                        n > s && (n = s, e = a)
                    }),
                    e
                },
                _clearTimer: function() {
                    this._timer && (clearTimeout(this._timer), this._timer = null)
                },
                _changeTimeline: function(t) {
                    var e = this.model.getCurrentIndex();
                    "+" === t ? t = e + 1 : "-" === t && (t = e - 1),
                    this.api[Un]({
                        type: "timelineChange",
                        currentIndex: t,
                        from: this.uid
                    })
                }
            })
        }),
        e("echarts/component/dataZoom/DataZoomModel", [Tr, Ar, Sr, Ei, Bi, "./helper", "./AxisProxy"],
        function(t) {
            function e(t) {
                var e = {};
                return h(["start", "end", "startValue", "endValue", "throttle"],
                function(i) {
                    t.hasOwnProperty(i) && (e[i] = t[i])
                }),
                e
            }
            function i(t, e, i, n) {
                null != i[e] && null == i[t] && (n[t] = null)
            }
            var n = t(Ar),
            r = t(Sr),
            a = t(Ei),
            o = t(Bi),
            u = t("./helper"),
            c = t("./AxisProxy"),
            h = n.each,
            d = u.eachAxisDim,
            f = a[wn]({
                type: "dataZoom",
                dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", Fn],
                defaultOption: {
                    zlevel: 0,
                    z: 4,
                    orient: null,
                    xAxisIndex: null,
                    yAxisIndex: null,
                    filterMode: "filter",
                    throttle: null,
                    start: 0,
                    end: 100,
                    startValue: null,
                    endValue: null
                },
                init: function(t, i, n) {
                    this._dataIntervalByAxis = {},
                    this._dataInfo = {},
                    this._axisProxies = {},
                    this.textStyleModel,
                    this._autoThrottle = !0;
                    var r = e(t);
                    this[De](t, n),
                    this.doInit(r)
                },
                mergeOption: function(t) {
                    var i = e(t);
                    n.merge(this[zi], t, !0),
                    this.doInit(i)
                },
                doInit: function(t) {
                    var e = this[zi];
                    r[cr] || (e.realtime = !1),
                    this._setDefaultThrottle(t),
                    i("start", "startValue", t, e),
                    i("end", "endValue", t, e),
                    this.textStyleModel = this[fr](on),
                    this._resetTarget(),
                    this._giveAxisProxies()
                },
                _giveAxisProxies: function() {
                    var t = this._axisProxies;
                    this.eachTargetAxis(function(e, i, n, r) {
                        var a = this.dependentModels[e.axis][i],
                        o = a.__dzAxisProxy || (a.__dzAxisProxy = new c(e.name, i, this, r));
                        t[e.name + "_" + i] = o
                    },
                    this)
                },
                _resetTarget: function() {
                    var t = this[zi],
                    e = this._judgeAutoMode();
                    d(function(e) {
                        var i = e.axisIndex;
                        t[i] = o.normalizeToArray(t[i])
                    },
                    this),
                    "axisIndex" === e ? this._autoSetAxisIndex() : e === l && this._autoSetOrient()
                },
                _judgeAutoMode: function() {
                    var t = this[zi],
                    e = !1;
                    d(function(i) {
                        null != t[i.axisIndex] && (e = !0)
                    },
                    this);
                    var i = t[l];
                    return null == i && e ? l: e ? void 0 : (null == i && (t[l] = O), "axisIndex")
                },
                _autoSetAxisIndex: function() {
                    var t = !0,
                    e = this.get(l, !0),
                    i = this[zi];
                    if (t) {
                        var r = e === s ? {
                            dim: "y",
                            axisIndex: "yAxisIndex",
                            axis: "yAxis"
                        }: {
                            dim: "x",
                            axisIndex: "xAxisIndex",
                            axis: "xAxis"
                        };
                        this.dependentModels[r.axis][Wn] && (i[r.axisIndex] = [0], t = !1)
                    }
                    t && d(function(e) {
                        if (t) {
                            var n = [],
                            r = this.dependentModels[e.axis];
                            if (r[Wn] && !n[Wn]) for (var a = 0,
                            o = r[Wn]; o > a; a++) r[a].get("type") === te && n.push(a);
                            i[e.axisIndex] = n,
                            n[Wn] && (t = !1)
                        }
                    },
                    this),
                    t && this[Te][tr](function(t) {
                        this._isSeriesHasAllAxesTypeOf(t, "value") && d(function(e) {
                            var r = i[e.axisIndex],
                            a = t.get(e.axisIndex),
                            o = t.get(e.axisId),
                            s = t[Te][Ee]({
                                mainType: e.axis,
                                index: a,
                                id: o
                            })[0];
                            a = s[Oe],
                            n[gn](r, a) < 0 && r.push(a)
                        })
                    },
                    this)
                },
                _autoSetOrient: function() {
                    var t;
                    this.eachTargetAxis(function(e) { ! t && (t = e.name)
                    },
                    this),
                    this[zi][l] = "y" === t ? s: O
                },
                _isSeriesHasAllAxesTypeOf: function(t, e) {
                    var i = !0;
                    return d(function(n) {
                        var r = t.get(n.axisIndex),
                        a = this.dependentModels[n.axis][r];
                        a && a.get("type") === e || (i = !1)
                    },
                    this),
                    i
                },
                _setDefaultThrottle: function(t) {
                    if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
                        var e = this[Te][zi];
                        this[zi].throttle = e[vr] && e.animationDurationUpdate > 0 ? 100 : 20
                    }
                },
                getFirstTargetAxisModel: function() {
                    var t;
                    return d(function(e) {
                        if (null == t) {
                            var i = this.get(e.axisIndex);
                            i[Wn] && (t = this.dependentModels[e.axis][i[0]])
                        }
                    },
                    this),
                    t
                },
                eachTargetAxis: function(t, e) {
                    var i = this[Te];
                    d(function(n) {
                        h(this.get(n.axisIndex),
                        function(r) {
                            t.call(e, n, r, this, i)
                        },
                        this)
                    },
                    this)
                },
                getAxisProxy: function(t, e) {
                    return this._axisProxies[t + "_" + e]
                },
                setRawRange: function(t) {
                    h(["start", "end", "startValue", "endValue"],
                    function(e) {
                        this[zi][e] = t[e]
                    },
                    this)
                },
                getPercentRange: function() {
                    var t = this.findRepresentativeAxisProxy();
                    return t ? t.getDataPercentWindow() : void 0
                },
                getValueRange: function(t, e) {
                    if (null != t || null != e) return this.getAxisProxy(t, e).getDataValueWindow();
                    var i = this.findRepresentativeAxisProxy();
                    return i ? i.getDataValueWindow() : void 0
                },
                findRepresentativeAxisProxy: function() {
                    var t = this._axisProxies;
                    for (var e in t) if (t.hasOwnProperty(e) && t[e].hostedBy(this)) return t[e];
                    for (var e in t) if (t.hasOwnProperty(e) && !t[e].hostedBy(this)) return t[e]
                }
            });
            return f
        }),
        e("echarts/component/dataZoom/DataZoomView", [Tr, "../../view/Component"],
        function(t) {
            var e = t("../../view/Component");
            return e[jn]({
                type: "dataZoom",
                render: function(t, e, i) {
                    this.dataZoomModel = t,
                    this[Te] = e,
                    this.api = i
                },
                getTargetInfo: function() {
                    function t(t, e, i, n) {
                        for (var r, a = 0; a < i[Wn]; a++) if (i[a].model === t) {
                            r = i[a];
                            break
                        }
                        r || i.push(r = {
                            model: t,
                            axisModels: [],
                            coordIndex: n
                        }),
                        r.axisModels.push(e)
                    }
                    var e = this.dataZoomModel,
                    i = this[Te],
                    n = [],
                    r = [],
                    a = [];
                    return e.eachTargetAxis(function(e, o) {
                        var s = i[Re](e.axis, o);
                        if (s) {
                            a.push(s);
                            var l;
                            l = "xAxis" === e.axis || "yAxis" === e.axis ? "grid": "polar";
                            var u = i[Ee]({
                                mainType: l,
                                index: s.get(l + "Index"),
                                id: s.get(l + "Id")
                            })[0];
                            null != u && t(u, s, "grid" === l ? n: r, u[Oe])
                        }
                    },
                    this),
                    {
                        cartesians: n,
                        polars: r,
                        axisModels: a
                    }
                }
            })
        }),
        e("echarts/component/dataZoom/SliderZoomModel", [Tr, "./DataZoomModel"],
        function(t) {
            var e = t("./DataZoomModel"),
            i = e[jn]({
                type: "dataZoom.slider",
                layoutMode: "box",
                defaultOption: {
                    show: !0,
                    right: "ph",
                    top: "ph",
                    width: "ph",
                    height: "ph",
                    left: null,
                    bottom: null,
                    backgroundColor: "rgba(47,69,84,0)",
                    dataBackground: {
                        lineStyle: {
                            color: "#2f4554",
                            width: .5,
                            opacity: .3
                        },
                        areaStyle: {
                            color: "rgba(47,69,84,0.3)",
                            opacity: .3
                        }
                    },
                    borderColor: "#ddd",
                    fillerColor: "rgba(167,183,204,0.4)",
                    handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z",
                    handleSize: "100%",
                    handleStyle: {
                        color: "#a7b7cc"
                    },
                    labelPrecision: null,
                    labelFormatter: null,
                    showDetail: !0,
                    showDataShadow: "auto",
                    realtime: !0,
                    zoomLock: !1,
                    textStyle: {
                        color: "#333"
                    }
                }
            });
            return i
        }),
        e("echarts/component/dataZoom/SliderZoomView", [Tr, Ar, Si, "../../util/throttle", "./DataZoomView", qe, re, "../helper/sliderMove"],
        function(t) {
            function e(t) {
                return "x" === t ? "y": "x"
            }
            var i = t(Ar),
            n = t(Si),
            r = t("../../util/throttle"),
            a = t("./DataZoomView"),
            o = n.Rect,
            u = t(qe),
            c = u[Ge],
            h = t(re),
            d = t("../helper/sliderMove"),
            f = u.asc,
            p = i.bind,
            v = i.each,
            g = 7,
            m = 1,
            y = 30,
            x = O,
            _ = s,
            w = 5,
            b = ["line", "bar", "candlestick", "scatter"],
            A = a[jn]({
                type: "dataZoom.slider",
                init: function(t, e) {
                    this._displayables = {},
                    this._orient,
                    this._range,
                    this._handleEnds,
                    this._size,
                    this._handleWidth,
                    this._handleHeight,
                    this._location,
                    this._dragging,
                    this._dataShadowInfo,
                    this.api = e
                },
                render: function(t, e, i, n) {
                    return A[Oi](this, Bn, arguments),
                    r.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"),
                    this._orient = t.get(l),
                    this.dataZoomModel.get("show") === !1 ? void this.group[cn]() : (n && "dataZoom" === n.type && n.from === this.uid || this._buildView(), void this._updateView())
                },
                remove: function() {
                    A[Oi](this, Xn, arguments),
                    r.clear(this, "_dispatchZoomAction")
                },
                dispose: function() {
                    A[Oi](this, Hn, arguments),
                    r.clear(this, "_dispatchZoomAction")
                },
                _buildView: function() {
                    var t = this.group;
                    t[cn](),
                    this._resetLocation(),
                    this._resetInterval();
                    var e = this._displayables.barGroup = new n.Group;
                    this._renderBackground(),
                    this._renderHandle(),
                    this._renderDataShadow(),
                    t.add(e),
                    this._positionGroup()
                },
                _resetLocation: function() {
                    var t = this.dataZoomModel,
                    e = this.api,
                    n = this._findCoordRect(),
                    r = {
                        width: e[dr](),
                        height: e[hr]()
                    },
                    a = this._orient === x ? {
                        right: r.width - n.x - n.width,
                        top: r[nr] - y - g,
                        width: n.width,
                        height: y
                    }: {
                        right: g,
                        top: n.y,
                        width: y,
                        height: n[nr]
                    },
                    o = h.getLayoutParams(t[zi]);
                    i.each(["right", "top", "width", nr],
                    function(t) {
                        "ph" === o[t] && (o[t] = a[t])
                    });
                    var s = h[Ki](o, r, t.padding);
                    this._location = {
                        x: s.x,
                        y: s.y
                    },
                    this._size = [s.width, s[nr]],
                    this._orient === _ && this._size[S]()
                },
                _positionGroup: function() {
                    var t = this.group,
                    e = this._location,
                    i = this._orient,
                    n = this.dataZoomModel.getFirstTargetAxisModel(),
                    r = n && n.get(Q),
                    a = this._displayables.barGroup,
                    o = (this._dataShadowInfo || {}).otherAxisInverse;
                    a.attr(i !== x || r ? i === x && r ? {
                        scale: o ? [ - 1, 1] : [ - 1, -1]
                    }: i !== _ || r ? {
                        scale: o ? [ - 1, -1] : [ - 1, 1],
                        rotation: Math.PI / 2
                    }: {
                        scale: o ? [1, -1] : [1, 1],
                        rotation: Math.PI / 2
                    }: {
                        scale: o ? [1, 1] : [1, -1]
                    });
                    var s = t[en]([a]);
                    t.attr($i, [e.x - s.x, e.y - s.y])
                },
                _getViewExtent: function() {
                    return [0, this._size[0]]
                },
                _renderBackground: function() {
                    var t = this.dataZoomModel,
                    e = this._size;
                    this._displayables.barGroup.add(new o({
                        silent: !0,
                        shape: {
                            x: 0,
                            y: 0,
                            width: e[0],
                            height: e[1]
                        },
                        style: {
                            fill: t.get(ur)
                        },
                        z2: -40
                    }))
                },
                _renderDataShadow: function() {
                    var t = this._dataShadowInfo = this._prepareDataShadowInfo();
                    if (t) {
                        var e = this._size,
                        r = t[Fn],
                        a = r.getRawData(),
                        o = r.getShadowDim ? r.getShadowDim() : t.otherDim,
                        s = a[Fe](o),
                        l = .3 * (s[1] - s[0]);
                        s = [s[0] - l, s[1] + l];
                        var u = [0, e[1]],
                        h = [0, e[0]],
                        d = [[e[0], 0], [0, 0]],
                        f = [],
                        p = h[1] / (a.count() - 1),
                        v = 0,
                        g = Math.round(a.count() / e[0]);
                        a.each([o],
                        function(t, e) {
                            if (g > 0 && e % g) return void(v += p);
                            var i = null == t || isNaN(t) || "" === t ? null: c(t, s, u, !0);
                            null != i && (d.push([v, i]), f.push([v, i])),
                            v += p
                        });
                        var m = this.dataZoomModel;
                        this._displayables.barGroup.add(new n[we]({
                            shape: {
                                points: d
                            },
                            style: i[qn]({
                                fill: m.get("dataBackgroundColor")
                            },
                            m[fr]("dataBackground.areaStyle")[V]()),
                            silent: !0,
                            z2: -20
                        })),
                        this._displayables.barGroup.add(new n[xi]({
                            shape: {
                                points: f
                            },
                            style: m[fr]("dataBackground.lineStyle")[ti](),
                            silent: !0,
                            z2: -19
                        }))
                    }
                },
                _prepareDataShadowInfo: function() {
                    var t = this.dataZoomModel,
                    n = t.get("showDataShadow");
                    if (n !== !1) {
                        var r, a = this[Te];
                        return t.eachTargetAxis(function(o, s) {
                            var l = t.getAxisProxy(o.name, s).getTargetSeriesModels();
                            i.each(l,
                            function(t) {
                                if (! (r || n !== !0 && i[gn](b, t.get("type")) < 0)) {
                                    var l = e(o.name),
                                    u = a[Re](o.axis, s).axis;
                                    r = {
                                        thisAxis: u,
                                        series: t,
                                        thisDim: o.name,
                                        otherDim: l,
                                        otherAxisInverse: t[ln].getOtherAxis(u)[Q]
                                    }
                                }
                            },
                            this)
                        },
                        this),
                        r
                    }
                },
                _renderHandle: function() {
                    var t = this._displayables,
                    e = t.handles = [],
                    i = t.handleLabels = [],
                    r = this._displayables.barGroup,
                    a = this._size,
                    l = this.dataZoomModel;
                    r.add(t.filler = new o({
                        draggable: !0,
                        cursor: "move",
                        drift: p(this._onDragMove, this, "all"),
                        ondragstart: p(this._showDataInfo, this, !0),
                        ondragend: p(this._onDragEnd, this),
                        onmouseover: p(this._showDataInfo, this, !0),
                        onmouseout: p(this._showDataInfo, this, !1),
                        style: {
                            fill: l.get("fillerColor"),
                            textPosition: "inside"
                        }
                    })),
                    r.add(new o(n.subPixelOptimizeRect({
                        silent: !0,
                        shape: {
                            x: 0,
                            y: 0,
                            width: a[0],
                            height: a[1]
                        },
                        style: {
                            stroke: l.get("dataBackgroundColor") || l.get(N),
                            lineWidth: m,
                            fill: "rgba(0,0,0,0)"
                        }
                    })));
                    var c = l.get("handleIcon");
                    v([0, 1],
                    function(t) {
                        var a = n.makePath(c, {
                            style: {
                                strokeNoScale: !0
                            },
                            rectHover: !0,
                            cursor: this._orient === s ? "ns-resize": "ew-resize",
                            draggable: !0,
                            drift: p(this._onDragMove, this, t),
                            ondragend: p(this._onDragEnd, this),
                            onmouseover: p(this._showDataInfo, this, !0),
                            onmouseout: p(this._showDataInfo, this, !1)
                        },
                        {
                            x: -.5,
                            y: 0,
                            width: 1,
                            height: 1
                        },
                        Ji),
                        o = a[en]();
                        this._handleHeight = u[We](l.get("handleSize"), this._size[1]),
                        this._handleWidth = o.width / o[nr] * this._handleHeight,
                        a[Ln](l[fr]("handleStyle")[sn]());
                        var h = l.get("handleColor");
                        null != h && (a.style.fill = h),
                        r.add(e[t] = a);
                        var d = l.textStyleModel;
                        this.group.add(i[t] = new n.Text({
                            silent: !0,
                            invisible: !0,
                            style: {
                                x: 0,
                                y: 0,
                                text: "",
                                textVerticalAlign: "middle",
                                textAlign: "center",
                                fill: d[nn](),
                                textFont: d[rn]()
                            },
                            z2: 10
                        }))
                    },
                    this)
                },
                _resetInterval: function() {
                    var t = this._range = this.dataZoomModel.getPercentRange(),
                    e = this._getViewExtent();
                    this._handleEnds = [c(t[0], [0, 100], e, !0), c(t[1], [0, 100], e, !0)]
                },
                _updateInterval: function(t, e) {
                    var i = this._handleEnds,
                    n = this._getViewExtent();
                    d(e, i, n, "all" === t || this.dataZoomModel.get("zoomLock") ? "rigid": "cross", t),
                    this._range = f([c(i[0], n, [0, 100], !0), c(i[1], n, [0, 100], !0)])
                },
                _updateView: function() {
                    var t = this._displayables,
                    e = this._handleEnds,
                    i = f(e.slice()),
                    n = this._size;
                    v([0, 1],
                    function(i) {
                        var r = t.handles[i],
                        a = this._handleHeight;
                        r.attr({
                            scale: [a, a],
                            position: [e[i], n[1] / 2 - a / 2]
                        })
                    },
                    this),
                    t.filler[ci]({
                        x: i[0],
                        y: 0,
                        width: i[1] - i[0],
                        height: n[1]
                    }),
                    this._updateDataInfo()
                },
                _updateDataInfo: function() {
                    function t(t) {
                        var e = n.getTransform(i.handles[t][pe], this.group),
                        s = n.transformDirection(0 === t ? "right": "left", e),
                        l = this._handleWidth / 2 + w,
                        c = n[_e]([u[t] + (0 === t ? -l: l), this._size[1] / 2], e);
                        r[t][Ln]({
                            x: c[0],
                            y: c[1],
                            textVerticalAlign: a === x ? Qi: s,
                            textAlign: a === x ? s: Ji,
                            text: o[t]
                        })
                    }
                    var e = this.dataZoomModel,
                    i = this._displayables,
                    r = i.handleLabels,
                    a = this._orient,
                    o = ["", ""];
                    if (e.get("showDetail")) {
                        var s, l;
                        e.eachTargetAxis(function(t, i) {
                            s || (s = e.getAxisProxy(t.name, i).getDataValueWindow(), l = this[Te][Re](t.axis, i).axis)
                        },
                        this),
                        s && (o = [this._formatLabel(s[0], l), this._formatLabel(s[1], l)])
                    }
                    var u = f(this._handleEnds.slice());
                    t.call(this, 0),
                    t.call(this, 1)
                },
                _formatLabel: function(t, e) {
                    var n = this.dataZoomModel,
                    r = n.get("labelFormatter");
                    if (i.isFunction(r)) return r(t);
                    var a = n.get("labelPrecision");
                    return (null == a || "auto" === a) && (a = e.getPixelPrecision()),
                    t = null == t && isNaN(t) ? "": e.type === te || "time" === e.type ? e.scale[Wi](Math.round(t)) : t[Ii](Math.min(a, 20)),
                    i[pn](r) && (t = r[Tn]("{value}", t)),
                    t
                },
                _showDataInfo: function(t) {
                    t = this._dragging || t;
                    var e = this._displayables.handleLabels;
                    e[0].attr(M, !t),
                    e[1].attr(M, !t)
                },
                _onDragMove: function(t, e, i) {
                    this._dragging = !0;
                    var n = this._applyBarTransform([e, i], !0);
                    this._updateInterval(t, n[0]),
                    this._updateView(),
                    this.dataZoomModel.get("realtime") && this._dispatchZoomAction()
                },
                _onDragEnd: function() {
                    this._dragging = !1,
                    this._showDataInfo(!1),
                    this._dispatchZoomAction()
                },
                _dispatchZoomAction: function() {
                    var t = this._range;
                    this.api[Un]({
                        type: "dataZoom",
                        from: this.uid,
                        dataZoomId: this.dataZoomModel.id,
                        start: t[0],
                        end: t[1]
                    })
                },
                _applyBarTransform: function(t, e) {
                    var i = this._displayables.barGroup[ve]();
                    return n[_e](t, i, e)
                },
                _findCoordRect: function() {
                    var t, e = this.getTargetInfo();
                    if (e.cartesians[Wn]) t = e.cartesians[0].model[ln][un]();
                    else {
                        var i = this.api[dr](),
                        n = this.api[hr]();
                        t = {
                            x: .2 * i,
                            y: .2 * n,
                            width: .6 * i,
                            height: .6 * n
                        }
                    }
                    return t
                }
            });
            return A
        }),
        e("echarts/component/dataZoom/InsideZoomView", [Tr, "./DataZoomView", Ar, "../helper/sliderMove", "./roams"],
        function(t) {
            function e(t, e, i, r) {
                e = e.slice();
                var a = r.axisModels[0];
                if (a) {
                    var o = n(t, a, i),
                    l = o.signal * (e[1] - e[0]) * o.pixel / o.pixelLength;
                    return s(l, e, [0, 100], "rigid"),
                    e
                }
            }
            function i(t, e, i, a, o) {
                i = i.slice();
                var s = o.axisModels[0];
                if (s) {
                    var l = n(e, s, a),
                    u = l.pixel - l.pixelStart,
                    c = u / l.pixelLength * (i[1] - i[0]) + i[0];
                    return t = Math.max(t, 0),
                    i[0] = (i[0] - c) * t + c,
                    i[1] = (i[1] - c) * t + c,
                    r(i)
                }
            }
            function n(t, e, i) {
                var n = e.axis,
                r = i[T](),
                a = {};
                return "x" === n.dim ? (a.pixel = t[0], a.pixelLength = r.width, a.pixelStart = r.x, a.signal = n[Q] ? 1 : -1) : (a.pixel = t[1], a.pixelLength = r[nr], a.pixelStart = r.y, a.signal = n[Q] ? -1 : 1),
                a
            }
            function r(t) {
                var e = [0, 100];
                return ! (t[0] <= e[1]) && (t[0] = e[1]),
                !(t[1] <= e[1]) && (t[1] = e[1]),
                !(t[0] >= e[0]) && (t[0] = e[0]),
                !(t[1] >= e[0]) && (t[1] = e[0]),
                t
            }
            var a = t("./DataZoomView"),
            o = t(Ar),
            s = t("../helper/sliderMove"),
            l = t("./roams"),
            u = o.bind,
            c = a[jn]({
                type: "dataZoom.inside",
                init: function() {
                    this._range
                },
                render: function(t, e, i, n) {
                    c[Oi](this, Bn, arguments),
                    l.shouldRecordRange(n, t.id) && (this._range = t.getPercentRange());
                    var r = this.getTargetInfo().cartesians,
                    a = o.map(r,
                    function(t) {
                        return l.generateCoordId(t.model)
                    });
                    o.each(r,
                    function(e) {
                        var n = e.model;
                        l[bn](i, {
                            coordId: l.generateCoordId(n),
                            allCoordIds: a,
                            coordinateSystem: n[ln],
                            dataZoomId: t.id,
                            throttleRate: t.get("throttle", !0),
                            panGetRange: u(this._onPan, this, e),
                            zoomGetRange: u(this._onZoom, this, e)
                        })
                    },
                    this)
                },
                dispose: function() {
                    l.unregister(this.api, this.dataZoomModel.id),
                    c[Oi](this, Hn, arguments),
                    this._range = null
                },
                _onPan: function(t, i, n, r) {
                    return this._range = e([n, r], this._range, i, t)
                },
                _onZoom: function(t, e, n, r, a) {
                    var o = this.dataZoomModel;
                    return o[zi].zoomLock ? this._range: this._range = i(1 / n, [r, a], this._range, e, t, o)
                }
            });
            return c
        }),
        e("echarts/component/dataZoom/InsideZoomModel", [Tr, "./DataZoomModel"],
        function(t) {
            return t("./DataZoomModel")[jn]({
                type: "dataZoom.inside",
                defaultOption: {
                    zoomLock: !1
                }
            })
        }),
        e("echarts/component/dataZoom/dataZoomProcessor", [Tr, Ei],
        function(t) {
            function e(t, e, i) {
                i.getAxisProxy(t.name, e).reset(i)
            }
            function i(t, e, i) {
                i.getAxisProxy(t.name, e).filterData(i)
            }
            var n = t(Ei);
            n.registerProcessor(function(t) {
                t[or]("dataZoom",
                function(t) {
                    t.eachTargetAxis(e),
                    t.eachTargetAxis(i)
                }),
                t[or]("dataZoom",
                function(t) {
                    var e = t.findRepresentativeAxisProxy(),
                    i = e.getDataPercentWindow(),
                    n = e.getDataValueWindow();
                    t.setRawRange({
                        start: i[0],
                        end: i[1],
                        startValue: n[0],
                        endValue: n[1]
                    })
                })
            })
        }),
        e("echarts/component/dataZoom/dataZoomAction", [Tr, Ar, "./helper", Ei],
        function(t) {
            var e = t(Ar),
            i = t("./helper"),
            n = t(Ei);
            n[Mn]("dataZoom",
            function(t, n) {
                var r = i.createLinkedNodesFinder(e.bind(n[or], n, "dataZoom"), i.eachAxisDim,
                function(t, e) {
                    return t.get(e.axisIndex)
                }),
                a = [];
                n[or]({
                    mainType: "dataZoom",
                    query: t
                },
                function(t) {
                    a.push.apply(a, r(t).nodes)
                }),
                e.each(a,
                function(e) {
                    e.setRawRange({
                        start: t.start,
                        end: t.end,
                        startValue: t.startValue,
                        endValue: t.endValue
                    })
                })
            })
        }),
        e("echarts/component/visualMapContinuous", [Tr, "../echarts", "./visualMap/preprocessor", "./visualMap/typeDefaulter", "./visualMap/visualEncoding", "./visualMap/ContinuousModel", "./visualMap/ContinuousView", "./visualMap/visualMapAction"],
        function(t) {
            t("../echarts").registerPreprocessor(t("./visualMap/preprocessor")),
            t("./visualMap/typeDefaulter"),
            t("./visualMap/visualEncoding"),
            t("./visualMap/ContinuousModel"),
            t("./visualMap/ContinuousView"),
            t("./visualMap/visualMapAction")
        }),
        e("echarts/component/visualMapPiecewise", [Tr, "../echarts", "./visualMap/preprocessor", "./visualMap/typeDefaulter", "./visualMap/visualEncoding", "./visualMap/PiecewiseModel", "./visualMap/PiecewiseView", "./visualMap/visualMapAction"],
        function(t) {
            t("../echarts").registerPreprocessor(t("./visualMap/preprocessor")),
            t("./visualMap/typeDefaulter"),
            t("./visualMap/visualEncoding"),
            t("./visualMap/PiecewiseModel"),
            t("./visualMap/PiecewiseView"),
            t("./visualMap/visualMapAction")
        }),
        e("echarts/component/brush/preprocessor", [Tr, Ar],
        function(t) {
            function e(t) {
                var e = {};
                i.each(t,
                function(t) {
                    e[t] = 1
                }),
                t[Wn] = 0,
                i.each(e,
                function(e, i) {
                    t.push(i)
                })
            }
            var i = t(Ar),
            n = ["rect", "polygon", "keep", "clear"];
            return function(t, r) {
                var a = t && t.brush;
                if (i[An](a) || (a = a ? [a] : []), a[Wn]) {
                    var o = [];
                    i.each(a,
                    function(t) {
                        var e = t.hasOwnProperty("toolbox") ? t.toolbox: [];
                        e instanceof Array && (o = o[Ai](e))
                    });
                    var s = t && t.toolbox;
                    i[An](s) && (s = s[0]),
                    s || (s = {
                        feature: {}
                    },
                    t.toolbox = [s]);
                    var l = s.feature || (s.feature = {}),
                    u = l.brush || (l.brush = {}),
                    c = u.type || (u.type = []);
                    c.push.apply(c, o),
                    e(c),
                    r && !c[Wn] && c.push.apply(c, n)
                }
            }
        }),
        e("echarts/component/brush/visualEncoding", [Tr, Ei, "../../visual/visualSolution", Ar, Me, "./selector", "../../util/throttle", "../helper/brushHelper"],
        function(t) {
            function e(t, e, n, r, a) {
                if (a) {
                    var o = t.getZr();
                    if (!o[m]) {
                        o[g] || (o[g] = i);
                        var s = f.createOrUpdate(o, g, n, e);
                        s(t, r)
                    }
                }
            }
            function i(t, e) {
                if (!t.isDisposed()) {
                    var i = t.getZr();
                    i[m] = !0,
                    t[Un]({
                        type: "brushSelect",
                        batch: e
                    }),
                    i[m] = !1
                }
            }
            function n(t, e, i, n) {
                for (var r = i[bi](n), a = 0, o = e[Wn]; o > a; a++) {
                    var s = e[a];
                    if (t[s.brushType](r, s.selectors, s)) return ! 0
                }
            }
            function r(t) {
                var e = t.brushSelector;
                if (c[pn](e)) {
                    var i = [];
                    return c.each(d,
                    function(t, n) {
                        i[n] = t[e]
                    }),
                    i
                }
                if (c.isFunction(e)) {
                    var n = {};
                    return c.each(d,
                    function(t, i) {
                        n[i] = e
                    }),
                    n
                }
                return e
            }
            function a(t, e) {
                var i = t[zi][Dn];
                return null != i && "all" !== i && (c[An](i) ? c[gn](i, e) < 0 : e !== i)
            }
            function o(t) {
                var e = t.selectors = {};
                return c.each(d[t.brushType],
                function(i, n) {
                    e[n] = function(n) {
                        return i(n, e, t)
                    }
                }),
                t
            }
            function s(t) {
                return new h(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0])
            }
            var l = t(Ei),
            u = t("../../visual/visualSolution"),
            c = t(Ar),
            h = t(Me),
            d = t("./selector"),
            f = t("../../util/throttle"),
            p = t("../helper/brushHelper"),
            v = ["inBrush", "outOfBrush"],
            g = "__ecBrushSelect",
            m = "__ecInBrushSelectEvent",
            y = l.PRIORITY.VISUAL.BRUSH;
            l.registerLayout(y,
            function(t, e, i) {
                t[or]({
                    mainType: "brush"
                },
                function(e) {
                    i && "takeGlobalCursor" === i.type && e.setBrushOption("brush" === i.key ? i.brushOption: {
                        brushType: !1
                    }),
                    e.coordInfoList = p.makeCoordInfoList(e[zi], t),
                    p.parseInputRanges(e, t)
                })
            }),
            l.registerVisual(y,
            function(t, i, s) {
                var l, h, d = [];
                t[or]({
                    mainType: "brush"
                },
                function(e, i) {
                    function s(t) {
                        return "all" === w || b[t]
                    }
                    function f(t) {
                        return !! t[Wn]
                    }
                    function g(t, e) {
                        var i = t[ln];
                        A |= i.hasAxisbrushed(),
                        s(e) && i.eachActiveState(t[Kn](),
                        function(t, e) {
                            "active" === t && (M[e] = 1)
                        })
                    }
                    function m(t, i, o) {
                        var l = r(t);
                        if (l && !a(e, i) && (c.each(T,
                        function(i) {
                            l[i.brushType] && p.controlSeries(i, e, t) && o.push(i),
                            A |= f(o)
                        }), s(i) && f(o))) {
                            var u = t[Kn]();
                            u.each(function(t) {
                                n(l, o, u, t) && (M[t] = 1)
                            })
                        }
                    }
                    var y = {
                        brushId: e.id,
                        brushIndex: i,
                        brushName: e.name,
                        areas: c.clone(e.areas),
                        selected: []
                    };
                    d.push(y);
                    var _ = e[zi],
                    w = _.brushLink,
                    b = [],
                    M = [],
                    S = [],
                    A = 0;
                    i || (l = _.throttleType, h = _.throttleDelay);
                    var T = c.map(e.areas,
                    function(t) {
                        return o(c[qn]({
                            boundingRect: x[t.brushType](t)
                        },
                        t))
                    }),
                    C = u.createVisualMappings(e[zi], v,
                    function(t) {
                        t.mappingMethod = "fixed"
                    });
                    c[An](w) && c.each(w,
                    function(t) {
                        b[t] = 1
                    }),
                    t[tr](function(t, e) {
                        var i = S[e] = [];
                        "parallel" === t.subType ? g(t, e, i) : m(t, e, i)
                    }),
                    t[tr](function(t, e) {
                        var i = {
                            seriesId: t.id,
                            seriesIndex: e,
                            seriesName: t.name,
                            dataIndex: []
                        };
                        y[ai].push(i);
                        var a = r(t),
                        o = S[e],
                        l = t[Kn](),
                        c = s(e) ?
                        function(t) {
                            return M[t] ? (i[zn].push(l[je](t)), "inBrush") : "outOfBrush"
                        }: function(t) {
                            return n(a, o, l, t) ? (i[zn].push(l[je](t)), "inBrush") : "outOfBrush"
                        }; (s(e) ? A: f(o)) && u.applyVisual(v, C, l, c)
                    })
                }),
                e(i, l, h, d, s)
            });
            var x = {
                lineX: c.noop,
                lineY: c.noop,
                rect: function(t) {
                    return s(t.range)
                },
                polygon: function(t) {
                    for (var e, i = t.range,
                    n = 0,
                    r = i[Wn]; r > n; n++) {
                        e = e || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
                        var a = i[n];
                        a[0] < e[0][0] && (e[0][0] = a[0]),
                        a[0] > e[0][1] && (e[0][1] = a[0]),
                        a[1] < e[1][0] && (e[1][0] = a[1]),
                        a[1] > e[1][1] && (e[1][1] = a[1])
                    }
                    return e && s(e)
                }
            }
        }),
        e("echarts/component/brush/BrushView", [Tr, Ar, "../helper/BrushController", Ei, "../helper/brushHelper"],
        function(t) {
            function e(t, e, i, n) { (!n || n.$from !== t.id) && this._brushController.setPanels(a.makePanelOpts(t.coordInfoList)).enableBrush(t.brushOption).updateCovers(t.areas.slice())
            }
            var i = t(Ar),
            n = t("../helper/BrushController"),
            r = t(Ei),
            a = t("../helper/brushHelper");
            return r[_n]({
                type: "brush",
                init: function(t, e) {
                    this[Te] = t,
                    this.api = e,
                    this.model,
                    (this._brushController = new n(e.getZr())).on("brush", i.bind(this._onBrush, this)).mount()
                },
                render: function(t) {
                    return this.model = t,
                    e.apply(this, arguments)
                },
                updateView: e,
                updateLayout: e,
                updateVisual: e,
                dispose: function() {
                    this._brushController[Hn]()
                },
                _onBrush: function(t, e) {
                    var n = this.model.id;
                    a.parseOutputRanges(t, this.model.coordInfoList, this[Te]),
                    (!e.isEnd || e.removeOnClick) && this.api[Un]({
                        type: "brush",
                        brushId: n,
                        areas: i.clone(t),
                        $from: n
                    })
                }
            })
        }),
        e("echarts/component/brush/BrushModel", [Tr, Ei, Ar, "../../visual/visualSolution", W],
        function(t) {
            var e = t(Ei),
            i = t(Ar),
            n = t("../../visual/visualSolution"),
            r = t(W),
            a = ["#ddd"],
            o = e[wn]({
                type: "brush",
                dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", Fn],
                defaultOption: {
                    toolbox: null,
                    brushLink: null,
                    seriesIndex: "all",
                    geoIndex: null,
                    xAxisIndex: null,
                    yAxisIndex: null,
                    brushType: "rect",
                    brushMode: "single",
                    transformable: !0,
                    brushStyle: {
                        borderWidth: 1,
                        color: "rgba(120,140,180,0.3)",
                        borderColor: "rgba(120,140,180,0.8)",
                        width: null
                    },
                    throttleType: "fixRate",
                    throttleDelay: 0,
                    removeOnClick: !0
                },
                areas: [],
                brushType: null,
                brushOption: {},
                coordInfoList: [],
                optionUpdated: function(t, e) {
                    var i = this[zi]; ! e && n.replaceVisualOption(i, t, ["inBrush", "outOfBrush"]),
                    i.inBrush = i.inBrush || {},
                    i.outOfBrush = i.outOfBrush || {
                        color: a
                    }
                },
                setAreas: function(t) {
                    t && (this.areas = i.map(t,
                    function(t) {
                        return this._mergeBrushOption(t)
                    },
                    this))
                },
                setBrushOption: function(t) {
                    this.brushOption = this._mergeBrushOption(t),
                    this.brushType = this.brushOption.brushType
                },
                _mergeBrushOption: function(t) {
                    var e = this[zi];
                    return i.merge({
                        brushType: e.brushType,
                        brushMode: e.brushMode,
                        transformable: e.transformable,
                        brushStyle: new r(e.brushStyle)[sn](),
                        removeOnClick: e.removeOnClick
                    },
                    t, !0)
                }
            });
            return o
        }),
        e("echarts/component/brush/brushAction", [Tr, Ei],
        function(t) {
            var e = t(Ei);
            e[Mn]({
                type: "brush",
                event: "brush",
                update: "updateView"
            },
            function(t, e) {
                e[or]({
                    mainType: "brush",
                    query: t
                },
                function(e) {
                    e.setAreas(t.areas)
                })
            }),
            e[Mn]({
                type: "brushSelect",
                event: "brushSelected",
                update: "none"
            },
            function() {})
        }),
        e("echarts/component/toolbox/feature/Brush", [Tr, "../featureManager", Ar],
        function(t) {
            function e(t, e, i) {
                this.model = t,
                this[Te] = e,
                this.api = i,
                this._brushType,
                this._brushMode
            }
            var i = t("../featureManager"),
            n = t(Ar);
            e.defaultOption = {
                show: !0,
                type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"],
                icon: {
                    rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
                    polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
                    lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
                    lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
                    keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
                    clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
                },
                title: {
                    rect: "矩形选择",
                    polygon: "圈选",
                    lineX: "横向选择",
                    lineY: "纵向选择",
                    keep: "保持选择",
                    clear: "清除选择"
                }
            };
            var r = e[xr];
            return r[Bn] = r.updateView = r[Qn] = function(t, e) {
                var i, r, a;
                e[or]({
                    mainType: "brush"
                },
                function(t) {
                    i = t.brushType,
                    r = t.brushOption.brushMode || "single",
                    a |= t.areas[Wn]
                }),
                this._brushType = i,
                this._brushMode = r,
                n.each(t.get("type", !0),
                function(e) {
                    t.setIconStatus(e, ("keep" === e ? "multiple" === r: "clear" === e ? a: e === i) ? Li: ki)
                })
            },
            r.getIcons = function() {
                var t = this.model,
                e = t.get("icon", !0),
                i = {};
                return n.each(t.get("type", !0),
                function(t) {
                    e[t] && (i[t] = e[t])
                }),
                i
            },
            r.onclick = function(t, e, i) {
                var e = this.api,
                n = this._brushType,
                r = this._brushMode;
                e[Un]("clear" === i ? {
                    type: "brush",
                    areas: []
                }: {
                    type: "takeGlobalCursor",
                    key: "brush",
                    brushOption: {
                        brushType: "keep" === i ? n: n === i ? !1 : i,
                        brushMode: "keep" === i ? "multiple" === r ? "single": "multiple": r
                    }
                })
            },
            i[bn]("brush", e),
            e
        }),
        e("echarts/component/toolbox/ToolboxModel", [Tr, "./featureManager", Ar, Ei],
        function(t) {
            var e = t("./featureManager"),
            i = t(Ar),
            n = t(Ei)[wn]({
                type: "toolbox",
                layoutMode: {
                    type: "box",
                    ignoreSize: !0
                },
                mergeDefaultAndTheme: function() {
                    n[Oi](this, De, arguments),
                    i.each(this[zi].feature,
                    function(t, n) {
                        var r = e.get(n);
                        r && i.merge(t, r.defaultOption)
                    })
                },
                defaultOption: {
                    show: !0,
                    z: 6,
                    zlevel: 0,
                    orient: "horizontal",
                    left: "right",
                    top: "top",
                    backgroundColor: "transparent",
                    borderColor: "#ccc",
                    borderWidth: 0,
                    padding: 5,
                    itemSize: 15,
                    itemGap: 8,
                    showTitle: !0,
                    iconStyle: {
                        normal: {
                            borderColor: "#666",
                            color: "none"
                        },
                        emphasis: {
                            borderColor: "#3E98C5"
                        }
                    }
                }
            });
            return n
        }),
        e("echarts/component/toolbox/ToolboxView", [Tr, "./featureManager", Ar, Si, W, "../../data/DataDiffer", "../helper/listComponent", "zrender/contain/text", Ei],
        function(t) {
            function e(t) {
                return 0 === t[gn]("my")
            }
            var i = t("./featureManager"),
            n = t(Ar),
            r = t(Si),
            a = t(W),
            o = t("../../data/DataDiffer"),
            s = t("../helper/listComponent"),
            l = t("zrender/contain/text");
            return t(Ei)[_n]({
                type: "toolbox",
                render: function(t, u, c, h) {
                    function d(n, r) {
                        var o, s = y[n],
                        l = y[r],
                        d = g[s],
                        p = new a(d, t, t[Te]);
                        if (s && !l) {
                            if (e(s)) o = {
                                model: p,
                                onclick: p[zi].onclick,
                                featureName: s
                            };
                            else {
                                var v = i.get(s);
                                if (!v) return;
                                o = new v(p, u, c)
                            }
                            m[s] = o
                        } else {
                            if (o = m[l], !o) return;
                            o.model = p,
                            o[Te] = u,
                            o.api = c
                        }
                        return ! s && l ? void(o[Hn] && o[Hn](u, c)) : !p.get("show") || o.unusable ? void(o[Xn] && o[Xn](u, c)) : (f(p, o, s), p.setIconStatus = function(t, e) {
                            var i = this[zi],
                            n = this.iconPaths;
                            i.iconStatus = i.iconStatus || {},
                            i.iconStatus[t] = e,
                            n[t] && n[t][Zn](e)
                        },
                        void(o[Bn] && o[Bn](p, u, c, h)))
                    }
                    function f(e, i, a) {
                        var o = e[fr]("iconStyle"),
                        s = i.getIcons ? i.getIcons() : e.get("icon"),
                        l = e.get("title") || {};
                        if (typeof s === yr) {
                            var h = s,
                            d = l;
                            s = {},
                            l = {},
                            s[a] = h,
                            l[a] = d
                        }
                        var f = e.iconPaths = {};
                        n.each(s,
                        function(a, s) {
                            var h = o[fr](ki)[sn](),
                            d = o[fr](Li)[sn](),
                            g = {
                                x: -v / 2,
                                y: -v / 2,
                                width: v,
                                height: v
                            },
                            m = 0 === a[gn]("image://") ? (g.image = a.slice(8), new r.Image({
                                style: g
                            })) : r.makePath(a[Tn]("path://", ""), {
                                style: h,
                                hoverStyle: d,
                                rectHover: !0
                            },
                            g, Ji);
                            r[ri](m),
                            t.get("showTitle") && (m.__title = l[s], m.on(En,
                            function() {
                                m[Ln]({
                                    text: l[s],
                                    textPosition: d[Z] || rr,
                                    textFill: d.fill || d[ye] || "#000",
                                    textAlign: d[an] || Ji
                                })
                            }).on(On,
                            function() {
                                m[Ln]({
                                    textFill: null
                                })
                            })),
                            m[Zn](e.get("iconStatus." + s) || ki),
                            p.add(m),
                            m.on("click", n.bind(i.onclick, i, u, c, s)),
                            f[s] = m
                        })
                    }
                    var p = this.group;
                    if (p[cn](), t.get("show")) {
                        var v = +t.get("itemSize"),
                        g = t.get("feature") || {},
                        m = this._features || (this._features = {}),
                        y = [];
                        n.each(g,
                        function(t, e) {
                            y.push(e)
                        }),
                        new o(this._featureNames || [], y).add(d)[er](d)[Xn](n.curry(d, null))[Qe](),
                        this._featureNames = y,
                        s[E](p, t, c),
                        s.addBackground(p, t),
                        p[Je](function(t) {
                            var e = t.__title,
                            i = t[oi];
                            if (i && e) {
                                var n = l[en](e, i.font),
                                r = t[$i][0] + p[$i][0],
                                a = t[$i][1] + p[$i][1] + v,
                                o = !1;
                                a + n[nr] > c[hr]() && (i[Z] = "top", o = !0);
                                var s = o ? -5 - n[nr] : v + 8;
                                r + n.width / 2 > c[dr]() ? (i[Z] = ["100%", s], i[an] = "right") : r - n.width / 2 < 0 && (i[Z] = [0, s], i[an] = "left")
                            }
                        })
                    }
                },
                updateView: function(t, e, i, r) {
                    n.each(this._features,
                    function(t) {
                        t.updateView && t.updateView(t.model, e, i, r)
                    })
                },
                updateLayout: function(t, e, i, r) {
                    n.each(this._features,
                    function(t) {
                        t[Qn] && t[Qn](t.model, e, i, r)
                    })
                },
                remove: function(t, e) {
                    n.each(this._features,
                    function(i) {
                        i[Xn] && i[Xn](t, e)
                    }),
                    this.group[cn]()
                },
                dispose: function(t, e) {
                    n.each(this._features,
                    function(i) {
                        i[Hn] && i[Hn](t, e)
                    })
                }
            })
        }),
        e("echarts/component/toolbox/feature/SaveAsImage", [Tr, Sr, "../featureManager"],
        function(t) {
            function e(t) {
                this.model = t
            }
            var i = t(Sr);
            e.defaultOption = {
                show: !0,
                icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
                title: "保存为图片",
                type: "png",
                name: "",
                excludeComponents: ["toolbox"],
                pixelRatio: 1,
                lang: ["右键另存为图片"]
            },
            e[xr].unusable = !i[cr];
            var n = e[xr];
            return n.onclick = function(t, e) {
                var i = this.model,
                n = i.get("name") || t.get("title.0.text") || "echarts",
                r = document[Ti]("a"),
                a = i.get("type", !0) || "png";
                r.download = n + "." + a,
                r[Vn] = "_blank";
                var o = e.getConnectedDataURL({
                    type: a,
                    backgroundColor: i.get(ur, !0) || t.get(ur) || "#fff",
                    excludeComponents: i.get("excludeComponents"),
                    pixelRatio: i.get("pixelRatio")
                });
                if (r.href = o, typeof MouseEvent === Sn) {
                    var s = new MouseEvent("click", {
                        view: window,
                        bubbles: !0,
                        cancelable: !1
                    });
                    r.dispatchEvent(s)
                } else {
                    var l = i.get("lang"),
                    u = '<body style="margin:0;"><img src="' + o + '" style="max-width:100%;" title="' + (l && l[0] || "") + '" /></body>',
                    c = window.open();
                    c.document.write(u)
                }
            },
            t("../featureManager")[bn]("saveAsImage", e),
            e
        }),
        e("echarts/component/toolbox/feature/MagicType", [Tr, Ar, "../../../echarts", "../featureManager"],
        function(t) {
            function e(t) {
                this.model = t
            }
            var i = t(Ar);
            e.defaultOption = {
                show: !0,
                type: [],
                icon: {
                    line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
                    bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
                    stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z",
                    tiled: "M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z"
                },
                title: {
                    line: "切换为折线图",
                    bar: "切换为柱状图",
                    stack: "切换为堆叠",
                    tiled: "切换为平铺"
                },
                option: {},
                seriesIndex: {}
            };
            var n = e[xr];
            n.getIcons = function() {
                var t = this.model,
                e = t.get("icon"),
                n = {};
                return i.each(t.get("type"),
                function(t) {
                    e[t] && (n[t] = e[t])
                }),
                n
            };
            var r = {
                line: function(t, e, n, r) {
                    return "bar" === t ? i.merge({
                        id: e,
                        type: "line",
                        data: n.get("data"),
                        stack: n.get("stack"),
                        markPoint: n.get("markPoint"),
                        markLine: n.get("markLine")
                    },
                    r.get("option.line") || {},
                    !0) : void 0
                },
                bar: function(t, e, n, r) {
                    return "line" === t ? i.merge({
                        id: e,
                        type: "bar",
                        data: n.get("data"),
                        stack: n.get("stack"),
                        markPoint: n.get("markPoint"),
                        markLine: n.get("markLine")
                    },
                    r.get("option.bar") || {},
                    !0) : void 0
                },
                stack: function(t, e, n, r) {
                    return "line" === t || "bar" === t ? i.merge({
                        id: e,
                        stack: "__ec_magicType_stack__"
                    },
                    r.get("option.stack") || {},
                    !0) : void 0
                },
                tiled: function(t, e, n, r) {
                    return "line" === t || "bar" === t ? i.merge({
                        id: e,
                        stack: ""
                    },
                    r.get("option.tiled") || {},
                    !0) : void 0
                }
            },
            a = [["line", "bar"], ["stack", "tiled"]];
            n.onclick = function(t, e, n) {
                var o = this.model,
                s = o.get("seriesIndex." + n);
                if (r[n]) {
                    var l = {
                        series: []
                    },
                    u = function(e) {
                        var a = e.subType,
                        s = e.id,
                        u = r[n](a, s, e, o);
                        u && (i[qn](u, e[zi]), l[Fn].push(u));
                        var c = e[ln];
                        if (c && c.type === q && ("line" === n || "bar" === n)) {
                            var h = c.getAxesByScale(Pe)[0];
                            if (h) {
                                var d = h.dim,
                                f = d + "Axis",
                                p = t[Ee]({
                                    mainType: f,
                                    index: e.get(name + "Index"),
                                    id: e.get(name + "Id")
                                })[0],
                                v = p[Oe];
                                l[f] = l[f] || [];
                                for (var g = 0; v >= g; g++) l[f][v] = l[f][v] || {};
                                l[f][v][X] = "bar" === n ? !0 : !1
                            }
                        }
                    };
                    i.each(a,
                    function(t) {
                        i[gn](t, n) >= 0 && i.each(t,
                        function(t) {
                            o.setIconStatus(t, ki)
                        })
                    }),
                    o.setIconStatus(n, Li),
                    t[or]({
                        mainType: "series",
                        query: null == s ? null: {
                            seriesIndex: s
                        }
                    },
                    u),
                    e[Un]({
                        type: "changeMagicType",
                        currentType: n,
                        newOption: l
                    })
                }
            };
            var o = t("../../../echarts");
            return o[Mn]({
                type: "changeMagicType",
                event: "magicTypeChanged",
                update: "prepareAndUpdate"
            },
            function(t, e) {
                e[Vi](t.newOption)
            }),
            t("../featureManager")[bn]("magicType", e),
            e
        }),
        e("echarts/component/toolbox/feature/DataView", [Tr, Ar, "zrender/core/event", "../featureManager", "../../../echarts"],
        function(t) {
            function e(t) {
                var e = {},
                i = [],
                n = [];
                return t.eachRawSeries(function(t) {
                    var r = t[ln];
                    if (!r || r.type !== q && "polar" !== r.type) i.push(t);
                    else {
                        var a = r[Ie]();
                        if (a.type === te) {
                            var o = a.dim + "_" + a.index;
                            e[o] || (e[o] = {
                                categoryAxis: a,
                                valueAxis: r.getOtherAxis(a),
                                series: []
                            },
                            n.push({
                                axisDim: a.dim,
                                axisIndex: a.index
                            })),
                            e[o][Fn].push(t)
                        } else i.push(t)
                    }
                }),
                {
                    seriesGroupByCategoryAxis: e,
                    other: i,
                    meta: n
                }
            }
            function i(t) {
                var e = [];
                return d.each(t,
                function(t) {
                    var i = t.categoryAxis,
                    n = t.valueAxis,
                    r = n.dim,
                    a = [" "][Ai](d.map(t[Fn],
                    function(t) {
                        return t.name
                    })),
                    o = [i.model.getCategories()];
                    d.each(t[Fn],
                    function(t) {
                        o.push(t.getRawData()[he](r,
                        function(t) {
                            return t
                        }))
                    });
                    for (var s = [a.join(v)], l = 0; l < o[0][Wn]; l++) {
                        for (var u = [], c = 0; c < o[Wn]; c++) u.push(o[c][l]);
                        s.push(u.join(v))
                    }
                    e.push(s.join("\n"))
                }),
                e.join("\n\n" + p + "\n\n")
            }
            function n(t) {
                return d.map(t,
                function(t) {
                    var e = t.getRawData(),
                    i = [t.name],
                    n = [];
                    return e.each(e[de],
                    function() {
                        for (var t = arguments[Wn], r = arguments[t - 1], a = e[Ci](r), o = 0; t - 1 > o; o++) n[o] = arguments[o];
                        i.push((a ? a + v: "") + n.join(v))
                    }),
                    i.join("\n")
                }).join("\n\n" + p + "\n\n")
            }
            function r(t) {
                var r = e(t);
                return {
                    value: d[mn]([i(r.seriesGroupByCategoryAxis), n(r.other)],
                    function(t) {
                        return t[Tn](/[\n\t\s]/g, "")
                    }).join("\n\n" + p + "\n\n"),
                    meta: r.meta
                }
            }
            function a(t) {
                return t[Tn](/^\s\s*/, "")[Tn](/\s\s*$/, "")
            }
            function o(t) {
                var e = t.slice(0, t[gn]("\n"));
                return e[gn](v) >= 0 ? !0 : void 0
            }
            function s(t) {
                for (var e = t.split(/\n+/g), i = a(e.shift()).split(g), n = [], r = d.map(i,
                function(t) {
                    return {
                        name: t,
                        data: []
                    }
                }), o = 0; o < e[Wn]; o++) {
                    var s = a(e[o]).split(g);
                    n.push(s.shift());
                    for (var l = 0; l < s[Wn]; l++) r[l] && (r[l].data[o] = s[l])
                }
                return {
                    series: r,
                    categories: n
                }
            }
            function l(t) {
                for (var e = t.split(/\n+/g), i = a(e.shift()), n = [], r = 0; r < e[Wn]; r++) {
                    var o, s = a(e[r]).split(g),
                    l = "",
                    u = !1;
                    isNaN(s[0]) ? (u = !0, l = s[0], s = s.slice(1), n[r] = {
                        name: l,
                        value: []
                    },
                    o = n[r].value) : o = n[r] = [];
                    for (var c = 0; c < s[Wn]; c++) o.push( + s[c]);
                    1 === o[Wn] && (u ? n[r].value = o[0] : n[r] = o[0])
                }
                return {
                    name: i,
                    data: n
                }
            }
            function u(t, e) {
                var i = t.split(new RegExp("\n*" + p + "\n*", "g")),
                n = {
                    series: []
                };
                return d.each(i,
                function(t, i) {
                    if (o(t)) {
                        var r = s(t),
                        a = e[i],
                        u = a.axisDim + "Axis";
                        a && (n[u] = n[u] || [], n[u][a.axisIndex] = {
                            data: r.categories
                        },
                        n[Fn] = n[Fn][Ai](r[Fn]))
                    } else {
                        var r = l(t);
                        n[Fn].push(r)
                    }
                }),
                n
            }
            function c(t) {
                this._dom = null,
                this.model = t
            }
            function h(t, e) {
                return d.map(t,
                function(t, i) {
                    var n = e && e[i];
                    return d[Yn](n) && !d[An](n) ? (d[Yn](t) && !d[An](t) && (t = t.value), d[qn]({
                        value: t
                    },
                    n)) : t
                })
            }
            var d = t(Ar),
            f = t("zrender/core/event"),
            p = new Array(60).join("-"),
            v = "	",
            g = new RegExp("[" + v + "]+", "g");
            return c.defaultOption = {
                show: !0,
                readOnly: !1,
                optionToContent: null,
                contentToOption: null,
                icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
                title: "数据视图",
                lang: ["数据视图", "关闭", "刷新"],
                backgroundColor: "#fff",
                textColor: "#000",
                textareaColor: "#fff",
                textareaBorderColor: "#333",
                buttonColor: "#c23531",
                buttonTextColor: "#fff"
            },
            c[xr].onclick = function(t, e) {
                function i() {
                    n.removeChild(o),
                    S._dom = null
                }
                var n = e.getDom(),
                a = this.model;
                this._dom && n.removeChild(this._dom);
                var o = document[Ti]("div");
                o.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;",
                o.style[ur] = a.get(ur) || "#fff";
                var s = document[Ti]("h4"),
                l = a.get("lang") || [];
                s.innerHTML = l[0] || a.get("title"),
                s.style.cssText = "margin: 10px 20px;",
                s.style.color = a.get("textColor");
                var c = document[Ti]("div"),
                h = document[Ti]("textarea");
                c.style.cssText = "display:block;width:100%;overflow:hidden;";
                var p = a.get("optionToContent"),
                g = a.get("contentToOption"),
                m = r(t);
                if (typeof p === Sn) {
                    var y = p(e.getOption());
                    typeof y === yr ? c.innerHTML = y: d.isDom(y) && c.appendChild(y)
                } else c.appendChild(h),
                h.readOnly = a.get("readOnly"),
                h.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;",
                h.style.color = a.get("textColor"),
                h.style[N] = a.get("textareaBorderColor"),
                h.style[ur] = a.get("textareaColor"),
                h.value = m.value;
                var x = m.meta,
                _ = document[Ti]("div");
                _.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
                var w = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px",
                b = document[Ti]("div"),
                M = document[Ti]("div");
                w += ";background-color:" + a.get("buttonColor"),
                w += ";color:" + a.get("buttonTextColor");
                var S = this;
                f.addEventListener(b, "click", i),
                f.addEventListener(M, "click",
                function() {
                    var t;
                    try {
                        t = typeof g === Sn ? g(c, e.getOption()) : u(h.value, x)
                    } catch(n) {
                        throw i(),
                        new Error("Data view format error " + n)
                    }
                    t && e[Un]({
                        type: "changeDataView",
                        newOption: t
                    }),
                    i()
                }),
                b.innerHTML = l[1],
                M.innerHTML = l[2],
                M.style.cssText = w,
                b.style.cssText = w,
                !a.get("readOnly") && _.appendChild(M),
                _.appendChild(b),
                f.addEventListener(h, "keydown",
                function(t) {
                    if (9 === (t.keyCode || t.which)) {
                        var e = this.value,
                        i = this.selectionStart,
                        n = this.selectionEnd;
                        this.value = e.substring(0, i) + v + e.substring(n),
                        this.selectionStart = this.selectionEnd = i + 1,
                        f.stop(t)
                    }
                }),
                o.appendChild(s),
                o.appendChild(c),
                o.appendChild(_),
                c.style[nr] = n.clientHeight - 80 + "px",
                n.appendChild(o),
                this._dom = o
            },
            c[xr][Xn] = function(t, e) {
                this._dom && e.getDom().removeChild(this._dom)
            },
            c[xr][Hn] = function(t, e) {
                this[Xn](t, e)
            },
            t("../featureManager")[bn]("dataView", c),
            t("../../../echarts")[Mn]({
                type: "changeDataView",
                event: "dataViewChanged",
                update: "prepareAndUpdate"
            },
            function(t, e) {
                var i = [];
                d.each(t.newOption[Fn],
                function(t) {
                    var n = e.getSeriesByName(t.name)[0];
                    if (n) {
                        var r = n.get("data");
                        i.push({
                            name: t.name,
                            data: h(t.data, r)
                        })
                    } else i.push(d[jn]({
                        type: "scatter"
                    },
                    t))
                }),
                e[Vi](d[qn]({
                    series: i
                },
                t.newOption))
            }),
            c
        }),
        e("echarts/component/toolbox/feature/DataZoom", [Tr, Ar, "../../helper/BrushController", "../../helper/brushHelper", "../../dataZoom/history", "../../dataZoomSelect", "../featureManager", "../../../echarts"],
        function(t) {
            function e(t, e, i) { (this._brushController = new o(i.getZr())).on("brush", a.bind(this._onBrush, this)).mount(),
                this._isZoomActive
            }
            function i(t) {
                var e = {};
                return a.each(["xAxisIndex", "yAxisIndex"],
                function(i) {
                    e[i] = t[i],
                    null == e[i] && (e[i] = "all"),
                    (e[i] === !1 || "none" === e[i]) && (e[i] = [])
                }),
                e
            }
            function n(t, e) {
                t.setIconStatus("back", l.count(e) > 1 ? Li: ki)
            }
            function r(t, e, n, r) {
                var a = n._isZoomActive;
                r && "takeGlobalCursor" === r.type && (a = "dataZoomSelect" === r.key ? r.dataZoomSelectActive: !1),
                n._isZoomActive = a,
                t.setIconStatus("zoom", a ? Li: ki);
                var o = s.makeCoordInfoList(i(t[zi]), e),
                l = o.xAxisHas && !o.yAxisHas ? "lineX": !o.xAxisHas && o.yAxisHas ? "lineY": "rect";
                n._brushController.setPanels(s.makePanelOpts(o)).enableBrush(a ? {
                    brushType: l,
                    brushStyle: {
                        lineWidth: 0,
                        fill: "rgba(0,0,0,0.2)"
                    }
                }: !1)
            }
            var a = t(Ar),
            o = t("../../helper/BrushController"),
            s = t("../../helper/brushHelper"),
            l = t("../../dataZoom/history"),
            u = a.each;
            t("../../dataZoomSelect");
            var c = "\x00_ec_\x00toolbox-dataZoom_";
            e.defaultOption = {
                show: !0,
                icon: {
                    zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
                    back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
                },
                title: {
                    zoom: "区域缩放",
                    back: "区域缩放还原"
                }
            };
            var h = e[xr];
            h[Bn] = function(t, e, i, a) {
                this.model = t,
                this[Te] = e,
                this.api = i,
                r(t, e, this, a),
                n(t, e)
            },
            h.onclick = function(t, e, i) {
                d[i].call(this)
            },
            h[Xn] = function() {
                this._brushController.unmount()
            },
            h[Hn] = function() {
                this._brushController[Hn]()
            };
            var d = {
                zoom: function() {
                    var t = !this._isZoomActive;
                    this.api[Un]({
                        type: "takeGlobalCursor",
                        key: "dataZoomSelect",
                        dataZoomSelectActive: t
                    })
                },
                back: function() {
                    this._dispatchZoomAction(l.pop(this[Te]))
                }
            };
            return h._onBrush = function(t, e) {
                function n(t, e, i) {
                    var n = r(t, i[t], o);
                    n && (a[n.id] = {
                        dataZoomId: n.id,
                        startValue: e[0],
                        endValue: e[1]
                    })
                }
                function r(t, e, i) {
                    var n;
                    return i[or]({
                        mainType: "dataZoom",
                        subType: "select"
                    },
                    function(r) {
                        var a = r.get(t + "Index");
                        null != a && i[Re](t, a) === e && (n = r)
                    }),
                    n
                }
                if (e.isEnd && t[Wn]) {
                    var a = {},
                    o = this[Te];
                    this._brushController.updateCovers([]);
                    var u = s.makeCoordInfoList(i(this.model[zi]), o),
                    c = [];
                    s.parseOutputRanges(t, u, o, c);
                    var h = t[0],
                    d = c[0],
                    f = h.coordRange,
                    p = h.brushType;
                    if (d && f) if ("rect" === p) n("xAxis", f[0], d),
                    n("yAxis", f[1], d);
                    else {
                        var v = {
                            lineX: "xAxis",
                            lineY: "yAxis"
                        };
                        n(v[p], f, d)
                    }
                    l.push(o, a),
                    this._dispatchZoomAction(a)
                }
            },
            h._dispatchZoomAction = function(t) {
                var e = [];
                u(t,
                function(t) {
                    e.push(a.clone(t))
                }),
                e[Wn] && this.api[Un]({
                    type: "dataZoom",
                    from: this.uid,
                    batch: e
                })
            },
            t("../featureManager")[bn]("dataZoom", e),
            t("../../../echarts").registerPreprocessor(function(t) {
                function e(t, e) {
                    if (e) {
                        var r = t + "Index",
                        o = e[r];
                        null == o || "all" == o || a[An](o) || (o = o === !1 || "none" === o ? [] : [o]),
                        i(t,
                        function(e, i) {
                            if (null == o || "all" == o || -1 !== a[gn](o, i)) {
                                var s = {
                                    type: "select",
                                    $fromToolbox: !0,
                                    id: c + t + i
                                };
                                s[r] = i,
                                n.push(s)
                            }
                        })
                    }
                }
                function i(e, i) {
                    var n = t[e];
                    a[An](n) || (n = n ? [n] : []),
                    u(n, i)
                }
                if (t) {
                    var n = t.dataZoom || (t.dataZoom = []);
                    a[An](n) || (t.dataZoom = n = [n]);
                    var r = t.toolbox;
                    if (r && (a[An](r) && (r = r[0]), r && r.feature)) {
                        var o = r.feature.dataZoom;
                        e("xAxis", o),
                        e("yAxis", o)
                    }
                }
            }),
            e
        }),
        e("echarts/component/toolbox/feature/Restore", [Tr, "../../dataZoom/history", "../featureManager", "../../../echarts"],
        function(t) {
            function e(t) {
                this.model = t
            }
            var i = t("../../dataZoom/history");
            e.defaultOption = {
                show: !0,
                icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
                title: "还原"
            };
            var n = e[xr];
            return n.onclick = function(t, e) {
                i.clear(t),
                e[Un]({
                    type: "restore",
                    from: this.uid
                })
            },
            t("../featureManager")[bn]("restore", e),
            t("../../../echarts")[Mn]({
                type: "restore",
                event: "restore",
                update: "prepareAndUpdate"
            },
            function(t, e) {
                e.resetOption("recreate")
            }),
            e
        }),
        e("zrender/vml/Painter", [Tr, "../core/log", "./core"],
        function(t) {
            function e(t) {
                return parseInt(t, 10)
            }
            function i(t, e) {
                o.initVML(),
                this.root = t,
                this[lr] = e;
                var i = document[Ti]("div"),
                n = document[Ti]("div");
                i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;",
                n.style.cssText = "position:absolute;left:0;top:0;",
                t.appendChild(i),
                this._vmlRoot = n,
                this._vmlViewport = i,
                this[gr]();
                var r = e.delFromMap,
                a = e.addToMap;
                e.delFromMap = function(t) {
                    var i = e.get(t);
                    r.call(e, t),
                    i && i.onRemove && i.onRemove(n)
                },
                e.addToMap = function(t) {
                    t.onAdd && t.onAdd(n),
                    a.call(e, t)
                },
                this._firstPaint = !0
            }
            function n(t) {
                return function() {
                    r('In IE8.0 VML mode painter not support method "' + t + '"')
                }
            }
            var r = t("../core/log"),
            o = t("./core");
            i[xr] = {
                constructor: i,
                getViewportRoot: function() {
                    return this._vmlViewport
                },
                refresh: function() {
                    var t = this[lr].getDisplayList(!0, !0);
                    this._paintList(t)
                },
                _paintList: function(t) {
                    for (var e = this._vmlRoot,
                    i = 0; i < t[Wn]; i++) {
                        var n = t[i];
                        n[M] || n[ar] ? (n.__alreadyNotVisible || n.onRemove(e), n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e), n.__alreadyNotVisible = !1, n[a] && (n.beforeBrush && n.beforeBrush(), (n.brushVML || n.brush).call(n, e), n.afterBrush && n.afterBrush())),
                        n[a] = !1
                    }
                    this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1)
                },
                resize: function() {
                    var t = this._getWidth(),
                    e = this._getHeight();
                    if (this._width != t && this._height != e) {
                        this._width = t,
                        this._height = e;
                        var i = this._vmlViewport.style;
                        i.width = t + "px",
                        i[nr] = e + "px"
                    }
                },
                dispose: function() {
                    this.root.innerHTML = "",
                    this._vmlRoot = this._vmlViewport = this[lr] = null
                },
                getWidth: function() {
                    return this._width
                },
                getHeight: function() {
                    return this._height
                },
                clear: function() {
                    this.root.removeChild(this.vmlViewport)
                },
                _getWidth: function() {
                    var t = this.root,
                    i = t.currentStyle;
                    return (t.clientWidth || e(i.width)) - e(i.paddingLeft) - e(i.paddingRight) | 0
                },
                _getHeight: function() {
                    var t = this.root,
                    i = t.currentStyle;
                    return (t.clientHeight || e(i[nr])) - e(i.paddingTop) - e(i.paddingBottom) | 0
                }
            };
            for (var s = ["getLayer", "insertLayer", "eachLayer", "eachBuildinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], l = 0; l < s[Wn]; l++) {
                var u = s[l];
                i[xr][u] = n(u)
            }
            return i
        }),
        e("echarts/util/model", [Tr, "./format", "./number", "../model/Model", Ar],
        function(t) {
            var e = t("./format"),
            i = t("./number"),
            n = t("../model/Model"),
            r = t(Ar),
            a = {};
            return a.normalizeToArray = function(t) {
                return t instanceof Array ? t: null == t ? [] : [t]
            },
            a[Pi] = function(t, e) {
                if (t) {
                    var i = t[Li] = t[Li] || {},
                    n = t[ki] = t[ki] || {};
                    r.each(e,
                    function(t) {
                        var e = r[vi](i[t], n[t]);
                        null != e && (i[t] = e)
                    })
                }
            },
            a.LABEL_OPTIONS = [$i, "show", on, ge, v],
            a.getDataItemValue = function(t) {
                return t && (null == t.value ? t: t.value)
            },
            a.isDataItemOption = function(t) {
                return r[Yn](t) && !(t instanceof Array)
            },
            a.converDataValue = function(t, e) {
                var n = e && e.type;
                return n === Pe ? t: ("time" !== n || isFinite(t) || null == t || "-" === t || (t = +i.parseDate(t)), null == t || "" === t ? 0 / 0 : +t)
            },
            a.createDataFormatModel = function(t, e) {
                var i = new n;
                return r.mixin(i, a.dataFormatMixin),
                i[Dn] = e[Dn],
                i.name = e.name || "",
                i[Ne] = e[Ne],
                i.subType = e.subType,
                i[Kn] = function() {
                    return t
                },
                i
            },
            a.dataFormatMixin = {
                getDataParams: function(t, e) {
                    var i = this[Kn](e),
                    n = this[Dn],
                    r = this.name,
                    a = this[ke](t, e),
                    o = i[je](t),
                    s = i[Ci](t, !0),
                    l = i.getRawDataItem(t);
                    return {
                        componentType: this[Ne],
                        componentSubType: this.subType,
                        seriesType: this[Ne] === Fn ? this.subType: null,
                        seriesIndex: n,
                        seriesName: r,
                        name: s,
                        dataIndex: o,
                        data: l,
                        dataType: e,
                        value: a,
                        color: i[gi](t, "color"),
                        $vars: ["seriesName", "name", "value"]
                    }
                },
                getFormattedLabel: function(t, i, n, r) {
                    i = i || ki;
                    var a = this[Kn](n),
                    o = a[hi](t),
                    s = this[In](t, n);
                    null != r && s.value instanceof Array && (s.value = s.value[r]);
                    var l = o.get(["label", i, v]);
                    return typeof l === Sn ? (s.status = i, l(s)) : typeof l === yr ? e.formatTpl(l, s) : void 0
                },
                getRawValue: function(t, e) {
                    var i = this[Kn](e),
                    n = i.getRawDataItem(t);
                    return null != n ? !r[Yn](n) || n instanceof Array ? n: n.value: void 0
                },
                formatTooltip: r.noop
            },
            a.mappingToExists = function(t, e) {
                e = (e || []).slice();
                var i = r.map(t || [],
                function(t) {
                    return {
                        exist: t
                    }
                });
                return r.each(e,
                function(t, n) {
                    if (r[Yn](t)) {
                        for (var o = 0; o < i[Wn]; o++) if (!i[o][zi] && null != t.id && i[o].exist.id === t.id + "") return i[o][zi] = t,
                        void(e[n] = null);
                        for (var o = 0; o < i[Wn]; o++) {
                            var s = i[o].exist;
                            if (! (i[o][zi] || null != s.id && null != t.id || null == t.name || a.isIdInner(t) || a.isIdInner(s) || s.name !== t.name + "")) return i[o][zi] = t,
                            void(e[n] = null)
                        }
                    }
                }),
                r.each(e,
                function(t) {
                    if (r[Yn](t)) {
                        for (var e = 0; e < i[Wn]; e++) {
                            var n = i[e].exist;
                            if (!i[e][zi] && !a.isIdInner(n) && null == t.id) {
                                i[e][zi] = t;
                                break
                            }
                        }
                        e >= i[Wn] && i.push({
                            option: t
                        })
                    }
                }),
                i
            },
            a.isIdInner = function(t) {
                return r[Yn](t) && t.id && 0 === (t.id + "")[gn]("\x00_ec_\x00")
            },
            a.compressBatches = function(t, e) {
                function i(t, e, i) {
                    for (var n = 0,
                    r = t[Wn]; r > n; n++) for (var o = t[n].seriesId, s = a.normalizeToArray(t[n][zn]), l = i && i[o], u = 0, c = s[Wn]; c > u; u++) {
                        var h = s[u];
                        l && l[h] ? l[h] = null: (e[o] || (e[o] = {}))[h] = 1
                    }
                }
                function n(t, e) {
                    var i = [];
                    for (var r in t) if (t.hasOwnProperty(r) && null != t[r]) if (e) i.push( + r);
                    else {
                        var a = n(t[r], !0);
                        a[Wn] && i.push({
                            seriesId: r,
                            dataIndex: a
                        })
                    }
                    return i
                }
                var r = {},
                o = {};
                return i(t || [], r),
                i(e || [], o, r),
                [n(r), n(o)]
            },
            a
        }),
        e("echarts/scale/Interval", [Tr, Xi, "../util/format", "./Scale"],
        function(t) {
            var e = t(Xi),
            i = t("../util/format"),
            n = t("./Scale"),
            r = Math.floor,
            a = Math.ceil,
            o = e.getPrecisionSafe,
            s = e.round,
            l = n[jn]({
                type: "interval",
                _interval: 0,
                setExtent: function(t, e) {
                    var i = this._extent;
                    isNaN(t) || (i[0] = parseFloat(t)),
                    isNaN(e) || (i[1] = parseFloat(e))
                },
                unionExtent: function(t) {
                    var e = this._extent;
                    t[0] < e[0] && (e[0] = t[0]),
                    t[1] > e[1] && (e[1] = t[1]),
                    l[xr][Zi].call(this, e[0], e[1])
                },
                getInterval: function() {
                    return this._interval || this.niceTicks(),
                    this._interval
                },
                setInterval: function(t) {
                    this._interval = t,
                    this._niceExtent = this._extent.slice()
                },
                getTicks: function() {
                    this._interval || this.niceTicks();
                    var t = this._interval,
                    e = this._extent,
                    i = [],
                    n = 1e4;
                    if (t) {
                        var r = this._niceExtent,
                        a = o(t) + 2;
                        e[0] < r[0] && i.push(e[0]);
                        for (var l = r[0]; l <= r[1];) if (i.push(l), l = s(l + t, a), i[Wn] > n) return [];
                        e[1] > r[1] && i.push(e[1])
                    }
                    return i
                },
                getTicksLabels: function() {
                    for (var t = [], e = this[qi](), i = 0; i < e[Wn]; i++) t.push(this[Wi](e[i]));
                    return t
                },
                getLabel: function(t) {
                    return i[ze](t)
                },
                niceTicks: function(t) {
                    t = t || 5;
                    var i = this._extent,
                    n = i[1] - i[0];
                    if (isFinite(n)) {
                        0 > n && (n = -n, i[S]());
                        var l = s(e.nice(n / t, !0), Math.max(o(i[0]), o(i[1])) + 2),
                        u = o(l) + 2,
                        c = [s(a(i[0] / l) * l, u), s(r(i[1] / l) * l, u)];
                        this._interval = l,
                        this._niceExtent = c
                    }
                },
                niceExtent: function(t, e, i) {
                    var n = this._extent;
                    if (n[0] === n[1]) if (0 !== n[0]) {
                        var o = n[0];
                        i ? n[0] -= o / 2 : (n[1] += o / 2, n[0] -= o / 2)
                    } else n[1] = 1;
                    var l = n[1] - n[0];
                    isFinite(l) || (n[0] = 0, n[1] = 1),
                    this.niceTicks(t);
                    var u = this._interval;
                    e || (n[0] = s(r(n[0] / u) * u)),
                    i || (n[1] = s(a(n[1] / u) * u))
                }
            });
            return l[ir] = function() {
                return new l
            },
            l
        }),
        e("echarts/scale/Scale", [Tr, "../util/clazz"],
        function(t) {
            function e() {
                this._extent = [1 / 0, -1 / 0],
                this._interval = 0,
                this.init && this.init.apply(this, arguments)
            }
            var i = t("../util/clazz"),
            n = e[xr];
            return n.parse = function(t) {
                return t
            },
            n[ji] = function(t) {
                var e = this._extent;
                return t >= e[0] && t <= e[1]
            },
            n[Ui] = function(t) {
                var e = this._extent;
                return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0])
            },
            n.scale = function(t) {
                var e = this._extent;
                return t * (e[1] - e[0]) + e[0]
            },
            n[Hi] = function(t) {
                var e = this._extent;
                t[0] < e[0] && (e[0] = t[0]),
                t[1] > e[1] && (e[1] = t[1])
            },
            n[Fi] = function() {
                return this._extent.slice()
            },
            n[Zi] = function(t, e) {
                var i = this._extent;
                isNaN(t) || (i[0] = t),
                isNaN(e) || (i[1] = e)
            },
            n.getTicksLabels = function() {
                for (var t = [], e = this[qi](), i = 0; i < e[Wn]; i++) t.push(this[Wi](e[i]));
                return t
            },
            i.enableClassExtend(e),
            i.enableClassManagement(e, {
                registerWhenExtend: !0
            }),
            e
        }),
        e("echarts/model/globalDefault", [],
        function() {
            var t = "";
            return typeof navigator !== Be && (t = navigator.platform || ""),
            {
                color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
                textStyle: {
                    fontFamily: t.match(/^Win/) ? "Microsoft YaHei": "sans-serif",
                    fontSize: 12,
                    fontStyle: "normal",
                    fontWeight: "normal"
                },
                blendMode: null,
                animation: !0,
                animationDuration: 1e3,
                animationDurationUpdate: 300,
                animationEasing: "exponentialOut",
                animationEasingUpdate: "cubicOut",
                animationThreshold: 2e3,
                progressiveThreshold: 3e3,
                progressive: 400,
                hoverLayerThreshold: 3e3
            }
        }),
        e("echarts/model/mixin/colorPalette", [],
        function() {
            return {
                clearColorPalette: function() {
                    this._colorIdx = 0,
                    this._colorNameMap = {}
                },
                getColorFromPalette: function(t, e) {
                    e = e || this;
                    var i = e._colorIdx || 0,
                    n = e._colorNameMap || (e._colorNameMap = {});
                    if (n[t]) return n[t];
                    var r = this.get("color", !0) || [];
                    if (r[Wn]) {
                        var a = r[i];
                        return t && (n[t] = a),
                        e._colorIdx = (i + 1) % r[Wn],
                        a
                    }
                }
            }
        }),
        e("zrender/tool/path", [Tr, "../graphic/Path", "../core/PathProxy", "./transformPath", "../core/matrix"],
        function(t) {
            function e(t, e, i, n, r, a, o, s, l, u, p) {
                var m = l * (f / 180),
                y = d(m) * (t - i) / 2 + h(m) * (e - n) / 2,
                x = -1 * h(m) * (t - i) / 2 + d(m) * (e - n) / 2,
                _ = y * y / (o * o) + x * x / (s * s);
                _ > 1 && (o *= c(_), s *= c(_));
                var w = (r === a ? -1 : 1) * c((o * o * s * s - o * o * x * x - s * s * y * y) / (o * o * x * x + s * s * y * y)) || 0,
                b = w * o * x / s,
                M = w * -s * y / o,
                S = (t + i) / 2 + d(m) * b - h(m) * M,
                A = (e + n) / 2 + h(m) * b + d(m) * M,
                T = g([1, 0], [(y - b) / o, (x - M) / s]),
                C = [(y - b) / o, (x - M) / s],
                L = [( - 1 * y - b) / o, ( - 1 * x - M) / s],
                k = g(C, L);
                v(C, L) <= -1 && (k = f),
                v(C, L) >= 1 && (k = 0),
                0 === a && k > 0 && (k -= 2 * f),
                1 === a && 0 > k && (k += 2 * f),
                p.addData(u, S, A, o, s, T, k, m, a)
            }
            function i(t) {
                if (!t) return [];
                var i, n = t[Tn](/-/g, " -")[Tn](/  /g, " ")[Tn](/ /g, ",")[Tn](/,,/g, ",");
                for (i = 0; i < u[Wn]; i++) n = n[Tn](new RegExp(u[i], "g"), "|" + u[i]);
                var r, a = n.split("|"),
                s = 0,
                l = 0,
                c = new o,
                h = o.CMD;
                for (i = 1; i < a[Wn]; i++) {
                    var d, f = a[i],
                    p = f.charAt(0),
                    v = 0,
                    g = f.slice(1)[Tn](/e,-/g, "e-").split(",");
                    g[Wn] > 0 && "" === g[0] && g.shift();
                    for (var m = 0; m < g[Wn]; m++) g[m] = parseFloat(g[m]);
                    for (; v < g[Wn] && !isNaN(g[v]) && !isNaN(g[0]);) {
                        var y, x, _, w, b, M, S, A = s,
                        T = l;
                        switch (p) {
                        case "l":
                            s += g[v++],
                            l += g[v++],
                            d = h.L,
                            c.addData(d, s, l);
                            break;
                        case "L":
                            s = g[v++],
                            l = g[v++],
                            d = h.L,
                            c.addData(d, s, l);
                            break;
                        case "m":
                            s += g[v++],
                            l += g[v++],
                            d = h.M,
                            c.addData(d, s, l),
                            p = "l";
                            break;
                        case "M":
                            s = g[v++],
                            l = g[v++],
                            d = h.M,
                            c.addData(d, s, l),
                            p = "L";
                            break;
                        case "h":
                            s += g[v++],
                            d = h.L,
                            c.addData(d, s, l);
                            break;
                        case "H":
                            s = g[v++],
                            d = h.L,
                            c.addData(d, s, l);
                            break;
                        case "v":
                            l += g[v++],
                            d = h.L,
                            c.addData(d, s, l);
                            break;
                        case "V":
                            l = g[v++],
                            d = h.L,
                            c.addData(d, s, l);
                            break;
                        case "C":
                            d = h.C,
                            c.addData(d, g[v++], g[v++], g[v++], g[v++], g[v++], g[v++]),
                            s = g[v - 2],
                            l = g[v - 1];
                            break;
                        case "c":
                            d = h.C,
                            c.addData(d, g[v++] + s, g[v++] + l, g[v++] + s, g[v++] + l, g[v++] + s, g[v++] + l),
                            s += g[v - 2],
                            l += g[v - 1];
                            break;
                        case "S":
                            y = s,
                            x = l;
                            var C = c.len(),
                            L = c.data;
                            r === h.C && (y += s - L[C - 4], x += l - L[C - 3]),
                            d = h.C,
                            A = g[v++],
                            T = g[v++],
                            s = g[v++],
                            l = g[v++],
                            c.addData(d, y, x, A, T, s, l);
                            break;
                        case "s":
                            y = s,
                            x = l;
                            var C = c.len(),
                            L = c.data;
                            r === h.C && (y += s - L[C - 4], x += l - L[C - 3]),
                            d = h.C,
                            A = s + g[v++],
                            T = l + g[v++],
                            s += g[v++],
                            l += g[v++],
                            c.addData(d, y, x, A, T, s, l);
                            break;
                        case "Q":
                            A = g[v++],
                            T = g[v++],
                            s = g[v++],
                            l = g[v++],
                            d = h.Q,
                            c.addData(d, A, T, s, l);
                            break;
                        case "q":
                            A = g[v++] + s,
                            T = g[v++] + l,
                            s += g[v++],
                            l += g[v++],
                            d = h.Q,
                            c.addData(d, A, T, s, l);
                            break;
                        case "T":
                            y = s,
                            x = l;
                            var C = c.len(),
                            L = c.data;
                            r === h.Q && (y += s - L[C - 4], x += l - L[C - 3]),
                            s = g[v++],
                            l = g[v++],
                            d = h.Q,
                            c.addData(d, y, x, s, l);
                            break;
                        case "t":
                            y = s,
                            x = l;
                            var C = c.len(),
                            L = c.data;
                            r === h.Q && (y += s - L[C - 4], x += l - L[C - 3]),
                            s += g[v++],
                            l += g[v++],
                            d = h.Q,
                            c.addData(d, y, x, s, l);
                            break;
                        case "A":
                            _ = g[v++],
                            w = g[v++],
                            b = g[v++],
                            M = g[v++],
                            S = g[v++],
                            A = s,
                            T = l,
                            s = g[v++],
                            l = g[v++],
                            d = h.A,
                            e(A, T, s, l, M, S, _, w, b, d, c);
                            break;
                        case "a":
                            _ = g[v++],
                            w = g[v++],
                            b = g[v++],
                            M = g[v++],
                            S = g[v++],
                            A = s,
                            T = l,
                            s += g[v++],
                            l += g[v++],
                            d = h.A,
                            e(A, T, s, l, M, S, _, w, b, d, c)
                        }
                    } ("z" === p || "Z" === p) && (d = h.Z, c.addData(d)),
                    r = d
                }
                return c.toStatic(),
                c
            }
            function n(t, e) {
                var n, r = i(t);
                return e = e || {},
                e.buildPath = function(t) {
                    t.setData(r.data),
                    n && s(t, n);
                    var e = t.getContext();
                    e && t.rebuildPath(e)
                },
                e[_e] = function(t) {
                    n || (n = l[ir]()),
                    l.mul(n, t, n),
                    this.dirty(!0)
                },
                e
            }
            var r = t("../graphic/Path"),
            o = t("../core/PathProxy"),
            s = t("./transformPath"),
            l = t("../core/matrix"),
            u = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"],
            c = Math.sqrt,
            h = Math.sin,
            d = Math.cos,
            f = Math.PI,
            p = function(t) {
                return Math.sqrt(t[0] * t[0] + t[1] * t[1])
            },
            v = function(t, e) {
                return (t[0] * e[0] + t[1] * e[1]) / (p(t) * p(e))
            },
            g = function(t, e) {
                return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(v(t, e))
            };
            return {
                createFromString: function(t, e) {
                    return new r(n(t, e))
                },
                extendFromString: function(t, e) {
                    return r[jn](n(t, e))
                },
                mergePath: function(t, e) {
                    for (var i = [], n = t[Wn], o = 0; n > o; o++) {
                        var s = t[o];
                        s[a] && s.buildPath(s.path, s.shape, !0),
                        i.push(s.path)
                    }
                    var l = new r(e);
                    return l.buildPath = function(t) {
                        t.appendPath(i);
                        var e = t.getContext();
                        e && t.rebuildPath(e)
                    },
                    l
                }
            }
        }),
        e("zrender/graphic/Path", [Tr, "./Displayable", r, "../core/PathProxy", "../contain/path", "./Pattern"],
        function(t) {
            function e(t) {
                i.call(this, t),
                this.path = new o
            }
            var i = t("./Displayable"),
            n = t(r),
            o = t("../core/PathProxy"),
            s = t("../contain/path"),
            l = t("./Pattern"),
            u = l[xr].getCanvasPattern,
            c = Math.abs;
            return e[xr] = {
                constructor: e,
                type: "path",
                __dirtyPath: !0,
                strokeContainThreshold: 5,
                brush: function(t, e) {
                    var i = this.style,
                    n = this.path,
                    r = i.hasStroke(),
                    o = i.hasFill(),
                    s = i.fill,
                    l = i[ye],
                    c = o && !!s.colorStops,
                    h = r && !!l.colorStops,
                    d = o && !!s.image,
                    f = r && !!l.image;
                    if (i.bind(t, this, e), this.setTransform(t), this[a]) {
                        var p = this[en]();
                        c && (this._fillGradient = i.getGradient(t, s, p)),
                        h && (this._strokeGradient = i.getGradient(t, l, p))
                    }
                    c ? t.fillStyle = this._fillGradient: d && (t.fillStyle = u.call(s, t)),
                    h ? t.strokeStyle = this._strokeGradient: f && (t.strokeStyle = u.call(l, t));
                    var v = i.lineDash,
                    g = i.lineDashOffset,
                    m = !!t.setLineDash,
                    y = this.getGlobalScale();
                    n.setScale(y[0], y[1]),
                    this.__dirtyPath || v && !m && r ? (n = this.path.beginPath(t), v && !m && (n.setLineDash(v), n.setLineDashOffset(g)), this.buildPath(n, this.shape, !1), this.__dirtyPath = !1) : (t.beginPath(), this.path.rebuildPath(t)),
                    o && n.fill(t),
                    v && m && (t.setLineDash(v), t.lineDashOffset = g),
                    r && n[ye](t),
                    v && m && t.setLineDash([]),
                    this.restoreTransform(t),
                    (i.text || 0 === i.text) && this.drawRectText(t, this[en]())
                },
                buildPath: function() {},
                getBoundingRect: function() {
                    var t = this._rect,
                    e = this.style,
                    i = !t;
                    if (i) {
                        var n = this.path;
                        this.__dirtyPath && (n.beginPath(), this.buildPath(n, this.shape, !1)),
                        t = n[en]()
                    }
                    if (this._rect = t, e.hasStroke()) {
                        var r = this._rectWithStroke || (this._rectWithStroke = t.clone());
                        if (this[a] || i) {
                            r.copy(t);
                            var o = e[xe],
                            s = e.strokeNoScale ? this.getLineScale() : 1;
                            e.hasFill() || (o = Math.max(o, this.strokeContainThreshold || 4)),
                            s > 1e-10 && (r.width += o / s, r[nr] += o / s, r.x -= o / s / 2, r.y -= o / s / 2)
                        }
                        return r
                    }
                    return t
                },
                contain: function(t, e) {
                    var i = this.transformCoordToLocal(t, e),
                    n = this[en](),
                    r = this.style;
                    if (t = i[0], e = i[1], n[ji](t, e)) {
                        var a = this.path.data;
                        if (r.hasStroke()) {
                            var o = r[xe],
                            l = r.strokeNoScale ? this.getLineScale() : 1;
                            if (l > 1e-10 && (r.hasFill() || (o = Math.max(o, this.strokeContainThreshold)), s.containStroke(a, o / l, t, e))) return ! 0
                        }
                        if (r.hasFill()) return s[ji](a, t, e)
                    }
                    return ! 1
                },
                dirty: function(t) {
                    null == t && (t = !0),
                    t && (this.__dirtyPath = t, this._rect = null),
                    this[a] = !0,
                    this.__zr && this.__zr.refresh(),
                    this.__clipTarget && this.__clipTarget.dirty()
                },
                animateShape: function(t) {
                    return this[wi]("shape", t)
                },
                attrKV: function(t, e) {
                    "shape" === t ? (this[ci](e), this.__dirtyPath = !0, this._rect = null) : i[xr].attrKV.call(this, t, e)
                },
                setShape: function(t, e) {
                    var i = this.shape;
                    if (i) {
                        if (n[Yn](t)) for (var r in t) i[r] = t[r];
                        else i[t] = e;
                        this.dirty(!0)
                    }
                    return this
                },
                getLineScale: function() {
                    var t = this[k];
                    return t && c(t[0] - 1) > 1e-10 && c(t[3] - 1) > 1e-10 ? Math.sqrt(c(t[0] * t[3] - t[2] * t[1])) : 1
                }
            },
            e[jn] = function(t) {
                var i = function(i) {
                    e.call(this, i),
                    t.style && this.style.extendFrom(t.style, !1);
                    var n = t.shape;
                    if (n) {
                        this.shape = this.shape || {};
                        var r = this.shape;
                        for (var a in n) ! r.hasOwnProperty(a) && n.hasOwnProperty(a) && (r[a] = n[a])
                    }
                    t.init && t.init.call(this, i)
                };
                n[vn](i, e);
                for (var r in t)"style" !== r && "shape" !== r && (i[xr][r] = t[r]);
                return i
            },
            n[vn](e, i),
            e
        }),
        e("zrender/container/Group", [Tr, r, "../Element", "../core/BoundingRect"],
        function(t) {
            var e = t(r),
            i = t("../Element"),
            n = t("../core/BoundingRect"),
            o = function(t) {
                t = t || {},
                i.call(this, t);
                for (var e in t) this[e] = t[e];
                this._children = [],
                this.__storage = null,
                this[a] = !0
            };
            return o[xr] = {
                constructor: o,
                isGroup: !0,
                type: "group",
                silent: !1,
                children: function() {
                    return this._children.slice()
                },
                childAt: function(t) {
                    return this._children[t]
                },
                childOfName: function(t) {
                    for (var e = this._children,
                    i = 0; i < e[Wn]; i++) if (e[i].name === t) return e[i]
                },
                childCount: function() {
                    return this._children[Wn]
                },
                add: function(t) {
                    return t && t !== this && t[pe] !== this && (this._children.push(t), this._doAdd(t)),
                    this
                },
                addBefore: function(t, e) {
                    if (t && t !== this && t[pe] !== this && e && e[pe] === this) {
                        var i = this._children,
                        n = i[gn](e);
                        n >= 0 && (i[Gn](n, 0, t), this._doAdd(t))
                    }
                    return this
                },
                _doAdd: function(t) {
                    t[pe] && t[pe][Xn](t),
                    t[pe] = this;
                    var e = this.__storage,
                    i = this.__zr;
                    e && e !== t.__storage && (e.addToMap(t), t instanceof o && t.addChildrenToStorage(e)),
                    i && i.refresh()
                },
                remove: function(t) {
                    var i = this.__zr,
                    n = this.__storage,
                    r = this._children,
                    a = e[gn](r, t);
                    return 0 > a ? this: (r[Gn](a, 1), t[pe] = null, n && (n.delFromMap(t.id), t instanceof o && t.delChildrenFromStorage(n)), i && i.refresh(), this)
                },
                removeAll: function() {
                    var t, e, i = this._children,
                    n = this.__storage;
                    for (e = 0; e < i[Wn]; e++) t = i[e],
                    n && (n.delFromMap(t.id), t instanceof o && t.delChildrenFromStorage(n)),
                    t[pe] = null;
                    return i[Wn] = 0,
                    this
                },
                eachChild: function(t, e) {
                    for (var i = this._children,
                    n = 0; n < i[Wn]; n++) {
                        var r = i[n];
                        t.call(e, r, n)
                    }
                    return this
                },
                traverse: function(t, e) {
                    for (var i = 0; i < this._children[Wn]; i++) {
                        var n = this._children[i];
                        t.call(e, n),
                        "group" === n.type && n[kn](t, e)
                    }
                    return this
                },
                addChildrenToStorage: function(t) {
                    for (var e = 0; e < this._children[Wn]; e++) {
                        var i = this._children[e];
                        t.addToMap(i),
                        i instanceof o && i.addChildrenToStorage(t)
                    }
                },
                delChildrenFromStorage: function(t) {
                    for (var e = 0; e < this._children[Wn]; e++) {
                        var i = this._children[e];
                        t.delFromMap(i.id),
                        i instanceof o && i.delChildrenFromStorage(t)
                    }
                },
                dirty: function() {
                    return this[a] = !0,
                    this.__zr && this.__zr.refresh(),
                    this
                },
                getBoundingRect: function(t) {
                    for (var e = null,
                    i = new n(0, 0, 0, 0), r = t || this._children, a = [], o = 0; o < r[Wn]; o++) {
                        var s = r[o];
                        if (!s[ar] && !s[M]) {
                            var l = s[en](),
                            u = s[ve](a);
                            u ? (i.copy(l), i[_e](u), e = e || i.clone(), e.union(i)) : (e = e || l.clone(), e.union(l))
                        }
                    }
                    return e || i
                }
            },
            e[vn](o, i),
            o
        }),
        e("zrender/vml/graphic", [Tr, "../core/env", "../core/vector", "../core/BoundingRect", "../core/PathProxy", "../tool/color", "../contain/text", "../graphic/mixin/RectText", "../graphic/Displayable", "../graphic/Image", "../graphic/Text", "../graphic/Path", "../graphic/Gradient", "./core"],
        function(t) {
            if (!t("../core/env")[cr]) {
                var e = t("../core/vector"),
                i = t("../core/BoundingRect"),
                n = t("../core/PathProxy").CMD,
                r = t("../tool/color"),
                a = t("../contain/text"),
                o = t("../graphic/mixin/RectText"),
                s = t("../graphic/Displayable"),
                l = t("../graphic/Image"),
                u = t("../graphic/Text"),
                c = t("../graphic/Path"),
                h = t("../graphic/Gradient"),
                d = t("./core"),
                f = Math.round,
                p = Math.sqrt,
                v = Math.abs,
                g = Math.cos,
                m = Math.sin,
                y = Math.max,
                x = e[_e],
                _ = ",",
                w = "progid:DXImageTransform.Microsoft",
                M = 21600,
                S = M / 2,
                T = 1e5,
                C = 1e3,
                L = function(t) {
                    t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;",
                    t.coordsize = M + "," + M,
                    t.coordorigin = "0,0"
                },
                P = function(t) {
                    return String(t)[Tn](/&/g, "&amp;")[Tn](/"/g, "&quot;")
                },
                I = function(t, e, i) {
                    return "rgb(" + [t, e, i].join(",") + ")"
                },
                D = function(t, e) {
                    e && t && e[A] !== t && t.appendChild(e)
                },
                z = function(t, e) {
                    e && t && e[A] === t && t.removeChild(e)
                },
                V = function(t, e, i) {
                    return (parseFloat(t) || 0) * T + (parseFloat(e) || 0) * C + i
                },
                R = function(t, e) {
                    return typeof t === yr ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e: parseFloat(t) : t
                },
                O = function(t, e, i) {
                    var n = r.parse(e);
                    i = +i,
                    isNaN(i) && (i = 1),
                    n && (t.color = I(n[0], n[1], n[2]), t[Yi] = i * n[3])
                },
                E = function(t) {
                    var e = r.parse(t);
                    return [I(e[0], e[1], e[2]), e[3]]
                },
                N = function(t, e, i) {
                    var n = e.fill;
                    if (null != n) if (n instanceof h) {
                        var r, a = 0,
                        o = [0, 0],
                        s = 0,
                        l = 1,
                        u = i[en](),
                        c = u.width,
                        d = u[nr];
                        if (n.type === b) {
                            r = "gradient";
                            var f = i[k],
                            p = [n.x * c, n.y * d],
                            v = [n.x2 * c, n.y2 * d];
                            f && (x(p, p, f), x(v, v, f));
                            var g = v[0] - p[0],
                            m = v[1] - p[1];
                            a = 180 * Math.atan2(g, m) / Math.PI,
                            0 > a && (a += 360),
                            1e-6 > a && (a = 0)
                        } else {
                            r = "gradientradial";
                            var p = [n.x * c, n.y * d],
                            f = i[k],
                            _ = i.scale,
                            w = c,
                            S = d;
                            o = [(p[0] - u.x) / w, (p[1] - u.y) / S],
                            f && x(p, p, f),
                            w /= _[0] * M,
                            S /= _[1] * M;
                            var A = y(w, S);
                            s = 0 / A,
                            l = 2 * n.r / A - s
                        }
                        var T = n.colorStops.slice();
                        T.sort(function(t, e) {
                            return t.offset - e.offset
                        });
                        for (var C = T[Wn], L = [], P = [], I = 0; C > I; I++) {
                            var D = T[I],
                            z = E(D.color);
                            P.push(D.offset * l + s + " " + z[0]),
                            (0 === I || I === C - 1) && L.push(z)
                        }
                        if (C >= 2) {
                            var V = L[0][0],
                            R = L[1][0],
                            N = L[0][1] * e[Yi],
                            B = L[1][1] * e[Yi];
                            t.type = r,
                            t.method = "none",
                            t.focus = "100%",
                            t.angle = a,
                            t.color = V,
                            t.color2 = R,
                            t.colors = P.join(","),
                            t[Yi] = B,
                            t.opacity2 = N
                        }
                        "radial" === r && (t.focusposition = o.join(","))
                    } else O(t, n, e[Yi])
                },
                B = function(t, e) {
                    null != e.lineDash && (t.dashstyle = e.lineDash.join(" ")),
                    null == e[ye] || e[ye] instanceof h || O(t, e[ye], e[Yi])
                },
                G = function(t, e, i, n) {
                    var r = "fill" == e,
                    a = t.getElementsByTagName(e)[0];
                    null != i[e] && "none" !== i[e] && (r || !r && i[xe]) ? (t[r ? "filled": "stroked"] = "true", i[e] instanceof h && z(t, a), a || (a = d.createNode(e)), r ? N(a, i, n) : B(a, i), D(t, a)) : (t[r ? "filled": "stroked"] = "false", z(t, a))
                },
                H = [[], [], []],
                F = function(t, e) {
                    var i, r, a, o, s, l, u = n.M,
                    c = n.C,
                    h = n.L,
                    d = n.A,
                    v = n.Q,
                    y = [];
                    for (o = 0; o < t[Wn];) {
                        switch (a = t[o++], r = "", i = 0, a) {
                        case u:
                            r = " m ",
                            i = 1,
                            s = t[o++],
                            l = t[o++],
                            H[0][0] = s,
                            H[0][1] = l;
                            break;
                        case h:
                            r = " l ",
                            i = 1,
                            s = t[o++],
                            l = t[o++],
                            H[0][0] = s,
                            H[0][1] = l;
                            break;
                        case v:
                        case c:
                            r = " c ",
                            i = 3;
                            var w, b, A = t[o++],
                            T = t[o++],
                            C = t[o++],
                            L = t[o++];
                            a === v ? (w = C, b = L, C = (C + 2 * A) / 3, L = (L + 2 * T) / 3, A = (s + 2 * A) / 3, T = (l + 2 * T) / 3) : (w = t[o++], b = t[o++]),
                            H[0][0] = A,
                            H[0][1] = T,
                            H[1][0] = C,
                            H[1][1] = L,
                            H[2][0] = w,
                            H[2][1] = b,
                            s = w,
                            l = b;
                            break;
                        case d:
                            var k = 0,
                            P = 0,
                            I = 1,
                            D = 1,
                            z = 0;
                            e && (k = e[4], P = e[5], I = p(e[0] * e[0] + e[1] * e[1]), D = p(e[2] * e[2] + e[3] * e[3]), z = Math.atan2( - e[1] / D, e[0] / I));
                            var V = t[o++],
                            R = t[o++],
                            O = t[o++],
                            E = t[o++],
                            N = t[o++] + z,
                            B = t[o++] + N + z;
                            o++;
                            var G = t[o++],
                            F = V + g(N) * O,
                            Z = R + m(N) * E,
                            A = V + g(B) * O,
                            T = R + m(B) * E,
                            W = G ? " wa ": " at ";
                            Math.abs(F - A) < 1e-10 && (Math.abs(B - N) > .01 ? G && (F += 270 / M) : Math.abs(Z - R) < 1e-10 ? G && V > F || !G && F > V ? T -= 270 / M: T += 270 / M: G && R > Z || !G && Z > R ? A += 270 / M: A -= 270 / M),
                            y.push(W, f(((V - O) * I + k) * M - S), _, f(((R - E) * D + P) * M - S), _, f(((V + O) * I + k) * M - S), _, f(((R + E) * D + P) * M - S), _, f((F * I + k) * M - S), _, f((Z * D + P) * M - S), _, f((A * I + k) * M - S), _, f((T * D + P) * M - S)),
                            s = A,
                            l = T;
                            break;
                        case n.R:
                            var q = H[0],
                            U = H[1];
                            q[0] = t[o++],
                            q[1] = t[o++],
                            U[0] = q[0] + t[o++],
                            U[1] = q[1] + t[o++],
                            e && (x(q, q, e), x(U, U, e)),
                            q[0] = f(q[0] * M - S),
                            U[0] = f(U[0] * M - S),
                            q[1] = f(q[1] * M - S),
                            U[1] = f(U[1] * M - S),
                            y.push(" m ", q[0], _, q[1], " l ", U[0], _, q[1], " l ", U[0], _, U[1], " l ", q[0], _, U[1]);
                            break;
                        case n.Z:
                            y.push(" x ")
                        }
                        if (i > 0) {
                            y.push(r);
                            for (var j = 0; i > j; j++) {
                                var X = H[j];
                                e && x(X, X, e),
                                y.push(f(X[0] * M - S), _, f(X[1] * M - S), i - 1 > j ? _: "")
                            }
                        }
                    }
                    return y.join("")
                };
                c[xr].brushVML = function(t) {
                    var e = this.style,
                    i = this._vmlEl;
                    i || (i = d.createNode("shape"), L(i), this._vmlEl = i),
                    G(i, "fill", e, this),
                    G(i, ye, e, this);
                    var n = this[k],
                    r = null != n,
                    a = i.getElementsByTagName(ye)[0];
                    if (a) {
                        var o = e[xe];
                        if (r && !e.strokeNoScale) {
                            var s = n[0] * n[3] - n[1] * n[2];
                            o *= p(v(s))
                        }
                        a.weight = o + "px"
                    }
                    var l = this.path;
                    this.__dirtyPath && (l.beginPath(), this.buildPath(l, this.shape), l.toStatic(), this.__dirtyPath = !1),
                    i.path = F(l.data, this[k]),
                    i.style.zIndex = V(this[Cn], this.z, this.z2),
                    D(t, i),
                    e.text ? this.drawRectText(t, this[en]()) : this.removeRectText(t)
                },
                c[xr].onRemove = function(t) {
                    z(t, this._vmlEl),
                    this.removeRectText(t)
                },
                c[xr].onAdd = function(t) {
                    D(t, this._vmlEl),
                    this.appendRectText(t)
                };
                var W = function(t) {
                    return "object" == typeof t && t.tagName && "IMG" === t.tagName.toUpperCase()
                };
                l[xr].brushVML = function(t) {
                    var e, i, n = this.style,
                    r = n.image;
                    if (W(r)) {
                        var a = r.src;
                        if (a === this._imageSrc) e = this._imageWidth,
                        i = this._imageHeight;
                        else {
                            var o = r.runtimeStyle,
                            s = o.width,
                            l = o[nr];
                            o.width = "auto",
                            o[nr] = "auto",
                            e = r.width,
                            i = r[nr],
                            o.width = s,
                            o[nr] = l,
                            this._imageSrc = a,
                            this._imageWidth = e,
                            this._imageHeight = i
                        }
                        r = a
                    } else r === this._imageSrc && (e = this._imageWidth, i = this._imageHeight);
                    if (r) {
                        var u = n.x || 0,
                        c = n.y || 0,
                        h = n.width,
                        v = n[nr],
                        g = n.sWidth,
                        m = n.sHeight,
                        b = n.sx || 0,
                        M = n.sy || 0,
                        S = g && m,
                        T = this._vmlEl;
                        T || (T = d.doc[Ti]("div"), L(T), this._vmlEl = T);
                        var C, P = T.style,
                        I = !1,
                        z = 1,
                        R = 1;
                        if (this[k] && (C = this[k], z = p(C[0] * C[0] + C[1] * C[1]), R = p(C[2] * C[2] + C[3] * C[3]), I = C[1] || C[2]), I) {
                            var O = [u, c],
                            E = [u + h, c],
                            N = [u, c + v],
                            B = [u + h, c + v];
                            x(O, O, C),
                            x(E, E, C),
                            x(N, N, C),
                            x(B, B, C);
                            var G = y(O[0], E[0], N[0], B[0]),
                            H = y(O[1], E[1], N[1], B[1]),
                            F = [];
                            F.push("M11=", C[0] / z, _, "M12=", C[2] / R, _, "M21=", C[1] / z, _, "M22=", C[3] / R, _, "Dx=", f(u * z + C[4]), _, "Dy=", f(c * R + C[5])),
                            P.padding = "0 " + f(G) + "px " + f(H) + "px 0",
                            P[mn] = w + ".Matrix(" + F.join("") + ", SizingMethod=clip)"
                        } else C && (u = u * z + C[4], c = c * R + C[5]),
                        P[mn] = "",
                        P.left = f(u) + "px",
                        P.top = f(c) + "px";
                        var Z = this._imageEl,
                        q = this._cropEl;
                        Z || (Z = d.doc[Ti]("div"), this._imageEl = Z);
                        var U = Z.style;
                        if (S) {
                            if (e && i) U.width = f(z * e * h / g) + "px",
                            U[nr] = f(R * i * v / m) + "px";
                            else {
                                var j = new Image,
                                X = this;
                                j.onload = function() {
                                    j.onload = null,
                                    e = j.width,
                                    i = j[nr],
                                    U.width = f(z * e * h / g) + "px",
                                    U[nr] = f(R * i * v / m) + "px",
                                    X._imageWidth = e,
                                    X._imageHeight = i,
                                    X._imageSrc = r
                                },
                                j.src = r
                            }
                            q || (q = d.doc[Ti]("div"), q.style.overflow = "hidden", this._cropEl = q);
                            var Y = q.style;
                            Y.width = f((h + b * h / g) * z),
                            Y[nr] = f((v + M * v / m) * R),
                            Y[mn] = w + ".Matrix(Dx=" + -b * h / g * z + ",Dy=" + -M * v / m * R + ")",
                            q[A] || T.appendChild(q),
                            Z[A] != q && q.appendChild(Z)
                        } else U.width = f(z * h) + "px",
                        U[nr] = f(R * v) + "px",
                        T.appendChild(Z),
                        q && q[A] && (T.removeChild(q), this._cropEl = null);
                        var $ = "",
                        J = n[Yi];
                        1 > J && ($ += ".Alpha(opacity=" + f(100 * J) + ") "),
                        $ += w + ".AlphaImageLoader(src=" + r + ", SizingMethod=scale)",
                        U[mn] = $,
                        T.style.zIndex = V(this[Cn], this.z, this.z2),
                        D(t, T),
                        n.text && this.drawRectText(t, this[en]())
                    }
                },
                l[xr].onRemove = function(t) {
                    z(t, this._vmlEl),
                    this._vmlEl = null,
                    this._cropEl = null,
                    this._imageEl = null,
                    this.removeRectText(t)
                },
                l[xr].onAdd = function(t) {
                    D(t, this._vmlEl),
                    this.appendRectText(t)
                };
                var q, U = ki,
                j = {},
                X = 0,
                Y = 100,
                $ = document[Ti]("div"),
                J = function(t) {
                    var e = j[t];
                    if (!e) {
                        X > Y && (X = 0, j = {});
                        var i, n = $.style;
                        try {
                            n.font = t,
                            i = n.fontFamily.split(",")[0]
                        } catch(r) {}
                        e = {
                            style: n.fontStyle || U,
                            variant: n.fontVariant || U,
                            weight: n.fontWeight || U,
                            size: 0 | parseFloat(n.fontSize || 12),
                            family: i || "Microsoft YaHei"
                        },
                        j[t] = e,
                        X++
                    }
                    return e
                };
                a.measureText = function(t, e) {
                    var i = d.doc;
                    q || (q = i[Ti]("div"), q.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", d.doc.body.appendChild(q));
                    try {
                        q.style.font = e
                    } catch(n) {}
                    return q.innerHTML = "",
                    q.appendChild(i.createTextNode(t)),
                    {
                        width: q.offsetWidth
                    }
                };
                for (var Q = new i,
                K = function(t, e, i, n) {
                    var r = this.style,
                    o = r.text;
                    if (o) {
                        var s, l, u = r[an],
                        c = J(r.textFont),
                        h = c.style + " " + c.variant + " " + c.weight + " " + c.size + 'px "' + c.family + '"',
                        p = r.textBaseline,
                        v = r.textVerticalAlign;
                        i = i || a[en](o, h, u, p);
                        var g = this[k];
                        if (g && !n && (Q.copy(e), Q[_e](g), e = Q), n) s = e.x,
                        l = e.y;
                        else {
                            var m = r[Z],
                            y = r.textDistance;
                            if (m instanceof Array) s = e.x + R(m[0], e.width),
                            l = e.y + R(m[1], e[nr]),
                            u = u || "left",
                            p = p || "top";
                            else {
                                var w = a.adjustTextPositionOnRect(m, e, i, y);
                                s = w.x,
                                l = w.y,
                                u = u || w[an],
                                p = p || w.textBaseline
                            }
                        }
                        if (v) {
                            switch (v) {
                            case Qi:
                                l -= i[nr] / 2;
                                break;
                            case rr:
                                l -= i[nr]
                            }
                            p = "top"
                        }
                        var b = c.size;
                        switch (p) {
                        case "hanging":
                        case "top":
                            l += b / 1.75;
                            break;
                        case Qi:
                            break;
                        default:
                            l -= b / 2.25
                        }
                        switch (u) {
                        case "left":
                            break;
                        case Ji:
                            s -= i.width / 2;
                            break;
                        case "right":
                            s -= i.width
                        }
                        var M, S, A, T = d.createNode,
                        C = this._textVmlEl;
                        C ? (A = C.firstChild, M = A.nextSibling, S = M.nextSibling) : (C = T("line"), M = T("path"), S = T("textpath"), A = T("skew"), S.style["v-text-align"] = "left", L(C), M.textpathok = !0, S.on = !0, C.from = "0 0", C.to = "1000 0.05", D(C, A), D(C, M), D(C, S), this._textVmlEl = C);
                        var I = [s, l],
                        z = C.style;
                        g && n ? (x(I, I, g), A.on = !0, A.matrix = g[0][Ii](3) + _ + g[2][Ii](3) + _ + g[1][Ii](3) + _ + g[3][Ii](3) + ",0,0", A.offset = (f(I[0]) || 0) + "," + (f(I[1]) || 0), A.origin = "0 0", z.left = "0px", z.top = "0px") : (A.on = !1, z.left = f(s) + "px", z.top = f(l) + "px"),
                        S[yr] = P(o);
                        try {
                            S.style.font = h
                        } catch(O) {}
                        G(C, "fill", {
                            fill: n ? r.fill: r.textFill,
                            opacity: r[Yi]
                        },
                        this),
                        G(C, ye, {
                            stroke: n ? r[ye] : r.textStroke,
                            opacity: r[Yi],
                            lineDash: r.lineDash
                        },
                        this),
                        C.style.zIndex = V(this[Cn], this.z, this.z2),
                        D(t, C)
                    }
                },
                te = function(t) {
                    z(t, this._textVmlEl),
                    this._textVmlEl = null
                },
                ee = function(t) {
                    D(t, this._textVmlEl)
                },
                ie = [o, s, l, c, u], ne = 0; ne < ie[Wn]; ne++) {
                    var re = ie[ne][xr];
                    re.drawRectText = K,
                    re.removeRectText = te,
                    re.appendRectText = ee
                }
                u[xr].brushVML = function(t) {
                    var e = this.style;
                    e.text ? this.drawRectText(t, {
                        x: e.x || 0,
                        y: e.y || 0,
                        width: 0,
                        height: 0
                    },
                    this[en](), !0) : this.removeRectText(t)
                },
                u[xr].onRemove = function(t) {
                    this.removeRectText(t)
                },
                u[xr].onAdd = function(t) {
                    this.appendRectText(t)
                }
            }
        }),
        e("zrender/graphic/Gradient", [Tr],
        function() {
            var t = function(t) {
                this.colorStops = t || []
            };
            return t[xr] = {
                constructor: t,
                addColorStop: function(t, e) {
                    this.colorStops.push({
                        offset: t,
                        color: e
                    })
                }
            },
            t
        }),
        e("zrender/graphic/Image", [Tr, "./Displayable", "../core/BoundingRect", r, "../core/LRU"],
        function(t) {
            function e(t) {
                i.call(this, t)
            }
            var i = t("./Displayable"),
            n = t("../core/BoundingRect"),
            a = t(r),
            o = t("../core/LRU"),
            s = new o(50);
            return e[xr] = {
                constructor: e,
                type: "image",
                brush: function(t, e) {
                    var i, n = this.style,
                    r = n.image;
                    if (n.bind(t, this, e), i = typeof r === yr ? this._image: r, !i && r) {
                        var a = s.get(r);
                        if (!a) return i = new Image,
                        i.onload = function() {
                            i.onload = null;
                            for (var t = 0; t < a.pending[Wn]; t++) a.pending[t].dirty()
                        },
                        a = {
                            image: i,
                            pending: [this]
                        },
                        i.src = r,
                        s.put(r, a),
                        void(this._image = i);
                        if (i = a.image, this._image = i, !i.width || !i[nr]) return void a.pending.push(this)
                    }
                    if (i) {
                        var o = n.width || i.width,
                        l = n[nr] || i[nr],
                        u = n.x || 0,
                        c = n.y || 0;
                        if (!i.width || !i[nr]) return;
                        if (this.setTransform(t), n.sWidth && n.sHeight) {
                            var h = n.sx || 0,
                            d = n.sy || 0;
                            t.drawImage(i, h, d, n.sWidth, n.sHeight, u, c, o, l)
                        } else if (n.sx && n.sy) {
                            var h = n.sx,
                            d = n.sy,
                            f = o - h,
                            p = l - d;
                            t.drawImage(i, h, d, f, p, u, c, o, l)
                        } else t.drawImage(i, u, c, o, l);
                        null == n.width && (n.width = o),
                        null == n[nr] && (n[nr] = l),
                        this.restoreTransform(t),
                        null != n.text && this.drawRectText(t, this[en]())
                    }
                },
                getBoundingRect: function() {
                    var t = this.style;
                    return this._rect || (this._rect = new n(t.x || 0, t.y || 0, t.width || 0, t[nr] || 0)),
                    this._rect
                }
            },
            a[vn](e, i),
            e
        }),
        e("zrender/graphic/shape/Circle", [Tr, "../Path"],
        function(t) {
            return t("../Path")[jn]({
                type: "circle",
                shape: {
                    cx: 0,
                    cy: 0,
                    r: 0
                },
                buildPath: function(t, e, i) {
                    i && t[p](e.cx + e.r, e.cy),
                    t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0)
                }
            })
        }),
        e("zrender/graphic/Text", [Tr, "./Displayable", r, "../contain/text"],
        function(t) {
            var e = t("./Displayable"),
            i = t(r),
            n = t("../contain/text"),
            a = function(t) {
                e.call(this, t)
            };
            return a[xr] = {
                constructor: a,
                type: "text",
                brush: function(t, e) {
                    var i = this.style,
                    r = i.x || 0,
                    a = i.y || 0,
                    o = i.text;
                    if (null != o && (o += ""), i.bind(t, this, e), o) {
                        this.setTransform(t);
                        var s, l = i[an],
                        u = i.textFont || i.font;
                        if (i.textVerticalAlign) {
                            var c = n[en](o, u, i[an], "top");
                            switch (s = Qi, i.textVerticalAlign) {
                            case Qi:
                                a -= c[nr] / 2 - c.lineHeight / 2;
                                break;
                            case rr:
                                a -= c[nr] - c.lineHeight / 2;
                                break;
                            default:
                                a += c.lineHeight / 2
                            }
                        } else s = i.textBaseline;
                        t.font = u || "12px sans-serif",
                        t[an] = l || "left",
                        t[an] !== l && (t[an] = "left"),
                        t.textBaseline = s || "alphabetic",
                        t.textBaseline !== s && (t.textBaseline = "alphabetic");
                        for (var h = n.measureText("国", t.font).width, d = o.split("\n"), f = 0; f < d[Wn]; f++) i.hasFill() && t.fillText(d[f], r, a),
                        i.hasStroke() && t.strokeText(d[f], r, a),
                        a += h;
                        this.restoreTransform(t)
                    }
                },
                getBoundingRect: function() {
                    if (!this._rect) {
                        var t = this.style,
                        e = t.textVerticalAlign,
                        i = n[en](t.text + "", t.textFont || t.font, t[an], e ? "top": t.textBaseline);
                        switch (e) {
                        case Qi:
                            i.y -= i[nr] / 2;
                            break;
                        case rr:
                            i.y -= i[nr]
                        }
                        i.x += t.x || 0,
                        i.y += t.y || 0,
                        this._rect = i
                    }
                    return this._rect
                }
            },
            i[vn](a, e),
            a
        }),
        e("zrender/graphic/shape/Sector", [Tr, "../Path"],
        function(t) {
            return t("../Path")[jn]({
                type: "sector",
                shape: {
                    cx: 0,
                    cy: 0,
                    r0: 0,
                    r: 0,
                    startAngle: 0,
                    endAngle: 2 * Math.PI,
                    clockwise: !0
                },
                buildPath: function(t, e) {
                    var i = e.cx,
                    n = e.cy,
                    r = Math.max(e.r0 || 0, 0),
                    a = Math.max(e.r, 0),
                    o = e.startAngle,
                    s = e.endAngle,
                    l = e[Ye],
                    u = Math.cos(o),
                    c = Math.sin(o);
                    t[p](u * r + i, c * r + n),
                    t[d](u * a + i, c * a + n),
                    t.arc(i, n, a, o, s, !l),
                    t[d](Math.cos(s) * r + i, Math.sin(s) * r + n),
                    0 !== r && t.arc(i, n, r, s, o, l),
                    t[h]()
                }
            })
        }),
        e("zrender/graphic/shape/Ring", [Tr, "../Path"],
        function(t) {
            return t("../Path")[jn]({
                type: "ring",
                shape: {
                    cx: 0,
                    cy: 0,
                    r: 0,
                    r0: 0
                },
                buildPath: function(t, e) {
                    var i = e.cx,
                    n = e.cy,
                    r = 2 * Math.PI;
                    t[p](i + e.r, n),
                    t.arc(i, n, e.r, 0, r, !1),
                    t[p](i + e.r0, n),
                    t.arc(i, n, e.r0, 0, r, !0)
                }
            })
        }),
        e("zrender/graphic/shape/Polygon", [Tr, "../helper/poly", "../Path"],
        function(t) {
            var e = t("../helper/poly");
            return t("../Path")[jn]({
                type: "polygon",
                shape: {
                    points: null,
                    smooth: !1,
                    smoothConstraint: null
                },
                buildPath: function(t, i) {
                    e.buildPath(t, i, !0)
                }
            })
        }),
        e("zrender/graphic/shape/Rect", [Tr, "../helper/roundRect", "../Path"],
        function(t) {
            var e = t("../helper/roundRect");
            return t("../Path")[jn]({
                type: "rect",
                shape: {
                    r: 0,
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function(t, i) {
                    var n = i.x,
                    r = i.y,
                    a = i.width,
                    o = i[nr];
                    i.r ? e.buildPath(t, i) : t.rect(n, r, a, o),
                    t[h]()
                }
            })
        }),
        e("zrender/graphic/shape/Polyline", [Tr, "../helper/poly", "../Path"],
        function(t) {
            var e = t("../helper/poly");
            return t("../Path")[jn]({
                type: "polyline",
                shape: {
                    points: null,
                    smooth: !1,
                    smoothConstraint: null
                },
                style: {
                    stroke: "#000",
                    fill: null
                },
                buildPath: function(t, i) {
                    e.buildPath(t, i, !1)
                }
            })
        }),
        e("zrender/graphic/shape/BezierCurve", [Tr, "../../core/curve", "../../core/vector", "../Path"],
        function(t) {
            function e(t, e, i) {
                var n = t.cpx2,
                r = t.cpy2;
                return null === n || null === r ? [(i ? u: s)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? u: s)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? l: o)(t.x1, t.cpx1, t.x2, e), (i ? l: o)(t.y1, t.cpy1, t.y2, e)]
            }
            var i = t("../../core/curve"),
            n = t("../../core/vector"),
            r = i.quadraticSubdivide,
            a = i.cubicSubdivide,
            o = i.quadraticAt,
            s = i.cubicAt,
            l = i.quadraticDerivativeAt,
            u = i.cubicDerivativeAt,
            c = [];
            return t("../Path")[jn]({
                type: "bezier-curve",
                shape: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                    cpx1: 0,
                    cpy1: 0,
                    percent: 1
                },
                style: {
                    stroke: "#000",
                    fill: null
                },
                buildPath: function(t, e) {
                    var i = e.x1,
                    n = e.y1,
                    o = e.x2,
                    s = e.y2,
                    l = e.cpx1,
                    u = e.cpy1,
                    h = e.cpx2,
                    d = e.cpy2,
                    v = e.percent;
                    0 !== v && (t[p](i, n), null == h || null == d ? (1 > v && (r(i, l, o, v, c), l = c[1], o = c[2], r(n, u, s, v, c), u = c[1], s = c[2]), t.quadraticCurveTo(l, u, o, s)) : (1 > v && (a(i, l, h, o, v, c), l = c[1], h = c[2], o = c[3], a(n, u, d, s, v, c), u = c[1], d = c[2], s = c[3]), t[f](l, u, h, d, o, s)))
                },
                pointAt: function(t) {
                    return e(this.shape, t, !1)
                },
                tangentAt: function(t) {
                    var i = e(this.shape, t, !0);
                    return n[Ui](i, i)
                }
            })
        }),
        e("zrender/graphic/shape/Line", [Tr, "../Path"],
        function(t) {
            return t("../Path")[jn]({
                type: "line",
                shape: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                    percent: 1
                },
                style: {
                    stroke: "#000",
                    fill: null
                },
                buildPath: function(t, e) {
                    var i = e.x1,
                    n = e.y1,
                    r = e.x2,
                    a = e.y2,
                    o = e.percent;
                    0 !== o && (t[p](i, n), 1 > o && (r = i * (1 - o) + r * o, a = n * (1 - o) + a * o), t[d](r, a))
                },
                pointAt: function(t) {
                    var e = this.shape;
                    return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]
                }
            })
        }),
        e("zrender/graphic/shape/Arc", [Tr, "../Path"],
        function(t) {
            return t("../Path")[jn]({
                type: "arc",
                shape: {
                    cx: 0,
                    cy: 0,
                    r: 0,
                    startAngle: 0,
                    endAngle: 2 * Math.PI,
                    clockwise: !0
                },
                style: {
                    stroke: "#000",
                    fill: null
                },
                buildPath: function(t, e) {
                    var i = e.cx,
                    n = e.cy,
                    r = Math.max(e.r, 0),
                    a = e.startAngle,
                    o = e.endAngle,
                    s = e[Ye],
                    l = Math.cos(a),
                    u = Math.sin(a);
                    t[p](l * r + i, u * r + n),
                    t.arc(i, n, r, a, o, !s)
                }
            })
        }),
        e("zrender/graphic/CompoundPath", [Tr, "./Path"],
        function(t) {
            var e = t("./Path");
            return e[jn]({
                type: "compound",
                shape: {
                    paths: null
                },
                _updatePathDirty: function() {
                    for (var t = this.__dirtyPath,
                    e = this.shape.paths,
                    i = 0; i < e[Wn]; i++) t = t || e[i].__dirtyPath;
                    this.__dirtyPath = t,
                    this[a] = this[a] || t
                },
                beforeBrush: function() {
                    this._updatePathDirty();
                    for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t[Wn]; i++) t[i].path.setScale(e[0], e[1])
                },
                buildPath: function(t, e) {
                    for (var i = e.paths || [], n = 0; n < i[Wn]; n++) i[n].buildPath(t, i[n].shape, !0)
                },
                afterBrush: function() {
                    for (var t = this.shape.paths,
                    e = 0; e < t[Wn]; e++) t[e].__dirtyPath = !1
                },
                getBoundingRect: function() {
                    return this._updatePathDirty(),
                    e[xr][en].call(this)
                }
            })
        }),
        e("zrender/graphic/LinearGradient", [Tr, r, "./Gradient"],
        function(t) {
            var e = t(r),
            i = t("./Gradient"),
            n = function(t, e, n, r, a, o) {
                this.x = null == t ? 0 : t,
                this.y = null == e ? 0 : e,
                this.x2 = null == n ? 1 : n,
                this.y2 = null == r ? 0 : r,
                this.type = b,
                this.global = o || !1,
                i.call(this, a)
            };
            return n[xr] = {
                constructor: n
            },
            e[vn](n, i),
            n
        }),
        e("zrender/graphic/RadialGradient", [Tr, r, "./Gradient"],
        function(t) {
            var e = t(r),
            i = t("./Gradient"),
            n = function(t, e, n, r, a) {
                this.x = null == t ? .5 : t,
                this.y = null == e ? .5 : e,
                this.r = null == n ? .5 : n,
                this.type = "radial",
                this.global = a || !1,
                i.call(this, r)
            };
            return n[xr] = {
                constructor: n
            },
            e[vn](n, i),
            n
        }),
        e(Me, [Tr, "./vector", "./matrix"],
        function(t) {
            function e(t, e, i, n) {
                this.x = t,
                this.y = e,
                this.width = i,
                this[nr] = n
            }
            var i = t("./vector"),
            n = t("./matrix"),
            r = i[_e],
            a = Math.min,
            o = Math.abs,
            s = Math.max;
            return e[xr] = {
                constructor: e,
                union: function(t) {
                    var e = a(t.x, this.x),
                    i = a(t.y, this.y);
                    this.width = s(t.x + t.width, this.x + this.width) - e,
                    this[nr] = s(t.y + t[nr], this.y + this[nr]) - i,
                    this.x = e,
                    this.y = i
                },
                applyTransform: function() {
                    var t = [],
                    e = [];
                    return function(i) {
                        i && (t[0] = this.x, t[1] = this.y, e[0] = this.x + this.width, e[1] = this.y + this[nr], r(t, t, i), r(e, e, i), this.x = a(t[0], e[0]), this.y = a(t[1], e[1]), this.width = o(e[0] - t[0]), this[nr] = o(e[1] - t[1]))
                    }
                } (),
                calculateTransform: function(t) {
                    var e = this,
                    i = t.width / e.width,
                    r = t[nr] / e[nr],
                    a = n[ir]();
                    return n.translate(a, a, [ - e.x, -e.y]),
                    n.scale(a, a, [i, r]),
                    n.translate(a, a, [t.x, t.y]),
                    a
                },
                intersect: function(t) {
                    var e = this,
                    i = e.x,
                    n = e.x + e.width,
                    r = e.y,
                    a = e.y + e[nr],
                    o = t.x,
                    s = t.x + t.width,
                    l = t.y,
                    u = t.y + t[nr];
                    return ! (o > n || i > s || l > a || r > u)
                },
                contain: function(t, e) {
                    var i = this;
                    return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i[nr]
                },
                clone: function() {
                    return new e(this.x, this.y, this.width, this[nr])
                },
                copy: function(t) {
                    this.x = t.x,
                    this.y = t.y,
                    this.width = t.width,
                    this[nr] = t[nr]
                }
            },
            e
        }),
        e("zrender/contain/text", [Tr, r, "../core/BoundingRect"],
        function(t) {
            function e(t, e) {
                var i = t + ":" + e;
                if (s[i]) return s[i];
                for (var n = (t + "").split("\n"), r = 0, a = 0, o = n[Wn]; o > a; a++) r = Math.max(f.measureText(n[a], e).width, r);
                return l > u && (l = 0, s = {}),
                l++,
                s[i] = r,
                r
            }
            function i(t, i, n, r) {
                var a = ((t || "") + "").split("\n")[Wn],
                o = e(t, i),
                s = e("国", i),
                l = a * s,
                u = new h(0, 0, o, l);
                switch (u.lineHeight = s, r) {
                case rr:
                case "alphabetic":
                    u.y -= s;
                    break;
                case Qi:
                    u.y -= s / 2
                }
                switch (n) {
                case "end":
                case "right":
                    u.x -= u.width;
                    break;
                case Ji:
                    u.x -= u.width / 2
                }
                return u
            }
            function n(t, e, i, n) {
                var r = e.x,
                a = e.y,
                o = e[nr],
                s = e.width,
                l = i[nr],
                u = o / 2 - l / 2,
                c = "left";
                switch (t) {
                case "left":
                    r -= n,
                    a += u,
                    c = "right";
                    break;
                case "right":
                    r += n + s,
                    a += u,
                    c = "left";
                    break;
                case "top":
                    r += s / 2,
                    a -= n + l,
                    c = Ji;
                    break;
                case rr:
                    r += s / 2,
                    a += o + n,
                    c = Ji;
                    break;
                case mi:
                    r += s / 2,
                    a += u,
                    c = Ji;
                    break;
                case "insideLeft":
                    r += n,
                    a += u,
                    c = "left";
                    break;
                case "insideRight":
                    r += s - n,
                    a += u,
                    c = "right";
                    break;
                case "insideTop":
                    r += s / 2,
                    a += n,
                    c = Ji;
                    break;
                case "insideBottom":
                    r += s / 2,
                    a += o - l - n,
                    c = Ji;
                    break;
                case "insideTopLeft":
                    r += n,
                    a += n,
                    c = "left";
                    break;
                case "insideTopRight":
                    r += s - n,
                    a += n,
                    c = "right";
                    break;
                case "insideBottomLeft":
                    r += n,
                    a += o - l - n;
                    break;
                case "insideBottomRight":
                    r += s - n,
                    a += o - l - n,
                    c = "right"
                }
                return {
                    x: r,
                    y: a,
                    textAlign: c,
                    textBaseline: "top"
                }
            }
            function a(t, i, n, r, a) {
                if (!i) return "";
                a = a || {},
                r = d(r, "...");
                for (var s = d(a.maxIterations, 2), l = d(a.minChar, 0), u = e("国", n), c = e("a", n), h = d(a.placeholder, ""), f = i = Math.max(0, i - 1), p = 0; l > p && f >= c; p++) f -= c;
                var v = e(r);
                v > f && (r = "", v = 0),
                f = i - v;
                for (var g = (t + "").split("\n"), p = 0, m = g[Wn]; m > p; p++) {
                    var y = g[p],
                    x = e(y, n);
                    if (! (i >= x)) {
                        for (var _ = 0;; _++) {
                            if (f >= x || _ >= s) {
                                y += r;
                                break
                            }
                            var w = 0 === _ ? o(y, f, c, u) : x > 0 ? Math.floor(y[Wn] * f / x) : 0;
                            y = y.substr(0, w),
                            x = e(y, n)
                        }
                        "" === y && (y = h),
                        g[p] = y
                    }
                }
                return g.join("\n")
            }
            function o(t, e, i, n) {
                for (var r = 0,
                a = 0,
                o = t[Wn]; o > a && e > r; a++) {
                    var s = t.charCodeAt(a);
                    r += s >= 0 && 127 >= s ? i: n
                }
                return a
            }
            var s = {},
            l = 0,
            u = 5e3,
            c = t(r),
            h = t("../core/BoundingRect"),
            d = c[vi],
            f = {
                getWidth: e,
                getBoundingRect: i,
                adjustTextPositionOnRect: n,
                truncateText: a,
                measureText: function(t, e) {
                    var i = c.getContext();
                    return i.font = e || "12px sans-serif",
                    i.measureText(t)
                }
            };
            return f
        }),
        e("echarts/coord/axisHelper", [Tr, "../scale/Ordinal", "../scale/Interval", "../scale/Time", "../scale/Log", "../scale/Scale", Xi, Ar, "zrender/contain/text"],
        function(t) {
            var e = t("../scale/Ordinal"),
            i = t("../scale/Interval");
            t("../scale/Time"),
            t("../scale/Log");
            var n = t("../scale/Scale"),
            r = t(Xi),
            a = t(Ar),
            o = t("zrender/contain/text"),
            s = {};
            return s.getScaleExtent = function(t, e) {
                var i = t.scale,
                n = i[Fi](),
                o = n[1] - n[0];
                if (i.type === Pe) return isFinite(o) ? n: [0, 0];
                var s = e.getMin ? e.getMin() : e.get("min"),
                l = e.getMax ? e.getMax() : e.get("max"),
                u = e.getNeedCrossZero ? e.getNeedCrossZero() : !e.get("scale"),
                c = e.get(X);
                a[An](c) || (c = [c || 0, c || 0]),
                c[0] = r[We](c[0], 1),
                c[1] = r[We](c[1], 1);
                var h = !0,
                d = !0;
                return null == s && (s = n[0] - c[0] * o, h = !1),
                null == l && (l = n[1] + c[1] * o, d = !1),
                "dataMin" === s && (s = n[0]),
                "dataMax" === l && (l = n[1]),
                u && (s > 0 && l > 0 && !h && (s = 0), 0 > s && 0 > l && !d && (l = 0)),
                [s, l]
            },
            s[ie] = function(t, e) {
                var i = t.scale,
                n = s.getScaleExtent(t, e),
                r = null != (e.getMin ? e.getMin() : e.get("min")),
                a = null != (e.getMax ? e.getMax() : e.get("max")),
                o = e.get("splitNumber");
                "log" === i.type && (i.base = e.get("logBase")),
                i[Zi](n[0], n[1]),
                i.niceExtent(o, r, a);
                var l = e.get("minInterval");
                if (isFinite(l) && !r && !a && i.type === R) {
                    var u = i.getInterval(),
                    c = Math.max(Math.abs(u), l) / u;
                    n = i[Fi](),
                    i[Zi](c * n[0], n[1] * c),
                    i.niceExtent(o)
                }
                var u = e.get(R);
                null != u && i.setInterval && i.setInterval(u)
            },
            s[$] = function(t, r) {
                if (r = r || t.get("type")) switch (r) {
                case te:
                    return new e(t.getCategories(), [1 / 0, -1 / 0]);
                case "value":
                    return new i;
                default:
                    return (n.getClass(r) || i)[ir](t)
                }
            },
            s.ifAxisCrossZero = function(t) {
                var e = t.scale[Fi](),
                i = e[0],
                n = e[1];
                return ! (i > 0 && n > 0 || 0 > i && 0 > n)
            },
            s.getAxisLabelInterval = function(t, e, i, n) {
                var r, a = 0,
                s = 0,
                l = 1;
                e[Wn] > 40 && (l = Math.floor(e[Wn] / 40));
                for (var u = 0; u < t[Wn]; u += l) {
                    var c = t[u],
                    h = o[en](e[u], i, Ji, "top");
                    h[n ? "x": "y"] += c,
                    h[n ? "width": nr] *= 1.3,
                    r ? r.intersect(h) ? (s++, a = Math.max(a, s)) : (r.union(h), s = 0) : r = h.clone()
                }
                return 0 === a && l > 1 ? l: (a + 1) * l - 1
            },
            s[ee] = function(t, e) {
                var i = t.scale,
                n = i.getTicksLabels(),
                r = i[qi]();
                return typeof e === yr ? (e = function(t) {
                    return function(e) {
                        return t[Tn]("{value}", e)
                    }
                } (e), a.map(n, e)) : typeof e === Sn ? a.map(r,
                function(n, r) {
                    return e(t.type === te ? i[Wi](n) : n, r)
                },
                this) : n
            },
            s
        }),
        e("echarts/coord/cartesian/Cartesian2D", [Tr, Ar, "./Cartesian"],
        function(t) {
            function e(t) {
                r.call(this, t)
            }
            var i = t(Ar),
            r = t("./Cartesian");
            return e[xr] = {
                constructor: e,
                type: "cartesian2d",
                dimensions: ["x", "y"],
                getBaseAxis: function() {
                    return this.getAxesByScale(Pe)[0] || this.getAxesByScale("time")[0] || this[J]("x")
                },
                containPoint: function(t) {
                    var e = this[J]("x"),
                    i = this[J]("y");
                    return e[ji](e.toLocalCoord(t[0])) && i[ji](i.toLocalCoord(t[1]))
                },
                containData: function(t) {
                    return this[J]("x").containData(t[0]) && this[J]("y").containData(t[1])
                },
                dataToPoints: function(t, e) {
                    return t[he](["x", "y"],
                    function(t, e) {
                        return this[ae]([t, e])
                    },
                    e, this)
                },
                dataToPoint: function(t, e) {
                    var i = this[J]("x"),
                    n = this[J]("y");
                    return [i[U](i[B](t[0], e)), n[U](n[B](t[1], e))]
                },
                pointToData: function(t, e) {
                    var i = this[J]("x"),
                    r = this[J]("y");
                    return [i[n](i.toLocalCoord(t[0]), e), r[n](r.toLocalCoord(t[1]), e)]
                },
                getOtherAxis: function(t) {
                    return this[J]("x" === t.dim ? "y": "x")
                }
            },
            i[vn](e, r),
            e
        }),
        e("echarts/coord/cartesian/Axis2D", [Tr, Ar, "../Axis", "./axisLabelInterval"],
        function(t) {
            var e = t(Ar),
            i = t("../Axis"),
            n = t("./axisLabelInterval"),
            r = function(t, e, n, r, a) {
                i.call(this, t, e, n),
                this.type = r || "value",
                this[$i] = a || rr
            };
            return r[xr] = {
                constructor: r,
                index: 0,
                onZero: !1,
                model: null,
                isHorizontal: function() {
                    var t = this[$i];
                    return "top" === t || t === rr
                },
                getGlobalExtent: function() {
                    var t = this[Fi]();
                    return t[0] = this[U](t[0]),
                    t[1] = this[U](t[1]),
                    t
                },
                getLabelInterval: function() {
                    var t = this._labelInterval;
                    return t || (t = this._labelInterval = n(this)),
                    t
                },
                isLabelIgnored: function(t) {
                    if (this.type === te) {
                        var e = this.getLabelInterval();
                        return typeof e === Sn && !e(t, this.scale[Wi](t)) || t % (e + 1)
                    }
                },
                toLocalCoord: null,
                toGlobalCoord: null
            },
            e[vn](r, i),
            r
        }),
        e("echarts/coord/cartesian/GridModel", [Tr, "./AxisModel", c],
        function(t) {
            t("./AxisModel");
            var e = t(c);
            return e[jn]({
                type: "grid",
                dependencies: ["xAxis", "yAxis"],
                layoutMode: "box",
                coordinateSystem: null,
                defaultOption: {
                    show: !1,
                    zlevel: 0,
                    z: 0,
                    left: "10%",
                    top: 60,
                    right: "10%",
                    bottom: 60,
                    containLabel: !1,
                    backgroundColor: "rgba(0,0,0,0)",
                    borderWidth: 1,
                    borderColor: "#ccc"
                }
            })
        }),
        e("echarts/chart/helper/createListFromArray", [Tr, Gi, Ni, Ar, Bi, ne],
        function(t) {
            function e(t) {
                for (var e = 0; e < t[Wn] && null == t[e];) e++;
                return t[e]
            }
            function i(t) {
                var i = e(t);
                return null != i && !u[An](d(i))
            }
            function n(t, e, n) {
                t = t || [];
                var r = e.get(ln),
                a = p[r],
                v = h.get(r),
                g = a && a(t, e, n),
                m = g && g[de];
                m || (m = v && v[de] || ["x", "y"], m = l(m, t, m[Ai](["value"])));
                var y = g ? g.categoryIndex: -1,
                x = new s(m, e),
                _ = o(g, t),
                w = {},
                b = y >= 0 && i(t) ?
                function(t, e, i, n) {
                    return c.isDataItemOption(t) && (x[fe] = !0),
                    n === y ? i: f(d(t), m[n])
                }: function(t, e, i, n) {
                    var r = d(t),
                    a = f(r && r[n], m[n]);
                    c.isDataItemOption(t) && (x[fe] = !0);
                    var o = g && g.categoryAxesModels;
                    return o && o[e] && typeof a === yr && (w[e] = w[e] || o[e].getCategories(), a = u[gn](w[e], a), 0 > a && !isNaN(a) && (a = +a)),
                    a
                };
                return x[fe] = !1,
                x[Di](t, _, b),
                x
            }
            function r(t) {
                return t !== te && "time" !== t
            }
            function a(t) {
                return t === te ? Pe: "time" === t ? "time": "float"
            }
            function o(t, e) {
                var i, n = [],
                r = t && t[de][t.categoryIndex];
                if (r && (i = t.categoryAxesModels[r.name]), i) {
                    var a = i.getCategories();
                    if (a) {
                        var o = e[Wn];
                        if (u[An](e[0]) && e[0][Wn] > 1) {
                            n = [];
                            for (var s = 0; o > s; s++) n[s] = a[e[s][t.categoryIndex || 0]]
                        } else n = a.slice(0)
                    }
                }
                return n
            }
            var s = t(Gi),
            l = t(Ni),
            u = t(Ar),
            c = t(Bi),
            h = t(ne),
            d = c.getDataItemValue,
            f = c.converDataValue,
            p = {
                cartesian2d: function(t, e, i) {
                    var n = u.map(["xAxis", "yAxis"],
                    function(t) {
                        return i[Ee]({
                            mainType: t,
                            index: e.get(t + "Index"),
                            id: e.get(t + "Id")
                        })[0]
                    }),
                    o = n[0],
                    s = n[1],
                    c = o.get("type"),
                    h = s.get("type"),
                    d = [{
                        name: "x",
                        type: a(c),
                        stackable: r(c)
                    },
                    {
                        name: "y",
                        type: a(h),
                        stackable: r(h)
                    }],
                    f = c === te,
                    p = h === te;
                    l(d, t, ["x", "y", "z"]);
                    var v = {};
                    return f && (v.x = o),
                    p && (v.y = s),
                    {
                        dimensions: d,
                        categoryIndex: f ? 0 : p ? 1 : -1,
                        categoryAxesModels: v
                    }
                },
                polar: function(t, e, i) {
                    var n = i[Ee]({
                        mainType: "polar",
                        index: e.get(D),
                        id: e.get("polarId")
                    })[0],
                    o = n.findAxisModel("angleAxis"),
                    s = n.findAxisModel("radiusAxis"),
                    u = s.get("type"),
                    c = o.get("type"),
                    h = [{
                        name: "radius",
                        type: a(u),
                        stackable: r(u)
                    },
                    {
                        name: "angle",
                        type: a(c),
                        stackable: r(c)
                    }],
                    d = c === te,
                    f = u === te;
                    l(h, t, [Ze, "angle", "value"]);
                    var p = {};
                    return f && (p[Ze] = s),
                    d && (p.angle = o),
                    {
                        dimensions: h,
                        categoryIndex: d ? 1 : f ? 0 : -1,
                        categoryAxesModels: p
                    }
                },
                geo: function(t) {
                    return {
                        dimensions: l([{
                            name: "lng"
                        },
                        {
                            name: "lat"
                        }], t, ["lng", "lat", "value"])
                    }
                }
            };
            return n
        }),
        e("echarts/util/clazz", [Tr, Ar],
        function(t) {
            function e(t, e) {
                var i = n.slice(arguments, 2);
                return this.superClass[xr][e].apply(t, i)
            }
            function i(t, e, i) {
                return this.superClass[xr][e].apply(t, i)
            }
            var n = t(Ar),
            r = {},
            a = ".",
            o = "___EC__COMPONENT__CONTAINER___",
            s = r.parseClassType = function(t) {
                var e = {
                    main: "",
                    sub: ""
                };
                return t && (t = t.split(a), e.main = t[0] || "", e.sub = t[1] || ""),
                e
            };
            return r.enableClassExtend = function(t) {
                t.$constructor = t,
                t[jn] = function(t) {
                    var r = this,
                    a = function() {
                        t.$constructor ? t.$constructor.apply(this, arguments) : r.apply(this, arguments)
                    };
                    return n[jn](a[xr], t),
                    a[jn] = this[jn],
                    a[Ri] = e,
                    a[Oi] = i,
                    n[vn](a, this),
                    a.superClass = r,
                    a
                }
            },
            r.enableClassManagement = function(t, e) {
                function i(t) {
                    var e = r[t.main];
                    return e && e[o] || (e = r[t.main] = {},
                    e[o] = !0),
                    e
                }
                e = e || {};
                var r = {};
                if (t.registerClass = function(t, e) {
                    if (e) if (e = s(e), e.sub) {
                        if (e.sub !== o) {
                            var n = i(e);
                            n[e.sub] = t
                        }
                    } else r[e.main] = t;
                    return t
                },
                t.getClass = function(t, e, i) {
                    var n = r[t];
                    if (n && n[o] && (n = e ? n[e] : null), i && !n) throw new Error("Component " + t + "." + (e || "") + " not exists. Load it first.");
                    return n
                },
                t.getClassesByMainType = function(t) {
                    t = s(t);
                    var e = [],
                    i = r[t.main];
                    return i && i[o] ? n.each(i,
                    function(t, i) {
                        i !== o && e.push(t)
                    }) : e.push(i),
                    e
                },
                t.hasClass = function(t) {
                    return t = s(t),
                    !!r[t.main]
                },
                t.getAllClassMainTypes = function() {
                    var t = [];
                    return n.each(r,
                    function(e, i) {
                        t.push(i)
                    }),
                    t
                },
                t.hasSubTypes = function(t) {
                    t = s(t);
                    var e = r[t.main];
                    return e && e[o]
                },
                t.parseClassType = s, e.registerWhenExtend) {
                    var a = t[jn];
                    a && (t[jn] = function(e) {
                        var i = a.call(this, e);
                        return t.registerClass(i, e.type)
                    })
                }
                return t
            },
            r.setReadOnly = function() {},
            r
        }),
        e("echarts/data/DataDiffer", [Tr],
        function() {
            function t(t) {
                return t
            }
            function e(e, i, n, r) {
                this._old = e,
                this._new = i,
                this._oldKeyGetter = n || t,
                this._newKeyGetter = r || t
            }
            function i(t, e, i, n) {
                for (var r = 0; r < t[Wn]; r++) {
                    var a = n(t[r], r),
                    o = e[a];
                    null == o ? (i.push(a), e[a] = r) : (o[Wn] || (e[a] = o = [o]), o.push(r))
                }
            }
            return e[xr] = {
                constructor: e,
                add: function(t) {
                    return this._add = t,
                    this
                },
                update: function(t) {
                    return this._update = t,
                    this
                },
                remove: function(t) {
                    return this._remove = t,
                    this
                },
                execute: function() {
                    var t, e = this._old,
                    n = this._new,
                    r = this._oldKeyGetter,
                    a = this._newKeyGetter,
                    o = {},
                    s = {},
                    l = [],
                    u = [];
                    for (i(e, o, l, r), i(n, s, u, a), t = 0; t < e[Wn]; t++) {
                        var c = l[t],
                        h = s[c];
                        if (null != h) {
                            var d = h[Wn];
                            d ? (1 === d && (s[c] = null), h = h.unshift()) : s[c] = null,
                            this._update && this._update(h, t)
                        } else this._remove && this._remove(t)
                    }
                    for (var t = 0; t < u[Wn]; t++) {
                        var c = u[t];
                        if (s.hasOwnProperty(c)) {
                            var h = s[c];
                            if (null == h) continue;
                            if (h[Wn]) for (var f = 0,
                            d = h[Wn]; d > f; f++) this._add && this._add(h[f]);
                            else this._add && this._add(h)
                        }
                    }
                }
            },
            e
        }),
        e("echarts/model/mixin/lineStyle", [Tr, "./makeStyleMapper"],
        function(t) {
            var e = t("./makeStyleMapper")([[xe, "width"], [ye, "color"], [Yi], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
            return {
                getLineStyle: function(t) {
                    var i = e.call(this, t),
                    n = this.getLineDash();
                    return n && (i.lineDash = n),
                    i
                },
                getLineDash: function() {
                    var t = this.get("type");
                    return "solid" === t || null == t ? null: "dashed" === t ? [5, 5] : [2, 2]
                }
            }
        }),
        e("echarts/model/mixin/areaStyle", [Tr, "./makeStyleMapper"],
        function(t) {
            return {
                getAreaStyle: t("./makeStyleMapper")([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], [Yi], ["shadowColor"]])
            }
        }),
        e("echarts/model/mixin/textStyle", [Tr, "zrender/contain/text"],
        function(t) {
            function e(t, e) {
                return t && t[Ce](e)
            }
            var i = t("zrender/contain/text");
            return {
                getTextColor: function() {
                    var t = this[Te];
                    return this[Ce]("color") || t && t.get("textStyle.color")
                },
                getFont: function() {
                    var t = this[Te],
                    i = t && t[fr](on);
                    return [this[Ce]("fontStyle") || e(i, "fontStyle"), this[Ce]("fontWeight") || e(i, "fontWeight"), (this[Ce]("fontSize") || e(i, "fontSize") || 12) + "px", this[Ce]("fontFamily") || e(i, "fontFamily") || "sans-serif"].join(" ")
                },
                getTextRect: function(t) {
                    var e = this.get(on) || {};
                    return i[en](t, this[rn](), e.align, e.baseline)
                },
                truncateText: function(t, e, n, r) {
                    return i.truncateText(t, e, this[rn](), n, r)
                }
            }
        }),
        e("echarts/model/mixin/itemStyle", [Tr, "./makeStyleMapper"],
        function(t) {
            var e = t("./makeStyleMapper")([["fill", "color"], [ye, N], [xe, "borderWidth"], [Yi], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
            return {
                getItemStyle: function(t) {
                    var i = e.call(this, t),
                    n = this.getBorderLineDash();
                    return n && (i.lineDash = n),
                    i
                },
                getBorderLineDash: function() {
                    var t = this.get("borderType");
                    return "solid" === t || null == t ? null: "dashed" === t ? [5, 5] : [1, 1]
                }
            }
        }),
        e("echarts/coord/polar/Polar", [Tr, "./RadiusAxis", "./AngleAxis"],
        function(t) {
            var e = t("./RadiusAxis"),
            i = t("./AngleAxis"),
            n = function(t) {
                this.name = t || "",
                this.cx = 0,
                this.cy = 0,
                this._radiusAxis = new e,
                this._angleAxis = new i
            };
            return n[xr] = {
                constructor: n,
                type: "polar",
                dimensions: [Ze, "angle"],
                containPoint: function(t) {
                    var e = this.pointToCoord(t);
                    return this._radiusAxis[ji](e[0]) && this._angleAxis[ji](e[1])
                },
                containData: function(t) {
                    return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1])
                },
                getAxis: function(t) {
                    return this["_" + t + "Axis"]
                },
                getAxesByScale: function(t) {
                    var e = [],
                    i = this._angleAxis,
                    n = this._radiusAxis;
                    return i.scale.type === t && e.push(i),
                    n.scale.type === t && e.push(n),
                    e
                },
                getAngleAxis: function() {
                    return this._angleAxis
                },
                getRadiusAxis: function() {
                    return this._radiusAxis
                },
                getOtherAxis: function(t) {
                    var e = this._angleAxis;
                    return t === e ? this._radiusAxis: e
                },
                getBaseAxis: function() {
                    return this.getAxesByScale(Pe)[0] || this.getAxesByScale("time")[0] || this.getAngleAxis()
                },
                dataToPoints: function(t) {
                    return t[he](this[de],
                    function(t, e) {
                        return this[ae]([t, e])
                    },
                    this)
                },
                dataToPoint: function(t, e) {
                    return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)])
                },
                pointToData: function(t, e) {
                    var i = this.pointToCoord(t);
                    return [this._radiusAxis.radiusToData(i[0], e), this._angleAxis.angleToData(i[1], e)]
                },
                pointToCoord: function(t) {
                    var e = t[0] - this.cx,
                    i = t[1] - this.cy,
                    n = this.getAngleAxis(),
                    r = n[Fi](),
                    a = Math.min(r[0], r[1]),
                    o = Math.max(r[0], r[1]);
                    n[Q] ? a = o - 360 : o = a + 360;
                    var s = Math.sqrt(e * e + i * i);
                    e /= s,
                    i /= s;
                    for (var l = Math.atan2( - i, e) / Math.PI * 180, u = a > l ? 1 : -1; a > l || l > o;) l += 360 * u;
                    return [s, l]
                },
                coordToPoint: function(t) {
                    var e = t[0],
                    i = t[1] / 180 * Math.PI,
                    n = Math.cos(i) * e + this.cx,
                    r = -Math.sin(i) * e + this.cy;
                    return [n, r]
                }
            },
            n
        }),
        e("echarts/coord/polar/PolarModel", [Tr, "./AxisModel", Ei],
        function(t) {
            t("./AxisModel"),
            t(Ei)[wn]({
                type: "polar",
                dependencies: ["polarAxis", "angleAxis"],
                coordinateSystem: null,
                findAxisModel: function(t) {
                    var e, i = this[Te];
                    return i[or](t,
                    function(t) {
                        var n = i[Ee]({
                            mainType: "polar",
                            index: t[Ce](D),
                            id: t[Ce]("polarId")
                        })[0];
                        n === this && (e = t)
                    },
                    this),
                    e
                },
                defaultOption: {
                    zlevel: 0,
                    z: 0,
                    center: ["50%", "50%"],
                    radius: "80%"
                }
            })
        }),
        e("echarts/component/helper/selectableMixin", [Tr, Ar],
        function(t) {
            var e = t(Ar);
            return {
                updateSelectedMap: function(t) {
                    this._selectTargetMap = e.reduce(t || [],
                    function(t, e) {
                        return t[e.name] = e,
                        t
                    },
                    {})
                },
                select: function(t) {
                    var i = this._selectTargetMap,
                    n = i[t],
                    r = this.get("selectedMode");
                    "single" === r && e.each(i,
                    function(t) {
                        t[ai] = !1
                    }),
                    n && (n[ai] = !0)
                },
                unSelect: function(t) {
                    var e = this._selectTargetMap[t];
                    e && (e[ai] = !1)
                },
                toggleSelected: function(t) {
                    var e = this._selectTargetMap[t];
                    return null != e ? (this[e[ai] ? "unSelect": "select"](t), e[ai]) : void 0
                },
                isSelected: function(t) {
                    var e = this._selectTargetMap[t];
                    return e && e[ai]
                }
            }
        }),
        e("echarts/coord/single/Single", [Tr, "./SingleAxis", "../axisHelper", re],
        function(t) {
            function e(t, e, i) {
                this.dimension = "x",
                this[de] = ["x"],
                this._axis = null,
                this._rect,
                this._init(t, e, i),
                this[pr] = t
            }
            var i = t("./SingleAxis"),
            r = t("../axisHelper"),
            a = t(re);
            return e[xr] = {
                type: "singleAxis",
                constructor: e,
                _init: function(t) {
                    var e = this.dimension,
                    n = new i(e, r[$](t), [0, 0], t.get("type"), t.get($i)),
                    a = n.type === te;
                    n[Y] = a && t.get(X),
                    n[Q] = t.get(Q),
                    n[l] = t.get(l),
                    t.axis = n,
                    n.model = t,
                    this._axis = n
                },
                update: function(t) {
                    this._updateAxisFromSeries(t)
                },
                _updateAxisFromSeries: function(t) {
                    t[tr](function(t) {
                        var e = t[Kn](),
                        i = this.dimension;
                        this._axis.scale[Hi](e[Fe](t[j](i))),
                        r[ie](this._axis, this._axis.model)
                    },
                    this)
                },
                resize: function(t, e) {
                    this._rect = a[Ki]({
                        left: t.get("left"),
                        top: t.get("top"),
                        right: t.get("right"),
                        bottom: t.get(rr),
                        width: t.get("width"),
                        height: t.get(nr)
                    },
                    {
                        width: e[dr](),
                        height: e[hr]()
                    }),
                    this._adjustAxis()
                },
                getRect: function() {
                    return this._rect
                },
                _adjustAxis: function() {
                    var t = this._rect,
                    e = this._axis,
                    i = e[K](),
                    n = i ? [0, t.width] : [0, t[nr]],
                    r = e[S] ? 1 : 0;
                    e[Zi](n[r], n[1 - r]),
                    this._updateAxisTransform(e, i ? t.x: t.y)
                },
                _updateAxisTransform: function(t, e) {
                    var i = t[Fi](),
                    n = i[0] + i[1],
                    r = t[K]();
                    t[U] = r ?
                    function(t) {
                        return t + e
                    }: function(t) {
                        return n - t + e
                    },
                    t.toLocalCoord = r ?
                    function(t) {
                        return t - e
                    }: function(t) {
                        return n - t + e
                    }
                },
                getAxis: function() {
                    return this._axis
                },
                getBaseAxis: function() {
                    return this._axis
                },
                containPoint: function(t) {
                    var e = this[un](),
                    i = this[J](),
                    n = i[l];
                    return n === O ? i[ji](i.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e[nr] : i[ji](i.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e[nr]
                },
                pointToData: function(t) {
                    var e = this[J]();
                    return [e[n](e.toLocalCoord(t[e[l] === O ? 0 : 1]))]
                },
                dataToPoint: function(t) {
                    var e = this[J](),
                    i = this[un](),
                    n = [],
                    r = e[l] === O ? 0 : 1;
                    return n[r] = e[U](e[B]( + t)),
                    n[1 - r] = 0 === r ? i.y + i[nr] / 2 : i.x + i.width / 2,
                    n
                }
            },
            e
        }),
        e("echarts/component/marker/MarkerModel", [Tr, Bi, Ar, Sr, G, Ei],
        function(t) {
            function e(t) {
                i[Pi](t.label, i.LABEL_OPTIONS)
            }
            var i = t(Bi),
            n = t(Ar),
            r = t(Sr),
            a = t(G),
            o = a[ze],
            s = a[Ve],
            l = t(Ei)[wn]({
                type: "marker",
                dependencies: [Fn, "grid", "polar", "geo"],
                init: function(t, e, i, n) {
                    this[De](t, i),
                    this[Vi](t, i, n.createdBySelf, !0)
                },
                ifEnableAnimation: function() {
                    if (r.node) return ! 1;
                    var t = this.__hostSeries;
                    return this[Ce](vr) && t && t.ifEnableAnimation()
                },
                mergeOption: function(t, i, r, a) {
                    var o = this.constructor,
                    s = this[Ne] + "Model";
                    r || i[tr](function(t) {
                        var r = t.get(this[Ne]),
                        l = t[s];
                        if (!r || !r.data) return void(t[s] = null);
                        if (l) l[Vi](r, i, !0);
                        else {
                            a && e(r),
                            n.each(r.data,
                            function(t) {
                                t instanceof Array ? (e(t[0]), e(t[1])) : e(t)
                            });
                            var u = {
                                mainType: this[Ne],
                                seriesIndex: t[Dn],
                                name: t.name,
                                createdBySelf: !0
                            };
                            l = new o(r, this, i, u),
                            l.__hostSeries = t
                        }
                        t[s] = l
                    },
                    this)
                },
                formatTooltip: function(t) {
                    var e = this[Kn](),
                    i = this[ke](t),
                    r = n[An](i) ? n.map(i, o).join(", ") : o(i),
                    a = e[Ci](t),
                    l = this.name;
                    return (null != i || a) && (l += Le),
                    a && (l += s(a), null != i && (l += " : ")),
                    null != i && (l += r),
                    l
                },
                getData: function() {
                    return this._data
                },
                setData: function(t) {
                    this._data = t
                }
            });
            return n.mixin(l, i.dataFormatMixin),
            l
        }),
        e("echarts/model/mixin/boxLayout", [Tr],
        function() {
            return {
                getBoxLayoutParams: function() {
                    return {
                        left: this.get("left"),
                        top: this.get("top"),
                        right: this.get("right"),
                        bottom: this.get(rr),
                        width: this.get("width"),
                        height: this.get(nr)
                    }
                }
            }
        }),
        e("echarts/util/component", [Tr, Ar, "./clazz"],
        function(t) {
            var e = t(Ar),
            i = t("./clazz"),
            n = i.parseClassType,
            r = 0,
            a = {},
            o = "_";
            return a.getUID = function(t) {
                return [t || "", r++, Math.random()].join(o)
            },
            a.enableSubTypeDefaulter = function(t) {
                var e = {};
                return t.registerSubTypeDefaulter = function(t, i) {
                    t = n(t),
                    e[t.main] = i
                },
                t.determineSubType = function(i, r) {
                    var a = r.type;
                    if (!a) {
                        var o = n(i).main;
                        t.hasSubTypes(i) && e[o] && (a = e[o](r))
                    }
                    return a
                },
                t
            },
            a.enableTopologicalTravel = function(t, i) {
                function n(t) {
                    var n = {},
                    o = [];
                    return e.each(t,
                    function(s) {
                        var l = r(n, s),
                        u = l.originalDeps = i(s),
                        c = a(u, t);
                        l.entryCount = c[Wn],
                        0 === l.entryCount && o.push(s),
                        e.each(c,
                        function(t) {
                            e[gn](l.predecessor, t) < 0 && l.predecessor.push(t);
                            var i = r(n, t);
                            e[gn](i.successor, t) < 0 && i.successor.push(s)
                        })
                    }),
                    {
                        graph: n,
                        noEntryList: o
                    }
                }
                function r(t, e) {
                    return t[e] || (t[e] = {
                        predecessor: [],
                        successor: []
                    }),
                    t[e]
                }
                function a(t, i) {
                    var n = [];
                    return e.each(t,
                    function(t) {
                        e[gn](i, t) >= 0 && n.push(t)
                    }),
                    n
                }
                t.topologicalTravel = function(t, i, r, a) {
                    function o(t) {
                        u[t].entryCount--,
                        0 === u[t].entryCount && c.push(t)
                    }
                    function s(t) {
                        h[t] = !0,
                        o(t)
                    }
                    if (t[Wn]) {
                        var l = n(i),
                        u = l.graph,
                        c = l.noEntryList,
                        h = {};
                        for (e.each(t,
                        function(t) {
                            h[t] = !0
                        }); c[Wn];) {
                            var d = c.pop(),
                            f = u[d],
                            p = !!h[d];
                            p && (r.call(a, d, f.originalDeps.slice()), delete h[d]),
                            e.each(f.successor, p ? s: o)
                        }
                        e.each(h,
                        function() {
                            throw new Error("Circle dependency may exists")
                        })
                    }
                }
            },
            a
        }),
        e("echarts/component/visualMap/preprocessor", [Tr, Ar],
        function(t) {
            function e(t, e) {
                return t && t.hasOwnProperty && t.hasOwnProperty(e)
            }
            var i = t(Ar),
            n = i.each;
            return function(t) {
                var r = t && t.visualMap;
                i[An](r) || (r = r ? [r] : []),
                n(r,
                function(t) {
                    if (t) {
                        e(t, "splitList") && !e(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
                        var r = t.pieces;
                        r && i[An](r) && n(r,
                        function(t) {
                            i[Yn](t) && (e(t, "start") && !e(t, "min") && (t.min = t.start), e(t, "end") && !e(t, "max") && (t.max = t.end))
                        })
                    }
                })
            }
        }),
        e("echarts/component/visualMap/visualEncoding", [Tr, Ei, "../../visual/visualSolution", "../../visual/VisualMapping"],
        function(t) {
            function e(t) {
                t.eachTargetSeries(function(e) {
                    var i = e[Kn]();
                    a.applyVisual(t.stateList, t.targetVisuals, i, t.getValueState, t, t.getDataDimension(i))
                })
            }
            function i(t) {
                t[tr](function(e) {
                    var i = e[Kn](),
                    r = [];
                    t[or]("visualMap",
                    function(t) {
                        if (t.isTargetSeries(e)) {
                            var a = {};
                            r.push(a),
                            a.stops = t.getStops(e, n),
                            a.dimension = t.getDataDimension(i)
                        }
                    }),
                    e[Kn]()[hn]("visualMeta", r)
                })
            }
            function n(t, e, i) {
                function n(t) {
                    return l[t]
                }
                function r(t, e) {
                    l[t] = e
                }
                for (var a = t.targetVisuals[i], s = o.prepareVisualTypes(a), l = {},
                u = 0, c = s[Wn]; c > u; u++) {
                    var h = s[u],
                    d = a["colorAlpha" === h ? "__alphaForOpacity": h];
                    d && d.applyVisual(e, n, r)
                }
                return l.color
            }
            var r = t(Ei),
            a = t("../../visual/visualSolution"),
            o = t("../../visual/VisualMapping");
            r.registerVisual(r.PRIORITY.VISUAL.COMPONENT,
            function(t) {
                t[or]("visualMap",
                function(i) {
                    e(i, t)
                }),
                i(t)
            })
        }),
        e("echarts/component/visualMap/ContinuousModel", [Tr, "./VisualMapModel", Ar, qe],
        function(t) {
            function e(t, e, i) {
                var n = t.targetVisuals[e].color;
                if (!n) return i.slice();
                var r = n[zi].visual[Wn];
                if (1 >= r || i[0] === i[1]) return i.slice();
                for (var a = (i[1] - i[0]) / (r - 1), o = i[0], s = [], l = 0; r > l && o < i[1]; l++) s.push(o),
                o += a;
                return s.push(i[1]),
                s
            }
            function i(t, i, n, a) {
                var o = e(t, i, n);
                r.each(o,
                function(t) {
                    for (var e = {
                        value: t,
                        valueState: i
                    },
                    n = 0, r = 0; r < a[Wn]; r++) {
                        if (n |= "inRange" === a[r].valueState, t < a[r].value) return void a[Gn](r, 0, e);
                        n && (a[r].valueState = "inRange")
                    }
                    a.push(e)
                })
            }
            var n = t("./VisualMapModel"),
            r = t(Ar),
            a = t(qe),
            o = [20, 140],
            s = n[jn]({
                type: "visualMap.continuous",
                defaultOption: {
                    align: "auto",
                    calculable: !1,
                    range: null,
                    realtime: !0,
                    itemHeight: null,
                    itemWidth: null,
                    hoverLink: !0,
                    hoverLinkDataSize: null,
                    hoverLinkOnHandle: !0
                },
                optionUpdated: function() {
                    s[Oi](this, "optionUpdated", arguments),
                    this.resetTargetSeries(),
                    this.resetExtent(),
                    this.resetVisual(function(t) {
                        t.mappingMethod = b,
                        t.dataExtent = this[Fi]()
                    }),
                    this._resetRange()
                },
                resetItemSize: function() {
                    s[Oi](this, "resetItemSize", arguments);
                    var t = this.itemSize;
                    this._orient === O && t[S](),
                    (null == t[0] || isNaN(t[0])) && (t[0] = o[0]),
                    (null == t[1] || isNaN(t[1])) && (t[1] = o[1])
                },
                _resetRange: function() {
                    var t = this[Fi](),
                    e = this[zi].range; ! e || e.auto ? (t.auto = 1, this[zi].range = t) : r[An](e) && (e[0] > e[1] && e[S](), e[0] = Math.max(e[0], t[0]), e[1] = Math.min(e[1], t[1]))
                },
                completeVisualOption: function() {
                    n[xr].completeVisualOption.apply(this, arguments),
                    r.each(this.stateList,
                    function(t) {
                        var e = this[zi].controller[t][oe];
                        e && e[0] !== e[1] && (e[0] = 0)
                    },
                    this)
                },
                setSelected: function(t) {
                    this[zi].range = t.slice(),
                    this._resetRange()
                },
                getSelected: function() {
                    var t = this[Fi](),
                    e = a.asc((this.get("range") || []).slice());
                    return e[0] > t[1] && (e[0] = t[1]),
                    e[1] > t[1] && (e[1] = t[1]),
                    e[0] < t[0] && (e[0] = t[0]),
                    e[1] < t[0] && (e[1] = t[0]),
                    e
                },
                getValueState: function(t) {
                    var e = this[zi].range,
                    i = this[Fi]();
                    return (e[0] <= i[0] || e[0] <= t) && (e[1] >= i[1] || t <= e[1]) ? "inRange": "outOfRange"
                },
                findTargetDataIndices: function(t) {
                    var e = [];
                    return this.eachTargetSeries(function(i) {
                        var n = [],
                        r = i[Kn]();
                        r.each(this.getDataDimension(r),
                        function(e, i) {
                            t[0] <= e && e <= t[1] && n.push(i)
                        },
                        !0, this),
                        e.push({
                            seriesId: i.id,
                            dataIndex: n
                        })
                    },
                    this),
                    e
                },
                getStops: function(t, e) {
                    var n = [];
                    return i(this, "outOfRange", this[Fi](), n),
                    i(this, "inRange", this[zi].range.slice(), n),
                    r.each(n,
                    function(t) {
                        t.color = e(this, t.value, t.valueState)
                    },
                    this),
                    n
                }
            });
            return s
        }),
        e("echarts/component/visualMap/ContinuousView", [Tr, "./VisualMapView", Si, Ar, qe, "../helper/sliderMove", "zrender/graphic/LinearGradient", "./helper", Bi],
        function(t) {
            function e(t, e, i, n) {
                return new u[we]({
                    shape: {
                        points: t
                    },
                    draggable: !!i,
                    cursor: e,
                    drift: i,
                    ondragend: n
                })
            }
            function i(t, e) {
                return 0 === t ? [[0, 0], [e, 0], [e, -e]] : [[0, 0], [e, 0], [e, e]]
            }
            function n(t, e, i, n) {
                return t ? [[0, -y(e, x(i, 0))], [S, 0], [0, y(e, x(n - i, 0))]] : [[0, 0], [5, -5], [5, 5]]
            }
            function r(t, e, i) {
                var n = b / 2,
                r = t.get("hoverLinkDataSize");
                return r && (n = g(r, e, i, !0) / 2),
                n
            }
            function a(t) {
                return ! t.get("realtime") && t.get("hoverLinkOnHandle")
            }
            var o = t("./VisualMapView"),
            u = t(Si),
            c = t(Ar),
            h = t(qe),
            d = t("../helper/sliderMove"),
            f = t("zrender/graphic/LinearGradient"),
            p = t("./helper"),
            v = t(Bi),
            g = h[Ge],
            m = c.each,
            y = Math.min,
            x = Math.max,
            b = 12,
            S = 6,
            A = o[jn]({
                type: "visualMap.continuous",
                init: function() {
                    A[Oi](this, "init", arguments),
                    this._shapes = {},
                    this._dataInterval = [],
                    this._handleEnds = [],
                    this._orient,
                    this._useHandle,
                    this._hoverLinkDataIndices = [],
                    this._dragging,
                    this._hovering
                },
                doRender: function(t, e, i, n) {
                    n && "selectDataRange" === n.type && n.from === this.uid || this._buildView()
                },
                _buildView: function() {
                    this.group[cn]();
                    var t = this.visualMapModel,
                    e = this.group;
                    this._orient = t.get(l),
                    this._useHandle = t.get("calculable"),
                    this._resetInterval(),
                    this._renderBar(e);
                    var i = t.get("text");
                    this._renderEndsText(e, i, 0),
                    this._renderEndsText(e, i, 1),
                    this._updateView(!0),
                    this.renderBackground(e),
                    this._updateView(),
                    this._enableHoverLinkToSeries(),
                    this._enableHoverLinkFromSeries(),
                    this.positionGroup(e)
                },
                _renderEndsText: function(t, e, i) {
                    if (e) {
                        var n = e[1 - i];
                        n = null != n ? n + "": "";
                        var r = this.visualMapModel,
                        a = r.get("textGap"),
                        o = r.itemSize,
                        s = this._shapes.barGroup,
                        l = this._applyTransform([o[0] / 2, 0 === i ? -a: o[1] + a], s),
                        c = this._applyTransform(0 === i ? rr: "top", s),
                        h = this._orient,
                        d = this.visualMapModel.textStyleModel;
                        this.group.add(new u.Text({
                            style: {
                                x: l[0],
                                y: l[1],
                                textVerticalAlign: h === O ? Qi: c,
                                textAlign: h === O ? c: Ji,
                                text: n,
                                textFont: d[rn](),
                                fill: d[nn]()
                            }
                        }))
                    }
                },
                _renderBar: function(t) {
                    var i = this.visualMapModel,
                    n = this._shapes,
                    r = i.itemSize,
                    a = this._orient,
                    o = this._useHandle,
                    s = p.getItemAlign(i, this.api, r),
                    l = n.barGroup = this._createBarGroup(s);
                    l.add(n.outOfRange = e()),
                    l.add(n.inRange = e(null, o ? "move": null, c.bind(this._dragHandle, this, "all", !1), c.bind(this._dragHandle, this, "all", !0)));
                    var u = i.textStyleModel.getTextRect("国"),
                    h = x(u.width, u[nr]);
                    o && (n.handleThumbs = [], n.handleLabels = [], n.handleLabelPoints = [], this._createHandle(l, 0, r, h, a, s), this._createHandle(l, 1, r, h, a, s)),
                    this._createIndicator(l, r, h, a),
                    t.add(l)
                },
                _createHandle: function(t, n, r, a, o) {
                    var s = c.bind(this._dragHandle, this, n, !1),
                    l = c.bind(this._dragHandle, this, n, !0),
                    h = e(i(n, a), "move", s, l);
                    h[$i][0] = r[0],
                    t.add(h);
                    var d = this.visualMapModel.textStyleModel,
                    f = new u.Text({
                        draggable: !0,
                        drift: s,
                        ondragend: l,
                        style: {
                            x: 0,
                            y: 0,
                            text: "",
                            textFont: d[rn](),
                            fill: d[nn]()
                        }
                    });
                    this.group.add(f);
                    var p = [o === O ? a / 2 : 1.5 * a, o === O ? 0 === n ? -(1.5 * a) : 1.5 * a: 0 === n ? -a / 2 : a / 2],
                    v = this._shapes;
                    v.handleThumbs[n] = h,
                    v.handleLabelPoints[n] = p,
                    v.handleLabels[n] = f
                },
                _createIndicator: function(t, i, n, r) {
                    var a = e([[0, 0]], "move");
                    a[$i][0] = i[0],
                    a.attr({
                        invisible: !0,
                        silent: !0
                    }),
                    t.add(a);
                    var o = this.visualMapModel.textStyleModel,
                    s = new u.Text({
                        silent: !0,
                        invisible: !0,
                        style: {
                            x: 0,
                            y: 0,
                            text: "",
                            textFont: o[rn](),
                            fill: o[nn]()
                        }
                    });
                    this.group.add(s);
                    var l = [r === O ? n / 2 : S + 3, 0],
                    c = this._shapes;
                    c.indicator = a,
                    c.indicatorLabel = s,
                    c.indicatorLabelPoint = l
                },
                _dragHandle: function(t, e, i, n) {
                    if (this._useHandle) {
                        if (this._dragging = !e, !e) {
                            var r = this._applyTransform([i, n], this._shapes.barGroup, !0);
                            this._updateInterval(t, r[1]),
                            this._updateView()
                        }
                        e === !this.visualMapModel.get("realtime") && this.api[Un]({
                            type: "selectDataRange",
                            from: this.uid,
                            visualMapId: this.visualMapModel.id,
                            selected: this._dataInterval.slice()
                        }),
                        e ? !this._hovering && this._clearHoverLinkToSeries() : a(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1)
                    }
                },
                _resetInterval: function() {
                    var t = this.visualMapModel,
                    e = this._dataInterval = t.getSelected(),
                    i = t[Fi](),
                    n = [0, t.itemSize[1]];
                    this._handleEnds = [g(e[0], i, n, !0), g(e[1], i, n, !0)]
                },
                _updateInterval: function(t, e) {
                    e = e || 0;
                    var i = this.visualMapModel,
                    n = this._handleEnds;
                    d(e, n, [0, i.itemSize[1]], "all" === t ? "rigid": "push", t);
                    var r = i[Fi](),
                    a = [0, i.itemSize[1]];
                    this._dataInterval = [g(n[0], a, r, !0), g(n[1], a, r, !0)]
                },
                _updateView: function(t) {
                    var e = this.visualMapModel,
                    i = e[Fi](),
                    n = this._shapes,
                    r = [0, e.itemSize[1]],
                    a = t ? r: this._handleEnds,
                    o = this._createBarVisual(this._dataInterval, i, a, "inRange"),
                    s = this._createBarVisual(i, i, r, "outOfRange");
                    n.inRange[Ln]({
                        fill: o.barColor,
                        opacity: o[Yi]
                    })[ci](z, o.barPoints),
                    n.outOfRange[Ln]({
                        fill: s.barColor,
                        opacity: s[Yi]
                    })[ci](z, s.barPoints),
                    this._updateHandle(a, o)
                },
                _createBarVisual: function(t, e, i, n) {
                    var r = {
                        forceState: n,
                        convertOpacityToAlpha: !0
                    },
                    a = this._makeColorGradient(t, r),
                    o = [this.getControllerVisual(t[0], oe, r), this.getControllerVisual(t[1], oe, r)],
                    s = this._createBarPoints(i, o);
                    return {
                        barColor: new f(0, 0, 0, 1, a),
                        barPoints: s,
                        handlesColor: [a[0].color, a[a[Wn] - 1].color]
                    }
                },
                _makeColorGradient: function(t, e) {
                    var i = 100,
                    n = [],
                    r = (t[1] - t[0]) / i;
                    n.push({
                        color: this.getControllerVisual(t[0], "color", e),
                        offset: 0
                    });
                    for (var a = 1; i > a; a++) {
                        var o = t[0] + r * a;
                        if (o > t[1]) break;
                        n.push({
                            color: this.getControllerVisual(o, "color", e),
                            offset: a / i
                        })
                    }
                    return n.push({
                        color: this.getControllerVisual(t[1], "color", e),
                        offset: 1
                    }),
                    n
                },
                _createBarPoints: function(t, e) {
                    var i = this.visualMapModel.itemSize;
                    return [[i[0] - e[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - e[1], t[1]]]
                },
                _createBarGroup: function(t) {
                    var e = this._orient,
                    i = this.visualMapModel.get(Q);
                    return new u.Group(e !== O || i ? e === O && i ? {
                        scale: t === rr ? [ - 1, 1] : [1, 1],
                        rotation: -Math.PI / 2
                    }: e !== s || i ? {
                        scale: "left" === t ? [1, 1] : [ - 1, 1]
                    }: {
                        scale: "left" === t ? [1, -1] : [ - 1, -1]
                    }: {
                        scale: t === rr ? [1, 1] : [ - 1, 1],
                        rotation: Math.PI / 2
                    })
                },
                _updateHandle: function(t, e) {
                    if (this._useHandle) {
                        var i = this._shapes,
                        n = this.visualMapModel,
                        r = i.handleThumbs,
                        a = i.handleLabels;
                        m([0, 1],
                        function(o) {
                            var s = r[o];
                            s[Ln]("fill", e.handlesColor[o]),
                            s[$i][1] = t[o];
                            var l = u[_e](i.handleLabelPoints[o], u.getTransform(s, this.group));
                            a[o][Ln]({
                                x: l[0],
                                y: l[1],
                                text: n.formatValueText(this._dataInterval[o]),
                                textVerticalAlign: "middle",
                                textAlign: this._applyTransform(this._orient === O ? 0 === o ? rr: "top": "left", i.barGroup)
                            })
                        },
                        this)
                    }
                },
                _showIndicator: function(t, e, i, r) {
                    var a = this.visualMapModel,
                    o = a[Fi](),
                    s = a.itemSize,
                    l = [0, s[1]],
                    c = g(t, o, l, !0),
                    h = this._shapes,
                    d = h.indicator;
                    if (d) {
                        d[$i][1] = c,
                        d.attr(M, !1),
                        d[ci](z, n( !! i, r, c, s[1]));
                        var f = {
                            convertOpacityToAlpha: !0
                        },
                        p = this.getControllerVisual(t, "color", f);
                        d[Ln]("fill", p);
                        var v = u[_e](h.indicatorLabelPoint, u.getTransform(d, this.group)),
                        m = h.indicatorLabel;
                        m.attr(M, !1);
                        var y = this._applyTransform("left", h.barGroup),
                        x = this._orient;
                        m[Ln]({
                            text: (i ? i: "") + a.formatValueText(e),
                            textVerticalAlign: x === O ? y: Qi,
                            textAlign: x === O ? Ji: y,
                            x: v[0],
                            y: v[1]
                        })
                    }
                },
                _enableHoverLinkToSeries: function() {
                    var t = this;
                    this._shapes.barGroup.on(Rn,
                    function(e) {
                        if (t._hovering = !0, !t._dragging) {
                            var i = t.visualMapModel.itemSize,
                            n = t._applyTransform([e[w], e[_]], t._shapes.barGroup, !0, !0);
                            n[1] = y(x(0, n[1]), i[1]),
                            t._doHoverLinkToSeries(n[1], 0 <= n[0] && n[0] <= i[0])
                        }
                    }).on(On,
                    function() {
                        t._hovering = !1,
                        !t._dragging && t._clearHoverLinkToSeries()
                    })
                },
                _enableHoverLinkFromSeries: function() {
                    var t = this.api.getZr();
                    this.visualMapModel[zi].hoverLink ? (t.on(En, this._hoverLinkFromSeriesMouseOver, this), t.on(On, this._hideIndicator, this)) : this._clearHoverLinkFromSeries()
                },
                _doHoverLinkToSeries: function(t, e) {
                    var i = this.visualMapModel,
                    n = i.itemSize;
                    if (i[zi].hoverLink) {
                        var o = [0, n[1]],
                        s = i[Fi]();
                        t = y(x(o[0], t), o[1]);
                        var l = r(i, s, o),
                        u = [t - l, t + l],
                        c = g(t, o, s, !0),
                        h = [g(u[0], o, s, !0), g(u[1], o, s, !0)];
                        u[0] < o[0] && (h[0] = -1 / 0),
                        u[1] > o[1] && (h[1] = 1 / 0),
                        e && (h[0] === -1 / 0 ? this._showIndicator(c, h[1], "< ", l) : 1 / 0 === h[1] ? this._showIndicator(c, h[0], "> ", l) : this._showIndicator(c, c, "≈ ", l));
                        var d = this._hoverLinkDataIndices,
                        f = []; (e || a(i)) && (f = this._hoverLinkDataIndices = i.findTargetDataIndices(h));
                        var p = v.compressBatches(d, f);
                        this._dispatchHighDown($n, p[0]),
                        this._dispatchHighDown(Jn, p[1])
                    }
                },
                _hoverLinkFromSeriesMouseOver: function(t) {
                    var e = t[Vn];
                    if (e && null != e[zn]) {
                        var i = e.dataModel || this[Te].getSeriesByIndex(e[Dn]),
                        n = i[Kn](e[Pn]),
                        r = n.getDimension(this.visualMapModel.getDataDimension(n)),
                        a = n.get(r, e[zn], !0);
                        isNaN(a) || this._showIndicator(a, a)
                    }
                },
                _hideIndicator: function() {
                    var t = this._shapes;
                    t.indicator && t.indicator.attr(M, !0),
                    t.indicatorLabel && t.indicatorLabel.attr(M, !0)
                },
                _clearHoverLinkToSeries: function() {
                    this._hideIndicator();
                    var t = this._hoverLinkDataIndices;
                    this._dispatchHighDown($n, t),
                    t[Wn] = 0
                },
                _clearHoverLinkFromSeries: function() {
                    this._hideIndicator();
                    var t = this.api.getZr();
                    t.off(En, this._hoverLinkFromSeriesMouseOver),
                    t.off(On, this._hideIndicator)
                },
                _applyTransform: function(t, e, i, n) {
                    var r = u.getTransform(e, n ? null: this.group);
                    return u[c[An](t) ? _e: "transformDirection"](t, r, i)
                },
                _dispatchHighDown: function(t, e) {
                    e && e[Wn] && this.api[Un]({
                        type: t,
                        batch: e
                    })
                },
                dispose: function() {
                    this._clearHoverLinkFromSeries(),
                    this._clearHoverLinkToSeries()
                },
                remove: function() {
                    this._clearHoverLinkFromSeries(),
                    this._clearHoverLinkToSeries()
                }
            });
            return A
        }),
        e("echarts/component/visualMap/visualMapAction", [Tr, Ei],
        function(t) {
            var e = t(Ei),
            i = {
                type: "selectDataRange",
                event: "dataRangeSelected",
                update: "update"
            };
            e[Mn](i,
            function(t, e) {
                e[or]({
                    mainType: "visualMap",
                    query: t
                },
                function(e) {
                    e.setSelected(t[ai])
                })
            })
        }),
        e("echarts/component/toolbox/featureManager", [Tr],
        function() {
            var t = {};
            return {
                register: function(e, i) {
                    t[e] = i
                },
                get: function(e) {
                    return t[e]
                }
            }
        }),
        e("zrender/core/PathProxy", [Tr, "./curve", "./vector", "./bbox", "./BoundingRect", "../config"],
        function(t) {
            var e = t("./curve"),
            i = t("./vector"),
            n = t("./bbox"),
            r = t("./BoundingRect"),
            a = t("../config").devicePixelRatio,
            s = {
                M: 1,
                L: 2,
                C: 3,
                Q: 4,
                A: 5,
                Z: 6,
                R: 7
            },
            l = [],
            u = [],
            c = [],
            v = [],
            g = Math.min,
            m = Math.max,
            y = Math.cos,
            x = Math.sin,
            _ = Math.sqrt,
            w = Math.abs,
            b = typeof Float32Array != Be,
            M = function() {
                this.data = [],
                this._len = 0,
                this._ctx = null,
                this._xi = 0,
                this._yi = 0,
                this._x0 = 0,
                this._y0 = 0,
                this._ux = 0,
                this._uy = 0
            };
            return M[xr] = {
                constructor: M,
                _lineDash: null,
                _dashOffset: 0,
                _dashIdx: 0,
                _dashSum: 0,
                setScale: function(t, e) {
                    this._ux = w(1 / a / t) || 0,
                    this._uy = w(1 / a / e) || 0
                },
                getContext: function() {
                    return this._ctx
                },
                beginPath: function(t) {
                    return this._ctx = t,
                    t && t.beginPath(),
                    t && (this.dpr = t.dpr),
                    this._len = 0,
                    this._lineDash && (this._lineDash = null, this._dashOffset = 0),
                    this
                },
                moveTo: function(t, e) {
                    return this.addData(s.M, t, e),
                    this._ctx && this._ctx[p](t, e),
                    this._x0 = t,
                    this._y0 = e,
                    this._xi = t,
                    this._yi = e,
                    this
                },
                lineTo: function(t, e) {
                    var i = w(t - this._xi) > this._ux || w(e - this._yi) > this._uy || this._len < 5;
                    return this.addData(s.L, t, e),
                    this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx[d](t, e)),
                    i && (this._xi = t, this._yi = e),
                    this
                },
                bezierCurveTo: function(t, e, i, n, r, a) {
                    return this.addData(s.C, t, e, i, n, r, a),
                    this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, r, a) : this._ctx[f](t, e, i, n, r, a)),
                    this._xi = r,
                    this._yi = a,
                    this
                },
                quadraticCurveTo: function(t, e, i, n) {
                    return this.addData(s.Q, t, e, i, n),
                    this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)),
                    this._xi = i,
                    this._yi = n,
                    this
                },
                arc: function(t, e, i, n, r, a) {
                    return this.addData(s.A, t, e, i, i, n, r - n, 0, a ? 0 : 1),
                    this._ctx && this._ctx.arc(t, e, i, n, r, a),
                    this._xi = y(r) * i + t,
                    this._xi = x(r) * i + t,
                    this
                },
                arcTo: function(t, e, i, n, r) {
                    return this._ctx && this._ctx.arcTo(t, e, i, n, r),
                    this
                },
                rect: function(t, e, i, n) {
                    return this._ctx && this._ctx.rect(t, e, i, n),
                    this.addData(s.R, t, e, i, n),
                    this
                },
                closePath: function() {
                    this.addData(s.Z);
                    var t = this._ctx,
                    e = this._x0,
                    i = this._y0;
                    return t && (this._needsDash() && this._dashedLineTo(e, i), t[h]()),
                    this._xi = e,
                    this._yi = i,
                    this
                },
                fill: function(t) {
                    t && t.fill(),
                    this.toStatic()
                },
                stroke: function(t) {
                    t && t[ye](),
                    this.toStatic()
                },
                setLineDash: function(t) {
                    if (t instanceof Array) {
                        this._lineDash = t,
                        this._dashIdx = 0;
                        for (var e = 0,
                        i = 0; i < t[Wn]; i++) e += t[i];
                        this._dashSum = e
                    }
                    return this
                },
                setLineDashOffset: function(t) {
                    return this._dashOffset = t,
                    this
                },
                len: function() {
                    return this._len
                },
                setData: function(t) {
                    var e = t[Wn];
                    this.data && this.data[Wn] == e || !b || (this.data = new Float32Array(e));
                    for (var i = 0; e > i; i++) this.data[i] = t[i];
                    this._len = e
                },
                appendPath: function(t) {
                    t instanceof Array || (t = [t]);
                    for (var e = t[Wn], i = 0, n = this._len, r = 0; e > r; r++) i += t[r].len();
                    b && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
                    for (var r = 0; e > r; r++) for (var a = t[r].data, o = 0; o < a[Wn]; o++) this.data[n++] = a[o];
                    this._len = n
                },
                addData: function(t) {
                    var e = this.data;
                    this._len + arguments[Wn] > e[Wn] && (this._expandData(), e = this.data);
                    for (var i = 0; i < arguments[Wn]; i++) e[this._len++] = arguments[i];
                    this._prevCmd = t
                },
                _expandData: function() {
                    if (! (this.data instanceof Array)) {
                        for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
                        this.data = t
                    }
                },
                _needsDash: function() {
                    return this._lineDash
                },
                _dashedLineTo: function(t, e) {
                    var i, n, r = this._dashSum,
                    a = this._dashOffset,
                    o = this._lineDash,
                    s = this._ctx,
                    l = this._xi,
                    u = this._yi,
                    c = t - l,
                    h = e - u,
                    f = _(c * c + h * h),
                    v = l,
                    y = u,
                    x = o[Wn];
                    for (c /= f, h /= f, 0 > a && (a = r + a), a %= r, v -= a * c, y -= a * h; c > 0 && t >= v || 0 > c && v >= t || 0 == c && (h > 0 && e >= y || 0 > h && y >= e);) n = this._dashIdx,
                    i = o[n],
                    v += c * i,
                    y += h * i,
                    this._dashIdx = (n + 1) % x,
                    c > 0 && l > v || 0 > c && v > l || h > 0 && u > y || 0 > h && y > u || s[n % 2 ? p: d](c >= 0 ? g(v, t) : m(v, t), h >= 0 ? g(y, e) : m(y, e));
                    c = v - t,
                    h = y - e,
                    this._dashOffset = -_(c * c + h * h)
                },
                _dashedBezierTo: function(t, i, n, r, a, o) {
                    var s, l, u, c, h, f = this._dashSum,
                    v = this._dashOffset,
                    g = this._lineDash,
                    m = this._ctx,
                    y = this._xi,
                    x = this._yi,
                    w = e.cubicAt,
                    b = 0,
                    M = this._dashIdx,
                    S = g[Wn],
                    A = 0;
                    for (0 > v && (v = f + v), v %= f, s = 0; 1 > s; s += .1) l = w(y, t, n, a, s + .1) - w(y, t, n, a, s),
                    u = w(x, i, r, o, s + .1) - w(x, i, r, o, s),
                    b += _(l * l + u * u);
                    for (; S > M && (A += g[M], !(A > v)); M++);
                    for (s = (A - v) / b; 1 >= s;) c = w(y, t, n, a, s),
                    h = w(x, i, r, o, s),
                    M % 2 ? m[p](c, h) : m[d](c, h),
                    s += g[M] / b,
                    M = (M + 1) % S;
                    M % 2 !== 0 && m[d](a, o),
                    l = a - c,
                    u = o - h,
                    this._dashOffset = -_(l * l + u * u)
                },
                _dashedQuadraticTo: function(t, e, i, n) {
                    var r = i,
                    a = n;
                    i = (i + 2 * t) / 3,
                    n = (n + 2 * e) / 3,
                    t = (this._xi + 2 * t) / 3,
                    e = (this._yi + 2 * e) / 3,
                    this._dashedBezierTo(t, e, i, n, r, a)
                },
                toStatic: function() {
                    var t = this.data;
                    t instanceof Array && (t[Wn] = this._len, b && (this.data = new Float32Array(t)))
                },
                getBoundingRect: function() {
                    l[0] = l[1] = c[0] = c[1] = Number.MAX_VALUE,
                    u[0] = u[1] = v[0] = v[1] = -Number.MAX_VALUE;
                    for (var t = this.data,
                    e = 0,
                    a = 0,
                    o = 0,
                    h = 0,
                    d = 0; d < t[Wn];) {
                        var f = t[d++];
                        switch (1 == d && (e = t[d], a = t[d + 1], o = e, h = a), f) {
                        case s.M:
                            o = t[d++],
                            h = t[d++],
                            e = o,
                            a = h,
                            c[0] = o,
                            c[1] = h,
                            v[0] = o,
                            v[1] = h;
                            break;
                        case s.L:
                            n.fromLine(e, a, t[d], t[d + 1], c, v),
                            e = t[d++],
                            a = t[d++];
                            break;
                        case s.C:
                            n.fromCubic(e, a, t[d++], t[d++], t[d++], t[d++], t[d], t[d + 1], c, v),
                            e = t[d++],
                            a = t[d++];
                            break;
                        case s.Q:
                            n.fromQuadratic(e, a, t[d++], t[d++], t[d], t[d + 1], c, v),
                            e = t[d++],
                            a = t[d++];
                            break;
                        case s.A:
                            var p = t[d++],
                            g = t[d++],
                            m = t[d++],
                            _ = t[d++],
                            w = t[d++],
                            b = t[d++] + w,
                            M = (t[d++], 1 - t[d++]);
                            1 == d && (o = y(w) * m + p, h = x(w) * _ + g),
                            n.fromArc(p, g, m, _, w, b, M, c, v),
                            e = y(b) * m + p,
                            a = x(b) * _ + g;
                            break;
                        case s.R:
                            o = e = t[d++],
                            h = a = t[d++];
                            var S = t[d++],
                            A = t[d++];
                            n.fromLine(o, h, o + S, h + A, c, v);
                            break;
                        case s.Z:
                            e = o,
                            a = h
                        }
                        i.min(l, l, c),
                        i.max(u, u, v)
                    }
                    return 0 === d && (l[0] = l[1] = u[0] = u[1] = 0),
                    new r(l[0], l[1], u[0] - l[0], u[1] - l[1])
                },
                rebuildPath: function(t) {
                    for (var e, i, n, r, a, l, u = this.data,
                    c = this._ux,
                    v = this._uy,
                    g = this._len,
                    m = 0; g > m;) {
                        var _ = u[m++];
                        switch (1 == m && (n = u[m], r = u[m + 1], e = n, i = r), _) {
                        case s.M:
                            e = n = u[m++],
                            i = r = u[m++],
                            t[p](n, r);
                            break;
                        case s.L:
                            a = u[m++],
                            l = u[m++],
                            (w(a - n) > c || w(l - r) > v || m === g - 1) && (t[d](a, l), n = a, r = l);
                            break;
                        case s.C:
                            t[f](u[m++], u[m++], u[m++], u[m++], u[m++], u[m++]),
                            n = u[m - 2],
                            r = u[m - 1];
                            break;
                        case s.Q:
                            t.quadraticCurveTo(u[m++], u[m++], u[m++], u[m++]),
                            n = u[m - 2],
                            r = u[m - 1];
                            break;
                        case s.A:
                            var b = u[m++],
                            M = u[m++],
                            S = u[m++],
                            A = u[m++],
                            T = u[m++],
                            C = u[m++],
                            L = u[m++],
                            k = u[m++],
                            P = S > A ? S: A,
                            I = S > A ? 1 : S / A,
                            D = S > A ? A / S: 1,
                            z = Math.abs(S - A) > .001,
                            V = T + C;
                            z ? (t.translate(b, M), t[o](L), t.scale(I, D), t.arc(0, 0, P, T, V, 1 - k), t.scale(1 / I, 1 / D), t[o]( - L), t.translate( - b, -M)) : t.arc(b, M, P, T, V, 1 - k),
                            1 == m && (e = y(T) * S + b, i = x(T) * A + M),
                            n = y(V) * S + b,
                            r = x(V) * A + M;
                            break;
                        case s.R:
                            e = n = u[m],
                            i = r = u[m + 1],
                            t.rect(u[m++], u[m++], u[m++], u[m++]);
                            break;
                        case s.Z:
                            t[h](),
                            n = e,
                            r = i
                        }
                    }
                }
            },
            M.CMD = s,
            M
        }),
        e("zrender/tool/transformPath", [Tr, "../core/PathProxy", "../core/vector"],
        function(t) {
            function e(t, e) {
                var n, l, u, c, h, d, f = t.data,
                p = i.M,
                v = i.C,
                g = i.L,
                m = i.R,
                y = i.A,
                x = i.Q;
                for (u = 0, c = 0; u < f[Wn];) {
                    switch (n = f[u++], c = u, l = 0, n) {
                    case p:
                        l = 1;
                        break;
                    case g:
                        l = 1;
                        break;
                    case v:
                        l = 3;
                        break;
                    case x:
                        l = 2;
                        break;
                    case y:
                        var _ = e[4],
                        w = e[5],
                        b = o(e[0] * e[0] + e[1] * e[1]),
                        M = o(e[2] * e[2] + e[3] * e[3]),
                        S = s( - e[1] / M, e[0] / b);
                        f[u++] += _,
                        f[u++] += w,
                        f[u++] *= b,
                        f[u++] *= M,
                        f[u++] += S,
                        f[u++] += S,
                        u += 2,
                        c = u;
                        break;
                    case m:
                        d[0] = f[u++],
                        d[1] = f[u++],
                        r(d, d, e),
                        f[c++] = d[0],
                        f[c++] = d[1],
                        d[0] += f[u++],
                        d[1] += f[u++],
                        r(d, d, e),
                        f[c++] = d[0],
                        f[c++] = d[1]
                    }
                    for (h = 0; l > h; h++) {
                        var d = a[h];
                        d[0] = f[u++],
                        d[1] = f[u++],
                        r(d, d, e),
                        f[c++] = d[0],
                        f[c++] = d[1]
                    }
                }
            }
            var i = t("../core/PathProxy").CMD,
            n = t("../core/vector"),
            r = n[_e],
            a = [[], [], []],
            o = Math.sqrt,
            s = Math.atan2;
            return e
        }),
        e("zrender/graphic/Displayable", [Tr, r, "./Style", "../Element", "./mixin/RectText"],
        function(t) {
            function e(t) {
                t = t || {},
                o.call(this, t);
                for (var e in t) t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
                this.style = new n(t.style),
                this._rect = null,
                this.__clipPaths = []
            }
            var i = t(r),
            n = t("./Style"),
            o = t("../Element"),
            s = t("./mixin/RectText");
            return e[xr] = {
                constructor: e,
                type: "displayable",
                __dirty: !0,
                invisible: !1,
                z: 0,
                z2: 0,
                zlevel: 0,
                draggable: !1,
                dragging: !1,
                silent: !1,
                culling: !1,
                cursor: "pointer",
                rectHover: !1,
                progressive: -1,
                beforeBrush: function() {},
                afterBrush: function() {},
                brush: function() {},
                getBoundingRect: function() {},
                contain: function(t, e) {
                    return this.rectContain(t, e)
                },
                traverse: function(t, e) {
                    t.call(e, this)
                },
                rectContain: function(t, e) {
                    var i = this.transformCoordToLocal(t, e),
                    n = this[en]();
                    return n[ji](i[0], i[1])
                },
                dirty: function() {
                    this[a] = !0,
                    this._rect = null,
                    this.__zr && this.__zr.refresh()
                },
                animateStyle: function(t) {
                    return this[wi]("style", t)
                },
                attrKV: function(t, e) {
                    "style" !== t ? o[xr].attrKV.call(this, t, e) : this.style.set(e)
                },
                setStyle: function(t, e) {
                    return this.style.set(t, e),
                    this.dirty(!1),
                    this
                },
                useStyle: function(t) {
                    return this.style = new n(t),
                    this.dirty(!1),
                    this
                }
            },
            i[vn](e, o),
            i.mixin(e, s),
            e
        }),
        e("zrender/contain/path", [Tr, "../core/PathProxy", "./line", "./cubic", "./quadratic", "./arc", "./util", "../core/curve", "./windingLine"],
        function(t) {
            function e(t, e) {
                return Math.abs(t - e) < m
            }
            function i() {
                var t = x[0];
                x[0] = x[1],
                x[1] = t
            }
            function n(t, e, n, r, a, o, s, l, u, c) {
                if (c > e && c > r && c > o && c > l || e > c && r > c && o > c && l > c) return 0;
                var h = f.cubicRootAt(e, r, o, l, c, y);
                if (0 === h) return 0;
                for (var d, p, v = 0,
                g = -1,
                m = 0; h > m; m++) {
                    var _ = y[m],
                    w = 0 === _ || 1 === _ ? .5 : 1,
                    b = f.cubicAt(t, n, a, s, _);
                    u > b || (0 > g && (g = f.cubicExtrema(e, r, o, l, x), x[1] < x[0] && g > 1 && i(), d = f.cubicAt(e, r, o, l, x[0]), g > 1 && (p = f.cubicAt(e, r, o, l, x[1]))), v += 2 == g ? _ < x[0] ? e > d ? w: -w: _ < x[1] ? d > p ? w: -w: p > l ? w: -w: _ < x[0] ? e > d ? w: -w: d > l ? w: -w)
                }
                return v
            }
            function r(t, e, i, n, r, a, o, s) {
                if (s > e && s > n && s > a || e > s && n > s && a > s) return 0;
                var l = f.quadraticRootAt(e, n, a, s, y);
                if (0 === l) return 0;
                var u = f.quadraticExtremum(e, n, a);
                if (u >= 0 && 1 >= u) {
                    for (var c = 0,
                    h = f.quadraticAt(e, n, a, u), d = 0; l > d; d++) {
                        var p = 0 === y[d] || 1 === y[d] ? .5 : 1,
                        v = f.quadraticAt(t, i, r, y[d]);
                        o > v || (c += y[d] < u ? e > h ? p: -p: h > a ? p: -p)
                    }
                    return c
                }
                var p = 0 === y[0] || 1 === y[0] ? .5 : 1,
                v = f.quadraticAt(t, i, r, y[0]);
                return o > v ? 0 : e > a ? p: -p
            }
            function a(t, e, i, n, r, a, o, s) {
                if (s -= e, s > i || -i > s) return 0;
                var l = Math.sqrt(i * i - s * s);
                y[0] = -l,
                y[1] = l;
                var u = Math.abs(n - r);
                if (1e-4 > u) return 0;
                if (1e-4 > u % g) {
                    n = 0,
                    r = g;
                    var c = a ? 1 : -1;
                    return o >= y[0] + t && o <= y[1] + t ? c: 0
                }
                if (a) {
                    var l = n;
                    n = d(r),
                    r = d(l)
                } else n = d(n),
                r = d(r);
                n > r && (r += g);
                for (var h = 0,
                f = 0; 2 > f; f++) {
                    var p = y[f];
                    if (p + t > o) {
                        var v = Math.atan2(s, p),
                        c = a ? 1 : -1;
                        0 > v && (v = g + v),
                        (v >= n && r >= v || v + g >= n && r >= v + g) && (v > Math.PI / 2 && v < 1.5 * Math.PI && (c = -c), h += c)
                    }
                }
                return h
            }
            function o(t, i, o, l, d) {
                for (var f = 0,
                g = 0,
                m = 0,
                y = 0,
                x = 0,
                _ = 0; _ < t[Wn];) {
                    var w = t[_++];
                    switch (w === s.M && _ > 1 && (o || (f += p(g, m, y, x, l, d))), 1 == _ && (g = t[_], m = t[_ + 1], y = g, x = m), w) {
                    case s.M:
                        y = t[_++],
                        x = t[_++],
                        g = y,
                        m = x;
                        break;
                    case s.L:
                        if (o) {
                            if (v(g, m, t[_], t[_ + 1], i, l, d)) return ! 0
                        } else f += p(g, m, t[_], t[_ + 1], l, d) || 0;
                        g = t[_++],
                        m = t[_++];
                        break;
                    case s.C:
                        if (o) {
                            if (u.containStroke(g, m, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], i, l, d)) return ! 0
                        } else f += n(g, m, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], l, d) || 0;
                        g = t[_++],
                        m = t[_++];
                        break;
                    case s.Q:
                        if (o) {
                            if (c.containStroke(g, m, t[_++], t[_++], t[_], t[_ + 1], i, l, d)) return ! 0
                        } else f += r(g, m, t[_++], t[_++], t[_], t[_ + 1], l, d) || 0;
                        g = t[_++],
                        m = t[_++];
                        break;
                    case s.A:
                        var b = t[_++],
                        M = t[_++],
                        S = t[_++],
                        A = t[_++],
                        T = t[_++],
                        C = t[_++],
                        L = (t[_++], 1 - t[_++]),
                        k = Math.cos(T) * S + b,
                        P = Math.sin(T) * A + M;
                        _ > 1 ? f += p(g, m, k, P, l, d) : (y = k, x = P);
                        var I = (l - b) * A / S + b;
                        if (o) {
                            if (h.containStroke(b, M, A, T, T + C, L, i, I, d)) return ! 0
                        } else f += a(b, M, A, T, T + C, L, I, d);
                        g = Math.cos(T + C) * S + b,
                        m = Math.sin(T + C) * A + M;
                        break;
                    case s.R:
                        y = g = t[_++],
                        x = m = t[_++];
                        var D = t[_++],
                        z = t[_++],
                        k = y + D,
                        P = x + z;
                        if (o) {
                            if (v(y, x, k, x, i, l, d) || v(k, x, k, P, i, l, d) || v(k, P, y, P, i, l, d) || v(y, P, y, x, i, l, d)) return ! 0
                        } else f += p(k, x, k, P, l, d),
                        f += p(y, P, y, x, l, d);
                        break;
                    case s.Z:
                        if (o) {
                            if (v(g, m, y, x, i, l, d)) return ! 0
                        } else f += p(g, m, y, x, l, d);
                        g = y,
                        m = x
                    }
                }
                return o || e(m, x) || (f += p(g, m, y, x, l, d) || 0),
                0 !== f
            }
            var s = t("../core/PathProxy").CMD,
            l = t("./line"),
            u = t("./cubic"),
            c = t("./quadratic"),
            h = t("./arc"),
            d = t("./util").normalizeRadian,
            f = t("../core/curve"),
            p = t("./windingLine"),
            v = l.containStroke,
            g = 2 * Math.PI,
            m = 1e-4,
            y = [ - 1, -1, -1],
            x = [ - 1, -1];
            return {
                contain: function(t, e, i) {
                    return o(t, 0, !1, e, i)
                },
                containStroke: function(t, e, i, n) {
                    return o(t, e, !0, i, n)
                }
            }
        }),
        e("zrender/graphic/Pattern", [Tr],
        function() {
            var t = function(t, e) {
                this.image = t,
                this.repeat = e,
                this.type = "pattern"
            };
            return t[xr].getCanvasPattern = function(t) {
                return this._canvasPattern || (this._canvasPattern = t.createPattern(this.image, this.repeat))
            },
            t
        }),
        e("zrender/graphic/mixin/RectText", [Tr, "../../contain/text", "../../core/BoundingRect"],
        function(t) {
            function e(t, e) {
                return typeof t === yr ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e: parseFloat(t) : t
            }
            var i = t("../../contain/text"),
            n = t("../../core/BoundingRect"),
            r = new n,
            a = function() {};
            return a[xr] = {
                constructor: a,
                drawRectText: function(t, n, a) {
                    var s = this.style,
                    l = s.text;
                    if (null != l && (l += ""), l) {
                        t.save();
                        var u, c, h = s[Z],
                        d = s.textDistance,
                        f = s[an],
                        p = s.textFont || s.font,
                        v = s.textBaseline,
                        g = s.textVerticalAlign;
                        a = a || i[en](l, p, f, v);
                        var m = this[k];
                        if (s.textTransform ? this.setTransform(t) : m && (r.copy(n), r[_e](m), n = r), h instanceof Array) {
                            if (u = n.x + e(h[0], n.width), c = n.y + e(h[1], n[nr]), f = f || "left", v = v || "top", g) {
                                switch (g) {
                                case Qi:
                                    c -= a[nr] / 2 - a.lineHeight / 2;
                                    break;
                                case rr:
                                    c -= a[nr] - a.lineHeight / 2;
                                    break;
                                default:
                                    c += a.lineHeight / 2
                                }
                                v = Qi
                            }
                        } else {
                            var y = i.adjustTextPositionOnRect(h, n, a, d);
                            u = y.x,
                            c = y.y,
                            f = f || y[an],
                            v = v || y.textBaseline
                        }
                        t[an] = f || "left",
                        t.textBaseline = v || "alphabetic";
                        var x = s.textFill,
                        _ = s.textStroke;
                        x && (t.fillStyle = x),
                        _ && (t.strokeStyle = _),
                        t.font = p || "12px sans-serif",
                        t.shadowBlur = s.textShadowBlur,
                        t.shadowColor = s.textShadowColor || "transparent",
                        t.shadowOffsetX = s.textShadowOffsetX,
                        t.shadowOffsetY = s.textShadowOffsetY;
                        var w = l.split("\n");
                        s.textRotation && (m && t.translate(m[4], m[5]), t[o](s.textRotation), m && t.translate( - m[4], -m[5]));
                        for (var b = 0; b < w[Wn]; b++) x && t.fillText(w[b], u, c),
                        _ && t.strokeText(w[b], u, c),
                        c += a.lineHeight;
                        t.restore()
                    }
                }
            },
            a
        }),
        e("zrender/vml/core", [Tr, "exports", "module", "../core/env"],
        function(t, e, i) {
            if (!t("../core/env")[cr]) {
                var n, r = "urn:schemas-microsoft-com:vml",
                a = window,
                o = a.document,
                s = !1;
                try { ! o.namespaces.zrvml && o.namespaces.add("zrvml", r),
                    n = function(t) {
                        return o[Ti]("<zrvml:" + t + ' class="zrvml">')
                    }
                } catch(l) {
                    n = function(t) {
                        return o[Ti]("<" + t + ' xmlns="' + r + '" class="zrvml">')
                    }
                }
                var u = function() {
                    if (!s) {
                        s = !0;
                        var t = o.styleSheets;
                        t[Wn] < 31 ? o.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)")
                    }
                };
                i.exports = {
                    doc: o,
                    initVML: u,
                    createNode: n
                }
            }
        }),
        e("echarts/scale/Ordinal", [Tr, Ar, "./Scale"],
        function(t) {
            var e = t(Ar),
            i = t("./Scale"),
            n = i[xr],
            r = i[jn]({
                type: "ordinal",
                init: function(t, e) {
                    this._data = t,
                    this._extent = e || [0, t[Wn] - 1]
                },
                parse: function(t) {
                    return typeof t === yr ? e[gn](this._data, t) : Math.round(t)
                },
                contain: function(t) {
                    return t = this.parse(t),
                    n[ji].call(this, t) && null != this._data[t]
                },
                normalize: function(t) {
                    return n[Ui].call(this, this.parse(t))
                },
                scale: function(t) {
                    return Math.round(n.scale.call(this, t))
                },
                getTicks: function() {
                    for (var t = [], e = this._extent, i = e[0]; i <= e[1];) t.push(i),
                    i++;
                    return t
                },
                getLabel: function(t) {
                    return this._data[t]
                },
                count: function() {
                    return this._extent[1] - this._extent[0] + 1
                },
                niceTicks: e.noop,
                niceExtent: e.noop
            });
            return r[ir] = function() {
                return new r
            },
            r
        }),
        e("echarts/model/mixin/makeStyleMapper", [Tr, Ar],
        function(t) {
            var e = t(Ar);
            return function(t) {
                for (var i = 0; i < t[Wn]; i++) t[i][1] || (t[i][1] = t[i][0]);
                return function(i) {
                    for (var n = {},
                    r = 0; r < t[Wn]; r++) {
                        var a = t[r][1];
                        if (! (i && e[gn](i, a) >= 0)) {
                            var o = this[Ce](a);
                            null != o && (n[t[r][0]] = o)
                        }
                    }
                    return n
                }
            }
        }),
        e("echarts/coord/polar/AngleAxis", [Tr, Ar, "../Axis"],
        function(t) {
            function e(t, e) {
                e = e || [0, 360],
                r.call(this, "angle", t, e),
                this.type = te
            }
            var i = t(Ar),
            r = t("../Axis");
            return e[xr] = {
                constructor: e,
                dataToAngle: r[xr][B],
                angleToData: r[xr][n]
            },
            i[vn](e, r),
            e
        }),
        e("echarts/coord/polar/RadiusAxis", [Tr, Ar, "../Axis"],
        function(t) {
            function e(t, e) {
                r.call(this, Ze, t, e),
                this.type = te
            }
            var i = t(Ar),
            r = t("../Axis");
            return e[xr] = {
                constructor: e,
                dataToRadius: r[xr][B],
                radiusToData: r[xr][n]
            },
            i[vn](e, r),
            e
        }),
        e("echarts/coord/single/SingleAxis", [Tr, Ar, "../Axis", "../axisHelper"],
        function(t) {
            var e = t(Ar),
            i = t("../Axis"),
            n = t("../axisHelper"),
            r = function(t, e, n, r, a) {
                i.call(this, t, e, n),
                this.type = r || "value",
                this[$i] = a || rr,
                this[l] = null,
                this._labelInterval = null
            };
            return r[xr] = {
                constructor: r,
                model: null,
                isHorizontal: function() {
                    var t = this[$i];
                    return "top" === t || t === rr
                },
                getLabelInterval: function() {
                    var t = this._labelInterval;
                    if (!t) {
                        var i = this.model,
                        r = i[fr](g),
                        a = r.get(R);
                        if (this.type !== te || "auto" !== a) return t = this._labelInterval = "auto" === a ? 0 : a;
                        t = this._labelInterval = n.getAxisLabelInterval(e.map(this.scale[qi](), this[B], this), i[ee](), r[fr](on)[rn](), this[K]())
                    }
                    return t
                },
                toGlobalCoord: null,
                toLocalCoord: null
            },
            e[vn](r, i),
            r
        }),
        e("zrender/core/bbox", [Tr, "./vector", "./curve"],
        function(t) {
            var e = t("./vector"),
            i = t("./curve"),
            n = {},
            r = Math.min,
            a = Math.max,
            o = Math.sin,
            s = Math.cos,
            l = e[ir](),
            u = e[ir](),
            c = e[ir](),
            h = 2 * Math.PI;
            n.fromPoints = function(t, e, i) {
                if (0 !== t[Wn]) {
                    var n, o = t[0],
                    s = o[0],
                    l = o[0],
                    u = o[1],
                    c = o[1];
                    for (n = 1; n < t[Wn]; n++) o = t[n],
                    s = r(s, o[0]),
                    l = a(l, o[0]),
                    u = r(u, o[1]),
                    c = a(c, o[1]);
                    e[0] = s,
                    e[1] = u,
                    i[0] = l,
                    i[1] = c
                }
            },
            n.fromLine = function(t, e, i, n, o, s) {
                o[0] = r(t, i),
                o[1] = r(e, n),
                s[0] = a(t, i),
                s[1] = a(e, n)
            };
            var d = [],
            f = [];
            return n.fromCubic = function(t, e, n, o, s, l, u, c, h, p) {
                var v, g = i.cubicExtrema,
                m = i.cubicAt,
                y = g(t, n, s, u, d);
                for (h[0] = 1 / 0, h[1] = 1 / 0, p[0] = -1 / 0, p[1] = -1 / 0, v = 0; y > v; v++) {
                    var x = m(t, n, s, u, d[v]);
                    h[0] = r(x, h[0]),
                    p[0] = a(x, p[0])
                }
                for (y = g(e, o, l, c, f), v = 0; y > v; v++) {
                    var _ = m(e, o, l, c, f[v]);
                    h[1] = r(_, h[1]),
                    p[1] = a(_, p[1])
                }
                h[0] = r(t, h[0]),
                p[0] = a(t, p[0]),
                h[0] = r(u, h[0]),
                p[0] = a(u, p[0]),
                h[1] = r(e, h[1]),
                p[1] = a(e, p[1]),
                h[1] = r(c, h[1]),
                p[1] = a(c, p[1])
            },
            n.fromQuadratic = function(t, e, n, o, s, l, u, c) {
                var h = i.quadraticExtremum,
                d = i.quadraticAt,
                f = a(r(h(t, n, s), 1), 0),
                p = a(r(h(e, o, l), 1), 0),
                v = d(t, n, s, f),
                g = d(e, o, l, p);
                u[0] = r(t, s, v),
                u[1] = r(e, l, g),
                c[0] = a(t, s, v),
                c[1] = a(e, l, g)
            },
            n.fromArc = function(t, i, n, r, a, d, f, p, v) {
                var g = e.min,
                m = e.max,
                y = Math.abs(a - d);
                if (1e-4 > y % h && y > 1e-4) return p[0] = t - n,
                p[1] = i - r,
                v[0] = t + n,
                void(v[1] = i + r);
                if (l[0] = s(a) * n + t, l[1] = o(a) * r + i, u[0] = s(d) * n + t, u[1] = o(d) * r + i, g(p, l, u), m(v, l, u), a %= h, 0 > a && (a += h), d %= h, 0 > d && (d += h), a > d && !f ? d += h: d > a && f && (a += h), f) {
                    var x = d;
                    d = a,
                    a = x
                }
                for (var _ = 0; d > _; _ += Math.PI / 2) _ > a && (c[0] = s(_) * n + t, c[1] = o(_) * r + i, g(p, c, p), m(v, c, v))
            },
            n
        }),
        e("zrender/config", [],
        function() {
            var t = 1;
            typeof window !== Be && (t = Math.max(window.devicePixelRatio || 1, 1));
            var e = {
                debugMode: 0,
                devicePixelRatio: t
            };
            return e
        }),
        e("zrender/core/curve", [Tr, "./vector"],
        function(t) {
            function e(t) {
                return t > -_ && _ > t
            }
            function i(t) {
                return t > _ || -_ > t
            }
            function n(t, e, i, n, r) {
                var a = 1 - r;
                return a * a * (a * t + 3 * r * e) + r * r * (r * n + 3 * a * i)
            }
            function r(t, e, i, n, r) {
                var a = 1 - r;
                return 3 * (((e - t) * a + 2 * (i - e) * r) * a + (n - i) * r * r)
            }
            function a(t, i, n, r, a, o) {
                var s = r + 3 * (i - n) - t,
                l = 3 * (n - 2 * i + t),
                u = 3 * (i - t),
                c = t - a,
                h = l * l - 3 * s * u,
                d = l * u - 9 * s * c,
                f = u * u - 3 * l * c,
                p = 0;
                if (e(h) && e(d)) if (e(l)) o[0] = 0;
                else {
                    var v = -u / l;
                    v >= 0 && 1 >= v && (o[p++] = v)
                } else {
                    var g = d * d - 4 * h * f;
                    if (e(g)) {
                        var m = d / h,
                        v = -l / s + m,
                        _ = -m / 2;
                        v >= 0 && 1 >= v && (o[p++] = v),
                        _ >= 0 && 1 >= _ && (o[p++] = _)
                    } else if (g > 0) {
                        var w = x(g),
                        S = h * l + 1.5 * s * ( - d + w),
                        A = h * l + 1.5 * s * ( - d - w);
                        S = 0 > S ? -y( - S, M) : y(S, M),
                        A = 0 > A ? -y( - A, M) : y(A, M);
                        var v = ( - l - (S + A)) / (3 * s);
                        v >= 0 && 1 >= v && (o[p++] = v)
                    } else {
                        var T = (2 * h * l - 3 * s * d) / (2 * x(h * h * h)),
                        C = Math.acos(T) / 3,
                        L = x(h),
                        k = Math.cos(C),
                        v = ( - l - 2 * L * k) / (3 * s),
                        _ = ( - l + L * (k + b * Math.sin(C))) / (3 * s),
                        P = ( - l + L * (k - b * Math.sin(C))) / (3 * s);
                        v >= 0 && 1 >= v && (o[p++] = v),
                        _ >= 0 && 1 >= _ && (o[p++] = _),
                        P >= 0 && 1 >= P && (o[p++] = P)
                    }
                }
                return p
            }
            function o(t, n, r, a, o) {
                var s = 6 * r - 12 * n + 6 * t,
                l = 9 * n + 3 * a - 3 * t - 9 * r,
                u = 3 * n - 3 * t,
                c = 0;
                if (e(l)) {
                    if (i(s)) {
                        var h = -u / s;
                        h >= 0 && 1 >= h && (o[c++] = h)
                    }
                } else {
                    var d = s * s - 4 * l * u;
                    if (e(d)) o[0] = -s / (2 * l);
                    else if (d > 0) {
                        var f = x(d),
                        h = ( - s + f) / (2 * l),
                        p = ( - s - f) / (2 * l);
                        h >= 0 && 1 >= h && (o[c++] = h),
                        p >= 0 && 1 >= p && (o[c++] = p)
                    }
                }
                return c
            }
            function s(t, e, i, n, r, a) {
                var o = (e - t) * r + t,
                s = (i - e) * r + e,
                l = (n - i) * r + i,
                u = (s - o) * r + o,
                c = (l - s) * r + s,
                h = (c - u) * r + u;
                a[0] = t,
                a[1] = o,
                a[2] = u,
                a[3] = h,
                a[4] = h,
                a[5] = c,
                a[6] = l,
                a[7] = n
            }
            function l(t, e, i, r, a, o, s, l, u, c, h) {
                var d, f, p, v, g, y = .005,
                _ = 1 / 0;
                S[0] = u,
                S[1] = c;
                for (var b = 0; 1 > b; b += .05) A[0] = n(t, i, a, s, b),
                A[1] = n(e, r, o, l, b),
                v = m(S, A),
                _ > v && (d = b, _ = v);
                _ = 1 / 0;
                for (var M = 0; 32 > M && !(w > y); M++) f = d - y,
                p = d + y,
                A[0] = n(t, i, a, s, f),
                A[1] = n(e, r, o, l, f),
                v = m(A, S),
                f >= 0 && _ > v ? (d = f, _ = v) : (T[0] = n(t, i, a, s, p), T[1] = n(e, r, o, l, p), g = m(T, S), 1 >= p && _ > g ? (d = p, _ = g) : y *= .5);
                return h && (h[0] = n(t, i, a, s, d), h[1] = n(e, r, o, l, d)),
                x(_)
            }
            function u(t, e, i, n) {
                var r = 1 - n;
                return r * (r * t + 2 * n * e) + n * n * i
            }
            function c(t, e, i, n) {
                return 2 * ((1 - n) * (e - t) + n * (i - e))
            }
            function h(t, n, r, a, o) {
                var s = t - 2 * n + r,
                l = 2 * (n - t),
                u = t - a,
                c = 0;
                if (e(s)) {
                    if (i(l)) {
                        var h = -u / l;
                        h >= 0 && 1 >= h && (o[c++] = h)
                    }
                } else {
                    var d = l * l - 4 * s * u;
                    if (e(d)) {
                        var h = -l / (2 * s);
                        h >= 0 && 1 >= h && (o[c++] = h)
                    } else if (d > 0) {
                        var f = x(d),
                        h = ( - l + f) / (2 * s),
                        p = ( - l - f) / (2 * s);
                        h >= 0 && 1 >= h && (o[c++] = h),
                        p >= 0 && 1 >= p && (o[c++] = p)
                    }
                }
                return c
            }
            function d(t, e, i) {
                var n = t + i - 2 * e;
                return 0 === n ? .5 : (t - e) / n
            }
            function f(t, e, i, n, r) {
                var a = (e - t) * n + t,
                o = (i - e) * n + e,
                s = (o - a) * n + a;
                r[0] = t,
                r[1] = a,
                r[2] = s,
                r[3] = s,
                r[4] = o,
                r[5] = i
            }
            function p(t, e, i, n, r, a, o, s, l) {
                var c, h = .005,
                d = 1 / 0;
                S[0] = o,
                S[1] = s;
                for (var f = 0; 1 > f; f += .05) {
                    A[0] = u(t, i, r, f),
                    A[1] = u(e, n, a, f);
                    var p = m(S, A);
                    d > p && (c = f, d = p)
                }
                d = 1 / 0;
                for (var v = 0; 32 > v && !(w > h); v++) {
                    var g = c - h,
                    y = c + h;
                    A[0] = u(t, i, r, g),
                    A[1] = u(e, n, a, g);
                    var p = m(A, S);
                    if (g >= 0 && d > p) c = g,
                    d = p;
                    else {
                        T[0] = u(t, i, r, y),
                        T[1] = u(e, n, a, y);
                        var _ = m(T, S);
                        1 >= y && d > _ ? (c = y, d = _) : h *= .5
                    }
                }
                return l && (l[0] = u(t, i, r, c), l[1] = u(e, n, a, c)),
                x(d)
            }
            var v = t("./vector"),
            g = v[ir],
            m = v.distSquare,
            y = Math.pow,
            x = Math.sqrt,
            _ = 1e-8,
            w = 1e-4,
            b = x(3),
            M = 1 / 3,
            S = g(),
            A = g(),
            T = g();
            return {
                cubicAt: n,
                cubicDerivativeAt: r,
                cubicRootAt: a,
                cubicExtrema: o,
                cubicSubdivide: s,
                cubicProjectPoint: l,
                quadraticAt: u,
                quadraticDerivativeAt: c,
                quadraticRootAt: h,
                quadraticExtremum: d,
                quadraticSubdivide: f,
                quadraticProjectPoint: p
            }
        }),
        e("zrender/graphic/Style", [Tr],
        function() {
            function t(t, e, i) {
                var n = e.x,
                r = e.x2,
                a = e.y,
                o = e.y2;
                e.global || (n = n * i.width + i.x, r = r * i.width + i.x, a = a * i[nr] + i.y, o = o * i[nr] + i.y);
                var s = t.createLinearGradient(n, a, r, o);
                return s
            }
            function e(t, e, i) {
                var n = i.width,
                r = i[nr],
                a = Math.min(n, r),
                o = e.x,
                s = e.y,
                l = e.r;
                e.global || (o = o * n + i.x, s = s * r + i.y, l *= a);
                var u = t.createRadialGradient(o, s, 0, o, s, l);
                return u
            }
            var i = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]],
            n = function(t) {
                this.extendFrom(t)
            };
            n[xr] = {
                constructor: n,
                fill: "#000000",
                stroke: null,
                opacity: 1,
                lineDash: null,
                lineDashOffset: 0,
                shadowBlur: 0,
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                lineWidth: 1,
                strokeNoScale: !1,
                text: null,
                textFill: "#000",
                textStroke: null,
                textPosition: "inside",
                textBaseline: null,
                textAlign: null,
                textVerticalAlign: null,
                textDistance: 5,
                textShadowBlur: 0,
                textShadowOffsetX: 0,
                textShadowOffsetY: 0,
                textTransform: !1,
                textRotation: 0,
                blend: null,
                bind: function(t, e, n) {
                    for (var r = this,
                    a = n && n.style,
                    o = !a,
                    s = 0; s < i[Wn]; s++) {
                        var l = i[s],
                        u = l[0]; (o || r[u] !== a[u]) && (t[u] = r[u] || l[1])
                    }
                    if ((o || r.fill !== a.fill) && (t.fillStyle = r.fill), (o || r[ye] !== a[ye]) && (t.strokeStyle = r[ye]), (o || r[Yi] !== a[Yi]) && (t.globalAlpha = null == r[Yi] ? 1 : r[Yi]), (o || r.blend !== a.blend) && (t.globalCompositeOperation = r.blend || "source-over"), this.hasStroke()) {
                        var c = r[xe];
                        t[xe] = c / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1)
                    }
                },
                hasFill: function() {
                    var t = this.fill;
                    return null != t && "none" !== t
                },
                hasStroke: function() {
                    var t = this[ye];
                    return null != t && "none" !== t && this[xe] > 0
                },
                extendFrom: function(t, e) {
                    if (t) {
                        var i = this;
                        for (var n in t) ! t.hasOwnProperty(n) || !e && i.hasOwnProperty(n) || (i[n] = t[n])
                    }
                },
                set: function(t, e) {
                    typeof t === yr ? this[t] = e: this.extendFrom(t, !0)
                },
                clone: function() {
                    var t = new this.constructor;
                    return t.extendFrom(this, !0),
                    t
                },
                getGradient: function(i, n, r) {
                    for (var a = "radial" === n.type ? e: t, o = a(i, n, r), s = n.colorStops, l = 0; l < s[Wn]; l++) o.addColorStop(s[l].offset, s[l].color);
                    return o
                }
            };
            for (var r = n[xr], a = 0; a < i[Wn]; a++) {
                var o = i[a];
                o[0] in r || (r[o[0]] = o[1])
            }
            return n.getGradient = r.getGradient,
            n
        }),
        e("zrender/Element", [Tr, "./core/guid", "./mixin/Eventful", "./mixin/Transformable", "./mixin/Animatable", "./core/util"],
        function(t) {
            var e = t("./core/guid"),
            n = t("./mixin/Eventful"),
            r = t("./mixin/Transformable"),
            a = t("./mixin/Animatable"),
            o = t("./core/util"),
            l = function(t) {
                r.call(this, t),
                n.call(this, t),
                a.call(this, t),
                this.id = t.id || e()
            };
            return l[xr] = {
                type: "element",
                name: "",
                __zr: null,
                ignore: !1,
                clipPath: null,
                drift: function(t, e) {
                    switch (this[L]) {
                    case O:
                        e = 0;
                        break;
                    case s:
                        t = 0
                    }
                    var i = this[k];
                    i || (i = this[k] = [1, 0, 0, 1, 0, 0]),
                    i[4] += t,
                    i[5] += e,
                    this.decomposeTransform(),
                    this.dirty(!1)
                },
                beforeUpdate: function() {},
                afterUpdate: function() {},
                update: function() {
                    this[i]()
                },
                traverse: function() {},
                attrKV: function(t, e) {
                    if (t === $i || "scale" === t || "origin" === t) {
                        if (e) {
                            var i = this[t];
                            i || (i = this[t] = []),
                            i[0] = e[0],
                            i[1] = e[1]
                        }
                    } else this[t] = e
                },
                hide: function() {
                    this[ar] = !0,
                    this.__zr && this.__zr.refresh()
                },
                show: function() {
                    this[ar] = !1,
                    this.__zr && this.__zr.refresh()
                },
                attr: function(t, e) {
                    if (typeof t === yr) this.attrKV(t, e);
                    else if (o[Yn](t)) for (var i in t) t.hasOwnProperty(i) && this.attrKV(i, t[i]);
                    return this.dirty(!1),
                    this
                },
                setClipPath: function(t) {
                    var e = this.__zr;
                    e && t.addSelfToZr(e),
                    this.clipPath && this.clipPath !== t && this.removeClipPath(),
                    this.clipPath = t,
                    t.__zr = e,
                    t.__clipTarget = this,
                    this.dirty(!1)
                },
                removeClipPath: function() {
                    var t = this.clipPath;
                    t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1))
                },
                addSelfToZr: function(t) {
                    this.__zr = t;
                    var e = this.animators;
                    if (e) for (var i = 0; i < e[Wn]; i++) t[vr].addAnimator(e[i]);
                    this.clipPath && this.clipPath.addSelfToZr(t)
                },
                removeSelfFromZr: function(t) {
                    this.__zr = null;
                    var e = this.animators;
                    if (e) for (var i = 0; i < e[Wn]; i++) t[vr].removeAnimator(e[i]);
                    this.clipPath && this.clipPath.removeSelfFromZr(t)
                }
            },
            o.mixin(l, a),
            o.mixin(l, r),
            o.mixin(l, n),
            l
        }),
        e("echarts/chart/helper/LineDraw", [Tr, Si, "./Line"],
        function(t) {
            function e(t) {
                return isNaN(t[0]) || isNaN(t[1])
            }
            function i(t) {
                return ! e(t[0]) && !e(t[1])
            }
            function n(t) {
                this._ctor = t || a,
                this.group = new r.Group
            }
            var r = t(Si),
            a = t("./Line"),
            o = n[xr];
            return o[yi] = function(t) {
                var e = this._lineData,
                n = this.group,
                r = this._ctor,
                a = t[fi],
                o = {
                    lineStyle: a[fr]("lineStyle.normal")[ti](),
                    hoverLineStyle: a[fr]("lineStyle.emphasis")[ti](),
                    labelModel: a[fr](ii),
                    hoverLabelModel: a[fr](ei)
                };
                t.diff(e).add(function(e) {
                    if (i(t[bi](e))) {
                        var a = new r(t, e, o);
                        t[$e](e, a),
                        n.add(a)
                    }
                })[er](function(a, s) {
                    var l = e[Mi](s);
                    return i(t[bi](a)) ? (l ? l[yi](t, a, o) : l = new r(t, a, o), t[$e](a, l), void n.add(l)) : void n[Xn](l)
                })[Xn](function(t) {
                    n[Xn](e[Mi](t))
                })[Qe](),
                this._lineData = t
            },
            o[Qn] = function() {
                var t = this._lineData;
                t[Se](function(e, i) {
                    e[Qn](t, i)
                },
                this)
            },
            o[Xn] = function() {
                this.group[cn]()
            },
            n
        }),
        e("echarts/coord/cartesian/Cartesian", [Tr, Ar],
        function(t) {
            function e(t) {
                return this._axes[t]
            }
            var i = t(Ar),
            r = function(t) {
                this._axes = {},
                this._dimList = [],
                this.name = t || ""
            };
            return r[xr] = {
                constructor: r,
                type: "cartesian",
                getAxis: function(t) {
                    return this._axes[t]
                },
                getAxes: function() {
                    return i.map(this._dimList, e, this)
                },
                getAxesByScale: function(t) {
                    return t = t[_r](),
                    i[mn](this.getAxes(),
                    function(e) {
                        return e.scale.type === t
                    })
                },
                addAxis: function(t) {
                    var e = t.dim;
                    this._axes[e] = t,
                    this._dimList.push(e)
                },
                dataToCoord: function(t) {
                    return this._dataCoordConvert(t, B)
                },
                coordToData: function(t) {
                    return this._dataCoordConvert(t, n)
                },
                _dataCoordConvert: function(t, e) {
                    for (var i = this._dimList,
                    n = t instanceof Array ? [] : {},
                    r = 0; r < i[Wn]; r++) {
                        var a = i[r],
                        o = this._axes[a];
                        n[a] = o[e](t[a])
                    }
                    return n
                }
            },
            r
        }),
        e("echarts/data/helper/completeDimensions", [Tr, Ar],
        function(t) {
            function e(t, e, a, o) {
                if (!e) return t;
                var s = i(e[0]),
                l = n[An](s) && s[Wn] || 1;
                a = a || [],
                o = o || "extra";
                for (var u = 0; l > u; u++) if (!t[u]) {
                    var c = a[u] || o + (u - a[Wn]);
                    t[u] = r(e, u) ? {
                        type: "ordinal",
                        name: c
                    }: c
                }
                return t
            }
            function i(t) {
                return n[An](t) ? t: n[Yn](t) ? t.value: t
            }
            var n = t(Ar),
            r = e.guessOrdinal = function(t, e) {
                for (var r = 0,
                a = t[Wn]; a > r; r++) {
                    var o = i(t[r]);
                    if (!n[An](o)) return ! 1;
                    var o = o[e];
                    if (null != o && isFinite(o)) return ! 1;
                    if (n[pn](o) && "-" !== o) return ! 0
                }
                return ! 1
            };
            return e
        }),
        e("echarts/chart/helper/EffectLine", [Tr, Si, "./Line", Ar, I, wr, "zrender/core/curve"],
        function(t) {
            function e(t, e, n) {
                i.Group.call(this),
                this.add(this.createLine(t, e, n)),
                this._updateEffectSymbol(t, e)
            }
            var i = t(Si),
            n = t("./Line"),
            r = t(Ar),
            a = t(I),
            o = t(wr),
            s = t("zrender/core/curve"),
            l = e[xr];
            return l.createLine = function(t, e, i) {
                return new n(t, e, i)
            },
            l._updateEffectSymbol = function(t, e) {
                var i = t[hi](e),
                n = i[fr]("effect"),
                o = n.get(oe),
                s = n.get(se);
                r[An](o) || (o = [o, o]);
                var l = n.get("color") || t[gi](e, "color"),
                u = this[di](1);
                this._symbolType !== s && (this[Xn](u), u = a[P](s, -.5, -.5, 1, 1, l), u.z2 = 100, u.culling = !0, this.add(u)),
                u && (u[Ln]("shadowColor", l), u[Ln](n[sn](["color"])), u.attr("scale", o), u.setColor(l), u.attr("scale", o), this._symbolType = s, this._updateEffectAnimation(t, n, e))
            },
            l._updateEffectAnimation = function(t, e, i) {
                var n = this[di](1);
                if (n) {
                    var r = this,
                    a = t[bi](i),
                    o = 1e3 * e.get("period"),
                    s = e.get("loop"),
                    l = e.get("constantSpeed"),
                    u = e.get("delay") ||
                    function(e) {
                        return e / t.count() * o / 3
                    },
                    c = typeof u === Sn;
                    if (n[ar] = !0, this.updateAnimationPoints(n, a), l > 0 && (o = this.getLineLength(n) / l * 1e3), o !== this._period || s !== this._loop) {
                        n[sr]();
                        var h = u;
                        c && (h = u(i)),
                        n.__t > 0 && (h = -o * n.__t),
                        n.__t = 0;
                        var d = n[wi]("", s).when(o, {
                            __t: 1
                        }).delay(h).during(function() {
                            r.updateSymbolPosition(n)
                        });
                        s || d.done(function() {
                            r[Xn](n)
                        }),
                        d.start()
                    }
                    this._period = o,
                    this._loop = s
                }
            },
            l.getLineLength = function(t) {
                return o.dist(t.__p1, t.__cp1) + o.dist(t.__cp1, t.__p2)
            },
            l.updateAnimationPoints = function(t, e) {
                t.__p1 = e[0],
                t.__p2 = e[1],
                t.__cp1 = e[2] || [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2]
            },
            l[yi] = function(t, e, i) {
                this[di](0)[yi](t, e, i),
                this._updateEffectSymbol(t, e)
            },
            l.updateSymbolPosition = function(t) {
                var e = t.__p1,
                i = t.__p2,
                n = t.__cp1,
                r = t.__t,
                a = t[$i],
                o = s.quadraticAt,
                l = s.quadraticDerivativeAt;
                a[0] = o(e[0], n[0], i[0], r),
                a[1] = o(e[1], n[1], i[1], r);
                var u = l(e[0], n[0], i[0], r),
                c = l(e[1], n[1], i[1], r);
                t[ni] = -Math.atan2(c, u) - Math.PI / 2,
                t[ar] = !1
            },
            l[Qn] = function(t, e) {
                this[di](0)[Qn](t, e);
                var i = t[hi](e)[fr]("effect");
                this._updateEffectAnimation(t, i, e)
            },
            r[vn](e, i.Group),
            e
        }),
        e("echarts/chart/helper/Line", [Tr, I, wr, "./LinePath", Si, Ar, qe],
        function(t) {
            function e(t) {
                return "_" + t + "Type"
            }
            function i(t, e, i) {
                var n = e[gi](i, "color"),
                r = e[gi](i, t),
                a = e[gi](i, t + "Size");
                if (r && "none" !== r) {
                    d[An](a) || (a = [a, a]);
                    var o = l[P](r, -a[0] / 2, -a[1] / 2, a[0], a[1], n);
                    return o.name = t,
                    o
                }
            }
            function n(t) {
                var e = new c({
                    name: "line"
                });
                return r(e.shape, t),
                e
            }
            function r(t, e) {
                var i = e[0],
                n = e[1],
                r = e[2];
                t.x1 = i[0],
                t.y1 = i[1],
                t.x2 = n[0],
                t.y2 = n[1],
                t.percent = 1,
                r ? (t.cpx1 = r[0], t.cpy1 = r[1]) : (t.cpx1 = 0 / 0, t.cpy1 = 0 / 0)
            }
            function o() {
                var t = this,
                e = t.childOfName("fromSymbol"),
                i = t.childOfName("toSymbol"),
                n = t.childOfName("label");
                if (e || i || !n[ar]) {
                    for (var r = 1,
                    o = this[pe]; o;) o.scale && (r /= o.scale[0]),
                    o = o[pe];
                    var s = t.childOfName("line");
                    if (this[a] || s[a]) {
                        var l = s.shape.percent,
                        c = s.pointAt(0),
                        h = s.pointAt(l),
                        d = u.sub([], h, c);
                        if (u[Ui](d, d), e) {
                            e.attr($i, c);
                            var f = s.tangentAt(0);
                            e.attr(ni, Math.PI / 2 - Math.atan2(f[1], f[0])),
                            e.attr("scale", [r * l, r * l])
                        }
                        if (i) {
                            i.attr($i, h);
                            var f = s.tangentAt(1);
                            i.attr(ni, -Math.PI / 2 - Math.atan2(f[1], f[0])),
                            i.attr("scale", [r * l, r * l])
                        }
                        if (!n[ar]) {
                            n.attr($i, h);
                            var p, v, g, m = 5 * r;
                            if ("end" === n.__position) p = [d[0] * m + h[0], d[1] * m + h[1]],
                            v = d[0] > .8 ? "left": d[0] < -.8 ? "right": Ji,
                            g = d[1] > .8 ? "top": d[1] < -.8 ? rr: Qi;
                            else if (n.__position === Qi) {
                                var y = l / 2,
                                f = s.tangentAt(y),
                                x = [f[1], -f[0]],
                                _ = s.pointAt(y);
                                x[1] > 0 && (x[0] = -x[0], x[1] = -x[1]),
                                p = [_[0] + x[0] * m, _[1] + x[1] * m],
                                v = Ji,
                                g = rr;
                                var w = -Math.atan2(f[1], f[0]);
                                h[0] < c[0] && (w = Math.PI + w),
                                n.attr(ni, w)
                            } else p = [ - d[0] * m + c[0], -d[1] * m + c[1]],
                            v = d[0] > .8 ? "right": d[0] < -.8 ? "left": Ji,
                            g = d[1] > .8 ? rr: d[1] < -.8 ? "top": Qi;
                            n.attr({
                                style: {
                                    textVerticalAlign: n.__verticalAlign || g,
                                    textAlign: n.__textAlign || v
                                },
                                position: p,
                                scale: [r, r]
                            })
                        }
                    }
                }
            }
            function s(t, e, i) {
                h.Group.call(this),
                this._createLine(t, e, i)
            }
            var l = t(I),
            u = t(wr),
            c = t("./LinePath"),
            h = t(Si),
            d = t(Ar),
            f = t(qe),
            p = ["fromSymbol", "toSymbol"],
            v = s[xr];
            return v.beforeUpdate = o,
            v._createLine = function(t, r, a) {
                var o = t[fi],
                s = t[bi](r),
                l = n(s);
                l.shape.percent = 0,
                h[Xe](l, {
                    shape: {
                        percent: 1
                    }
                },
                o, r),
                this.add(l);
                var u = new h.Text({
                    name: "label"
                });
                this.add(u),
                d.each(p,
                function(n) {
                    var a = i(n, t, r);
                    this.add(a),
                    this[e(n)] = t[gi](r, n)
                },
                this),
                this._updateCommonStl(t, r, a)
            },
            v[yi] = function(t, n, a) {
                var o = t[fi],
                s = this.childOfName("line"),
                l = t[bi](n),
                u = {
                    shape: {}
                };
                r(u.shape, l),
                h[ui](s, u, o, n),
                d.each(p,
                function(r) {
                    var a = t[gi](n, r),
                    o = e(r);
                    if (this[o] !== a) {
                        this[Xn](this.childOfName(r));
                        var s = i(r, t, n);
                        this.add(s)
                    }
                    this[o] = a
                },
                this),
                this._updateCommonStl(t, n, a)
            },
            v._updateCommonStl = function(t, e, i) {
                var n = t[fi],
                r = this.childOfName("line"),
                a = i && i[Ke],
                o = i && i.hoverLineStyle,
                s = i && i.labelModel,
                l = i && i.hoverLabelModel;
                if (!i || t[fe]) {
                    var u = t[hi](e);
                    a = u[fr]("lineStyle.normal")[ti](),
                    o = u[fr]("lineStyle.emphasis")[ti](),
                    s = u[fr](ii),
                    l = u[fr](ei)
                }
                var c = t[gi](e, "color"),
                v = d[vi](t[gi](e, Yi), a[Yi], 1);
                isNaN(g) && (g = t[Ci](e)),
                r[si](d[qn]({
                    strokeNoScale: !0,
                    fill: "none",
                    stroke: c,
                    opacity: v
                },
                a)),
                r[oi] = o,
                d.each(p,
                function(t) {
                    var e = this.childOfName(t);
                    e && (e.setColor(c), e[Ln]({
                        opacity: v
                    }))
                },
                this);
                var g, m, y = s[Ce]("show"),
                x = l[Ce]("show"),
                _ = this.childOfName("label");
                if ((y || x) && (g = f.round(n[ke](e)), m = c || "#000"), y) {
                    var w = s[fr](on);
                    _[Ln]({
                        text: d[vi](n[pi](e, ki, t[Pn]), g),
                        textFont: w[rn](),
                        fill: w[nn]() || m
                    }),
                    _.__textAlign = w.get("align"),
                    _.__verticalAlign = w.get("baseline"),
                    _.__position = s.get($i)
                } else _[Ln]("text", "");
                if (x) {
                    var b = l[fr](on);
                    _[oi] = {
                        text: d[vi](n[pi](e, Li, t[Pn]), g),
                        textFont: b[rn](),
                        fill: b[nn]() || m
                    }
                } else _[oi] = {
                    text: ""
                };
                _[ar] = !y && !x,
                h[ri](this)
            },
            v[Qn] = function(t, e) {
                this.setLinePoints(t[bi](e))
            },
            v.setLinePoints = function(t) {
                var e = this.childOfName("line");
                r(e.shape, t),
                e.dirty()
            },
            d[vn](s, h.Group),
            s
        }),
        e("echarts/chart/helper/Polyline", [Tr, Si, Ar],
        function(t) {
            function e(t, e, n) {
                i.Group.call(this),
                this._createPolyline(t, e, n)
            }
            var i = t(Si),
            n = t(Ar),
            r = e[xr];
            return r._createPolyline = function(t, e, n) {
                var r = t[bi](e),
                a = new i[xi]({
                    shape: {
                        points: r
                    }
                });
                this.add(a),
                this._updateCommonStl(t, e, n)
            },
            r[yi] = function(t, e, n) {
                var r = t[fi],
                a = this[di](0),
                o = {
                    shape: {
                        points: t[bi](e)
                    }
                };
                i[ui](a, o, r, e),
                this._updateCommonStl(t, e, n)
            },
            r._updateCommonStl = function(t, e, r) {
                var a = this[di](0),
                o = t[hi](e),
                s = t[gi](e, "color"),
                l = r && r[Ke],
                u = r && r.hoverLineStyle; (!r || t[fe]) && (l = o[fr]("lineStyle.normal")[ti](), u = o[fr]("lineStyle.emphasis")[ti]()),
                a[si](n[qn]({
                    strokeNoScale: !0,
                    fill: "none",
                    stroke: s
                },
                l)),
                a[oi] = u,
                i[ri](this)
            },
            r[Qn] = function(t, e) {
                var i = this[di](0);
                i[ci](z, t[bi](e))
            },
            n[vn](e, i.Group),
            e
        }),
        e("echarts/chart/gauge/PointerPath", [Tr, "zrender/graphic/Path"],
        function(t) {
            return t("zrender/graphic/Path")[jn]({
                type: "echartsGaugePointer",
                shape: {
                    angle: 0,
                    width: 10,
                    r: 10,
                    x: 0,
                    y: 0
                },
                buildPath: function(t, e) {
                    var i = Math.cos,
                    n = Math.sin,
                    r = e.r,
                    a = e.width,
                    o = e.angle,
                    s = e.x - i(o) * a * (a >= r / 3 ? 1 : 2),
                    l = e.y - n(o) * a * (a >= r / 3 ? 1 : 2);
                    o = e.angle - Math.PI / 2,
                    t[p](s, l),
                    t[d](e.x + i(o) * a, e.y + n(o) * a),
                    t[d](e.x + i(e.angle) * r, e.y + n(e.angle) * r),
                    t[d](e.x - i(o) * a, e.y - n(o) * a),
                    t[d](s, l)
                }
            })
        }),
        e("echarts/chart/helper/LargeLineDraw", [Tr, Si, "zrender/contain/quadratic", "zrender/contain/line"],
        function(t) {
            function e() {
                this.group = new i.Group,
                this._lineEl = new a
            }
            var i = t(Si),
            n = t("zrender/contain/quadratic"),
            r = t("zrender/contain/line"),
            a = i.extendShape({
                shape: {
                    polyline: !1,
                    segs: []
                },
                buildPath: function(t, e) {
                    for (var i = e.segs,
                    n = e.polyline,
                    r = 0; r < i[Wn]; r++) {
                        var a = i[r];
                        if (n) {
                            t[p](a[0][0], a[0][1]);
                            for (var o = 1; o < a[Wn]; o++) t[d](a[o][0], a[o][1])
                        } else t[p](a[0][0], a[0][1]),
                        a[Wn] > 2 ? t.quadraticCurveTo(a[2][0], a[2][1], a[1][0], a[1][1]) : t[d](a[1][0], a[1][1])
                    }
                },
                findDataIndex: function(t, e) {
                    for (var i = this.shape,
                    a = i.segs,
                    o = i.polyline,
                    s = Math.max(this.style[xe], 1), l = 0; l < a[Wn]; l++) {
                        var u = a[l];
                        if (o) {
                            for (var c = 1; c < u[Wn]; c++) if (r.containStroke(u[c - 1][0], u[c - 1][1], u[c][0], u[c][1], s, t, e)) return l
                        } else if (u[Wn] > 2) {
                            if (n.containStroke(u[0][0], u[0][1], u[2][0], u[2][1], u[1][0], u[1][1], s, t, e)) return l
                        } else if (r.containStroke(u[0][0], u[0][1], u[1][0], u[1][1], s, t, e)) return l
                    }
                    return - 1
                }
            }),
            o = e[xr];
            return o[yi] = function(t) {
                this.group[cn]();
                var e = this._lineEl,
                i = t[fi];
                e[ci]({
                    segs: t[he](t[bi]),
                    polyline: i.get("polyline")
                }),
                e[si](i[fr]("lineStyle.normal")[ti]());
                var n = t[ce]("color");
                n && e[Ln](ye, n),
                e[Ln]("fill"),
                e[Dn] = i[Dn],
                e.on(Rn,
                function(t) {
                    e[zn] = null;
                    var i = e.findDataIndex(t[w], t[_]);
                    i > 0 && (e[zn] = i)
                }),
                this.group.add(e)
            },
            o[Qn] = function(t) {
                var e = t[Kn]();
                this._lineEl[ci]({
                    segs: e[he](e[bi])
                })
            },
            o[Xn] = function() {
                this.group[cn]()
            },
            e
        }),
        e("echarts/chart/helper/EffectPolyline", [Tr, "./Polyline", Ar, "./EffectLine", wr],
        function(t) {
            function e(t, e, i) {
                r.call(this, t, e, i),
                this._lastFrame = 0,
                this._lastFramePercent = 0
            }
            var i = t("./Polyline"),
            n = t(Ar),
            r = t("./EffectLine"),
            a = t(wr),
            o = e[xr];
            return o.createLine = function(t, e, n) {
                return new i(t, e, n)
            },
            o.updateAnimationPoints = function(t, e) {
                this._points = e;
                for (var i = [0], n = 0, r = 1; r < e[Wn]; r++) {
                    var o = e[r - 1],
                    s = e[r];
                    n += a.dist(o, s),
                    i.push(n)
                }
                if (0 !== n) {
                    for (var r = 0; r < i[Wn]; r++) i[r] /= n;
                    this._offsets = i,
                    this._length = n
                }
            },
            o.getLineLength = function() {
                return this._length
            },
            o.updateSymbolPosition = function(t) {
                var e = t.__t,
                i = this._points,
                n = this._offsets,
                r = i[Wn];
                if (n) {
                    var o, s = this._lastFrame;
                    if (e < this._lastFramePercent) {
                        var l = Math.min(s + 1, r - 1);
                        for (o = l; o >= 0 && !(n[o] <= e); o--);
                        o = Math.min(o, r - 2)
                    } else {
                        for (var o = s; r > o && !(n[o] > e); o++);
                        o = Math.min(o - 1, r - 2)
                    }
                    a.lerp(t[$i], i[o], i[o + 1], (e - n[o]) / (n[o + 1] - n[o])),
                    this._lastFrame = o,
                    this._lastFramePercent = e,
                    t[ar] = !1
                }
            },
            n[vn](e, r),
            e
        }),
        e("echarts/coord/geo/Geo", [Tr, "./parseGeoJson", Ar, Me, "../View", "./fix/nanhai", "./fix/textCoord", "./fix/geoCoord"],
        function(t) {
            function e(t, e, i, n, r) {
                o.call(this, t),
                this.map = e,
                this._nameCoordMap = {},
                this.loadGeoJson(i, n, r)
            }
            var n = t("./parseGeoJson"),
            r = t(Ar),
            a = t(Me),
            o = t("../View"),
            s = [t("./fix/nanhai"), t("./fix/textCoord"), t("./fix/geoCoord")];
            return e[xr] = {
                constructor: e,
                type: "geo",
                dimensions: ["lng", "lat"],
                containCoord: function(t) {
                    for (var e = this.regions,
                    i = 0; i < e[Wn]; i++) if (e[i][ji](t)) return ! 0;
                    return ! 1
                },
                loadGeoJson: function(t, e, i) {
                    try {
                        this.regions = t ? n(t) : []
                    } catch(a) {
                        throw "Invalid geoJson format\n" + a
                    }
                    e = e || {},
                    i = i || {};
                    for (var o = this.regions,
                    l = {},
                    u = 0; u < o[Wn]; u++) {
                        var c = o[u].name;
                        c = i[c] || c,
                        o[u].name = c,
                        l[c] = o[u],
                        this.addGeoCoord(c, o[u][Ji]);
                        var h = e[c];
                        h && o[u].transformTo(h.left, h.top, h.width, h[nr])
                    }
                    this._regionsMap = l,
                    this._rect = null,
                    r.each(s,
                    function(t) {
                        t(this)
                    },
                    this)
                },
                transformTo: function(t, e, n, r) {
                    var o = this[en]();
                    o = o.clone(),
                    o.y = -o.y - o[nr];
                    var s = this._viewTransform;
                    s[k] = o.calculateTransform(new a(t, e, n, r)),
                    s.decomposeTransform();
                    var l = s.scale;
                    l[1] = -l[1],
                    s[i](),
                    this._updateTransform()
                },
                getRegion: function(t) {
                    return this._regionsMap[t]
                },
                getRegionByCoord: function(t) {
                    for (var e = this.regions,
                    i = 0; i < e[Wn]; i++) if (e[i][ji](t)) return e[i]
                },
                addGeoCoord: function(t, e) {
                    this._nameCoordMap[t] = e
                },
                getGeoCoord: function(t) {
                    return this._nameCoordMap[t]
                },
                getBoundingRect: function() {
                    if (this._rect) return this._rect;
                    for (var t, e = this.regions,
                    i = 0; i < e[Wn]; i++) {
                        var n = e[i][en]();
                        t = t || n.clone(),
                        t.union(n)
                    }
                    return this._rect = t || new a(0, 0, 0, 0)
                },
                dataToPoints: function(t) {
                    var e = [];
                    return t[he](["lng", "lat"],
                    function(t, i) {
                        return e[0] = t,
                        e[1] = i,
                        this[ae](e)
                    },
                    this)
                },
                dataToPoint: function(t) {
                    return typeof t === yr && (t = this.getGeoCoord(t)),
                    t ? o[xr][ae].call(this, t) : void 0
                }
            },
            r.mixin(e, o),
            e
        }),
        e("echarts/component/dataZoom/AxisProxy", [Tr, Ar, qe],
        function(t) {
            function e(t, e) {
                var i = [1 / 0, -1 / 0];
                return s(e,
                function(e) {
                    var n = e[Kn]();
                    n && s(e[j](t),
                    function(t) {
                        var e = n[Fe](t);
                        e[0] < i[0] && (i[0] = e[0]),
                        e[1] > i[1] && (i[1] = e[1])
                    })
                },
                this),
                i
            }
            function i(t, e, i) {
                var r = i.getAxisModel(),
                a = r.axis.scale,
                u = [0, 100],
                c = [t.start, t.end],
                h = [];
                return e = e.slice(),
                n(e, r, a),
                s(["startValue", "endValue"],
                function(e) {
                    h.push(null != t[e] ? a.parse(t[e]) : null)
                }),
                s([0, 1],
                function(t) {
                    var i = h[t],
                    n = c[t];
                    null != n || null == i ? (null == n && (n = u[t]), i = a.parse(o[Ge](n, u, e, !0))) : n = o[Ge](i, e, u, !0),
                    h[t] = i,
                    c[t] = n
                }),
                {
                    valueWindow: l(h),
                    percentWindow: l(c)
                }
            }
            function n(t, e, i) {
                return s(["min", "max"],
                function(n, r) {
                    var a = e.get(n, !0);
                    null != a && (a + "")[_r]() !== "data" + n && (t[r] = i.parse(a))
                }),
                e.get("scale", !0) || (t[0] > 0 && (t[0] = 0), t[1] < 0 && (t[1] = 0)),
                t
            }
            function r(t, e) {
                var i = t.getAxisModel(),
                n = t._percentWindow,
                r = t._valueWindow;
                if (n) {
                    var a = e || 0 === n[0] && 100 === n[1],
                    s = !e && o.getPixelPrecision(r, [0, 500]),
                    l = !(e || 20 > s && s >= 0),
                    u = e || a || l;
                    i.setRange && i.setRange(u ? null: +r[0][Ii](s), u ? null: +r[1][Ii](s))
                }
            }
            var a = t(Ar),
            o = t(qe),
            s = a.each,
            l = o.asc,
            u = function(t, e, i, n) {
                this._dimName = t,
                this._axisIndex = e,
                this._valueWindow,
                this._percentWindow,
                this._dataExtent,
                this[Te] = n,
                this._dataZoomModel = i
            };
            return u[xr] = {
                constructor: u,
                hostedBy: function(t) {
                    return this._dataZoomModel === t
                },
                getDataExtent: function() {
                    return this._dataExtent.slice()
                },
                getDataValueWindow: function() {
                    return this._valueWindow.slice()
                },
                getDataPercentWindow: function() {
                    return this._percentWindow.slice()
                },
                getTargetSeriesModels: function() {
                    var t = [],
                    e = this[Te];
                    return e[tr](function(i) {
                        var n = this._dimName,
                        r = e[Ee]({
                            mainType: n + "Axis",
                            index: i.get(n + "AxisIndex"),
                            id: i.get(n + "AxisId")
                        })[0];
                        this._axisIndex === (r && r[Oe]) && t.push(i)
                    },
                    this),
                    t
                },
                getAxisModel: function() {
                    return this[Te][Re](this._dimName + "Axis", this._axisIndex)
                },
                getOtherAxisModel: function() {
                    var t, e, i = this._dimName,
                    n = this[Te],
                    r = this.getAxisModel(),
                    a = "x" === i || "y" === i;
                    a ? (e = "gridIndex", t = "x" === i ? "y": "x") : (e = D, t = "angle" === i ? Ze: "angle");
                    var o;
                    return n[or](t + "Axis",
                    function(t) { (t.get(e) || 0) === (r.get(e) || 0) && (o = t)
                    }),
                    o
                },
                reset: function(t) {
                    if (t === this._dataZoomModel) {
                        var n = this._dataExtent = e(this._dimName, this.getTargetSeriesModels()),
                        a = i(t[zi], n, this);
                        this._valueWindow = a.valueWindow,
                        this._percentWindow = a.percentWindow,
                        r(this)
                    }
                },
                restore: function(t) {
                    t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, r(this, !0))
                },
                filterData: function(t) {
                    function e(t) {
                        return t >= a[0] && t <= a[1]
                    }
                    if (t === this._dataZoomModel) {
                        var i = this._dimName,
                        n = this.getTargetSeriesModels(),
                        r = t.get("filterMode"),
                        a = this._valueWindow,
                        o = this.getOtherAxisModel();
                        t.get("$fromToolbox") && o && o.get("type") === te && (r = "empty"),
                        s(n,
                        function(t) {
                            var n = t[Kn]();
                            n && s(t[j](i),
                            function(i) {
                                "empty" === r ? t.setData(n.map(i,
                                function(t) {
                                    return e(t) ? t: 0 / 0
                                })) : n.filterSelf(i, e)
                            })
                        })
                    }
                }
            },
            u
        }),
        e("echarts/coord/Axis", [Tr, Xi, Ar],
        function(t) {
            function e(t, e) {
                var i = t[1] - t[0],
                n = e,
                r = i / n / 2;
                t[0] += r,
                t[1] -= r
            }
            var i = t(Xi),
            n = i[Ge],
            r = t(Ar),
            a = [0, 1],
            o = function(t, e, i) {
                this.dim = t,
                this.scale = e,
                this._extent = i || [0, 0],
                this[Q] = !1,
                this[Y] = !1
            };
            return o[xr] = {
                constructor: o,
                contain: function(t) {
                    var e = this._extent,
                    i = Math.min(e[0], e[1]),
                    n = Math.max(e[0], e[1]);
                    return t >= i && n >= t
                },
                containData: function(t) {
                    return this[ji](this[B](t))
                },
                getExtent: function() {
                    var t = this._extent.slice();
                    return t
                },
                getPixelPrecision: function(t) {
                    return i.getPixelPrecision(t || this.scale[Fi](), this._extent)
                },
                setExtent: function(t, e) {
                    var i = this._extent;
                    i[0] = t,
                    i[1] = e
                },
                dataToCoord: function(t, i) {
                    var r = this._extent,
                    o = this.scale;
                    return t = o[Ui](t),
                    this[Y] && o.type === Pe && (r = r.slice(), e(r, o.count())),
                    n(t, a, r, i)
                },
                coordToData: function(t, i) {
                    var r = this._extent,
                    o = this.scale;
                    this[Y] && o.type === Pe && (r = r.slice(), e(r, o.count()));
                    var s = n(t, r, a, i);
                    return this.scale.scale(s)
                },
                getTicksCoords: function(t) {
                    if (this[Y] && !t) {
                        for (var e = this.getBands(), i = [], n = 0; n < e[Wn]; n++) i.push(e[n][0]);
                        return e[n - 1] && i.push(e[n - 1][1]),
                        i
                    }
                    return r.map(this.scale[qi](), this[B], this)
                },
                getLabelsCoords: function() {
                    return r.map(this.scale[qi](), this[B], this)
                },
                getBands: function() {
                    for (var t = this[Fi](), e = [], i = this.scale.count(), n = t[0], r = t[1], a = r - n, o = 0; i > o; o++) e.push([a * o / i + n, a * (o + 1) / i + n]);
                    return e
                },
                getBandWidth: function() {
                    var t = this._extent,
                    e = this.scale[Fi](),
                    i = e[1] - e[0] + (this[Y] ? 1 : 0);
                    0 === i && (i = 1);
                    var n = Math.abs(t[1] - t[0]);
                    return Math.abs(n) / i
                }
            },
            o
        }),
        e("zrender/core/guid", [],
        function() {
            var t = 2311;
            return function() {
                return t++
            }
        }),
        e("echarts/component/dataZoom/helper", [Tr, G, Ar],
        function(t) {
            var e = t(G),
            i = t(Ar),
            n = {},
            r = ["x", "y", "z", Ze, "angle"];
            return n.createNameEach = function(t, n) {
                t = t.slice();
                var r = i.map(t, e.capitalFirst);
                n = (n || []).slice();
                var a = i.map(n, e.capitalFirst);
                return function(e, o) {
                    i.each(t,
                    function(t, i) {
                        for (var s = {
                            name: t,
                            capital: r[i]
                        },
                        l = 0; l < n[Wn]; l++) s[n[l]] = t + a[l];
                        e.call(o, s)
                    })
                }
            },
            n.eachAxisDim = n.createNameEach(r, ["axisIndex", "axis", "index", "id"]),
            n.createLinkedNodesFinder = function(t, e, n) {
                function r(t, e) {
                    return i[gn](e.nodes, t) >= 0
                }
                function a(t, r) {
                    var a = !1;
                    return e(function(e) {
                        i.each(n(t, e) || [],
                        function(t) {
                            r.records[e.name][t] && (a = !0)
                        })
                    }),
                    a
                }
                function o(t, r) {
                    r.nodes.push(t),
                    e(function(e) {
                        i.each(n(t, e) || [],
                        function(t) {
                            r.records[e.name][t] = !0
                        })
                    })
                }
                return function(i) {
                    function n(t) { ! r(t, s) && a(t, s) && (o(t, s), l = !0)
                    }
                    var s = {
                        nodes: [],
                        records: {}
                    };
                    if (e(function(t) {
                        s.records[t.name] = {}
                    }), !i) return s;
                    o(i, s);
                    var l;
                    do l = !1,
                    t(n);
                    while (l);
                    return s
                }
            },
            n
        }),
        e("zrender/mixin/Transformable", [Tr, "../core/matrix", "../core/vector"],
        function(t) {
            function e(t) {
                return t > s || -s > t
            }
            var n = t("../core/matrix"),
            r = t("../core/vector"),
            a = n.identity,
            s = 5e-5,
            l = function(t) {
                t = t || {},
                t[$i] || (this[$i] = [0, 0]),
                null == t[ni] && (this[ni] = 0),
                t.scale || (this.scale = [1, 1]),
                this.origin = this.origin || null
            },
            u = l[xr];
            u[k] = null,
            u.needLocalTransform = function() {
                return e(this[ni]) || e(this[$i][0]) || e(this[$i][1]) || e(this.scale[0] - 1) || e(this.scale[1] - 1)
            },
            u[i] = function() {
                var t = this[pe],
                e = t && t[k],
                i = this.needLocalTransform(),
                r = this[k];
                return i || e ? (r = r || n[ir](), i ? this[ve](r) : a(r), e && (i ? n.mul(r, t[k], r) : n.copy(r, t[k])), this[k] = r, this.invTransform = this.invTransform || n[ir](), void n.invert(this.invTransform, r)) : void(r && a(r))
            },
            u[ve] = function(t) {
                t = t || [],
                a(t);
                var e = this.origin,
                i = this.scale,
                r = this[ni],
                s = this[$i];
                return e && (t[4] -= e[0], t[5] -= e[1]),
                n.scale(t, t, i),
                r && n[o](t, t, r),
                e && (t[4] += e[0], t[5] += e[1]),
                t[4] += s[0],
                t[5] += s[1],
                t
            },
            u.setTransform = function(t) {
                var e = this[k],
                i = t.dpr || 1;
                e ? t.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : t.setTransform(i, 0, 0, i, 0, 0)
            },
            u.restoreTransform = function(t) {
                var e = (this[k], t.dpr || 1);
                t.setTransform(e, 0, 0, e, 0, 0)
            };
            var c = [];
            return u.decomposeTransform = function() {
                if (this[k]) {
                    var t = this[pe],
                    i = this[k];
                    t && t[k] && (n.mul(c, t.invTransform, i), i = c);
                    var r = i[0] * i[0] + i[1] * i[1],
                    a = i[2] * i[2] + i[3] * i[3],
                    o = this[$i],
                    s = this.scale;
                    e(r - 1) && (r = Math.sqrt(r)),
                    e(a - 1) && (a = Math.sqrt(a)),
                    i[0] < 0 && (r = -r),
                    i[3] < 0 && (a = -a),
                    o[0] = i[4],
                    o[1] = i[5],
                    s[0] = r,
                    s[1] = a,
                    this[ni] = Math.atan2( - i[1] / a, i[0] / r)
                }
            },
            u.getGlobalScale = function() {
                var t = this[k];
                if (!t) return [1, 1];
                var e = Math.sqrt(t[0] * t[0] + t[1] * t[1]),
                i = Math.sqrt(t[2] * t[2] + t[3] * t[3]);
                return t[0] < 0 && (e = -e),
                t[3] < 0 && (i = -i),
                [e, i]
            },
            u.transformCoordToLocal = function(t, e) {
                var i = [t, e],
                n = this.invTransform;
                return n && r[_e](i, i, n),
                i
            },
            u.transformCoordToGlobal = function(t, e) {
                var i = [t, e],
                n = this[k];
                return n && r[_e](i, i, n),
                i
            },
            l
        }),
        e("zrender/mixin/Animatable", [Tr, "../animation/Animator", r, "../core/log"],
        function(t) {
            var e = t("../animation/Animator"),
            i = t(r),
            n = i[pn],
            a = i.isFunction,
            o = i[Yn],
            s = t("../core/log"),
            l = function() {
                this.animators = []
            };
            return l[xr] = {
                constructor: l,
                animate: function(t, n) {
                    var r, a = !1,
                    o = this,
                    l = this.__zr;
                    if (t) {
                        var u = t.split("."),
                        c = o;
                        a = "shape" === u[0];
                        for (var h = 0,
                        d = u[Wn]; d > h; h++) c && (c = c[u[h]]);
                        c && (r = c)
                    } else r = o;
                    if (!r) return void s('Property "' + t + '" is not existed in element ' + o.id);
                    var f = o.animators,
                    p = new e(r, n);
                    return p.during(function() {
                        o.dirty(a)
                    }).done(function() {
                        f[Gn](i[gn](f, p), 1)
                    }),
                    f.push(p),
                    l && l[vr].addAnimator(p),
                    p
                },
                stopAnimation: function(t) {
                    for (var e = this.animators,
                    i = e[Wn], n = 0; i > n; n++) e[n].stop(t);
                    return e[Wn] = 0,
                    this
                },
                animateTo: function(t, e, i, r, o) {
                    function s() {
                        u--,
                        u || o && o()
                    }
                    n(i) ? (o = r, r = i, i = 0) : a(r) ? (o = r, r = b, i = 0) : a(i) ? (o = i, i = 0) : a(e) ? (o = e, e = 500) : e || (e = 500),
                    this[sr](),
                    this._animateToShallow("", this, t, e, i, r, o);
                    var l = this.animators.slice(),
                    u = l[Wn];
                    u || o && o();
                    for (var c = 0; c < l[Wn]; c++) l[c].done(s).start(r)
                },
                _animateToShallow: function(t, e, n, r, a) {
                    var s = {},
                    l = 0;
                    for (var u in n) if (null != e[u]) o(n[u]) && !i.isArrayLike(n[u]) ? this._animateToShallow(t ? t + "." + u: u, e[u], n[u], r, a) : (s[u] = n[u], l++);
                    else if (null != n[u]) if (t) {
                        var c = {};
                        c[t] = {},
                        c[t][u] = n[u],
                        this.attr(c)
                    } else this.attr(u, n[u]);
                    return l > 0 && this[wi](t, !1).when(null == r ? 500 : r, s).delay(a || 0),
                    this
                }
            },
            l
        }),
        e("echarts/coord/cartesian/axisLabelInterval", [Tr, Ar, "../axisHelper"],
        function(t) {
            var e = t(Ar),
            i = t("../axisHelper");
            return function(t) {
                var n = t.model,
                r = n[fr](g),
                a = r.get(R);
                return t.type !== te || "auto" !== a ? "auto" === a ? 0 : a: i.getAxisLabelInterval(e.map(t.scale[qi](), t[B], t), n[ee](), r[fr](on)[rn](), t[K]())
            }
        }),
        e("echarts/chart/heatmap/HeatmapLayer", [Tr, Ar],
        function(t) {
            function e() {
                var t = n.createCanvas();
                this[mr] = t,
                this.blurSize = 30,
                this.pointSize = 20,
                this.maxOpacity = 1,
                this.minOpacity = 0,
                this._gradientPixels = {}
            }
            var i = 256,
            n = t(Ar);
            return e[xr] = {
                update: function(t, e, n, r, a, o) {
                    var s = this._getBrush(),
                    l = this._getGradient(t, a, "inRange"),
                    u = this._getGradient(t, a, "outOfRange"),
                    c = this.pointSize + this.blurSize,
                    h = this[mr],
                    d = h.getContext("2d"),
                    f = t[Wn];
                    h.width = e,
                    h[nr] = n;
                    for (var p = 0; f > p; ++p) {
                        var v = t[p],
                        g = v[0],
                        m = v[1],
                        y = v[2],
                        x = r(y);
                        d.globalAlpha = x,
                        d.drawImage(s, g - c, m - c)
                    }
                    for (var _ = d.getImageData(0, 0, h.width, h[nr]), w = _.data, b = 0, M = w[Wn], S = this.minOpacity, A = this.maxOpacity, T = A - S; M > b;) {
                        var x = w[b + 3] / 256,
                        C = 4 * Math.floor(x * (i - 1));
                        if (x > 0) {
                            var L = o(x) ? l: u;
                            x > 0 && (x = x * T + S),
                            w[b++] = L[C],
                            w[b++] = L[C + 1],
                            w[b++] = L[C + 2],
                            w[b++] = L[C + 3] * x * 256
                        } else b += 4
                    }
                    return d.putImageData(_, 0, 0),
                    h
                },
                _getBrush: function() {
                    var t = this._brushCanvas || (this._brushCanvas = n.createCanvas()),
                    e = this.pointSize + this.blurSize,
                    i = 2 * e;
                    t.width = i,
                    t[nr] = i;
                    var r = t.getContext("2d");
                    return r.clearRect(0, 0, i, i),
                    r.shadowOffsetX = i,
                    r.shadowBlur = this.blurSize,
                    r.shadowColor = "#000",
                    r.beginPath(),
                    r.arc( - e, e, this.pointSize, 0, 2 * Math.PI, !0),
                    r[h](),
                    r.fill(),
                    t
                },
                _getGradient: function(t, e, i) {
                    for (var n = this._gradientPixels,
                    r = n[i] || (n[i] = new Uint8ClampedArray(1024)), a = [], o = 0, s = 0; 256 > s; s++) e[i](s / 255, !0, a),
                    r[o++] = a[0],
                    r[o++] = a[1],
                    r[o++] = a[2],
                    r[o++] = a[3];
                    return r
                }
            },
            e
        }),
        e("echarts/coord/geo/parseGeoJson", [Tr, Ar, "./Region"],
        function(t) {
            function e(t) {
                if (!t.UTF8Encoding) return t;
                for (var e = t.features,
                n = 0; n < e[Wn]; n++) for (var r = e[n], a = r.geometry, o = a.coordinates, s = a.encodeOffsets, l = 0; l < o[Wn]; l++) {
                    var u = o[l];
                    if (a.type === we) o[l] = i(u, s[l]);
                    else if ("MultiPolygon" === a.type) for (var c = 0; c < u[Wn]; c++) {
                        var h = u[c];
                        u[c] = i(h, s[l][c])
                    }
                }
                return t.UTF8Encoding = !1,
                t
            }
            function i(t, e) {
                for (var i = [], n = e[0], r = e[1], a = 0; a < t[Wn]; a += 2) {
                    var o = t.charCodeAt(a) - 64,
                    s = t.charCodeAt(a + 1) - 64;
                    o = o >> 1 ^ -(1 & o),
                    s = s >> 1 ^ -(1 & s),
                    o += n,
                    s += r,
                    n = o,
                    r = s,
                    i.push([o / 1024, s / 1024])
                }
                return i
            }
            function n(t) {
                for (var e = [], i = 0; i < t[Wn]; i++) for (var n = 0; n < t[i][Wn]; n++) e.push(t[i][n]);
                return e
            }
            var r = t(Ar),
            a = t("./Region");
            return function(t) {
                return e(t),
                r.map(r[mn](t.features,
                function(t) {
                    return t.geometry && t.properties
                }),
                function(t) {
                    var e = t.properties,
                    i = t.geometry,
                    r = i.coordinates;
                    return "MultiPolygon" === i.type && (r = n(r)),
                    new a(e.name, r, e.cp)
                })
            }
        }),
        e("echarts/coord/geo/fix/nanhai", [Tr, "../Region"],
        function(t) {
            for (var e = t("../Region"), i = [126, 25], n = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, .7], [52, .7], [56, 7.7], [59, .7], [64, .7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]], r = 0; r < n[Wn]; r++) for (var a = 0; a < n[r][Wn]; a++) n[r][a][0] /= 10.5,
            n[r][a][1] /= -14,
            n[r][a][0] += i[0],
            n[r][a][1] += i[1];
            return function(t) {
                "china" === t.map && t.regions.push(new e("南海诸岛", n, i))
            }
        }),
        e("echarts/coord/geo/fix/geoCoord", [Tr, Ar],
        function(t) {
            var e = t(Ar),
            i = {
                Russia: [100, 60],
                "United States of America": [ - 99, 38]
            };
            return function(t) {
                e.each(t.regions,
                function(t) {
                    var e = i[t.name];
                    if (e) {
                        var n = t[Ji];
                        n[0] = e[0],
                        n[1] = e[1]
                    }
                })
            }
        }),
        e("echarts/coord/View", [Tr, wr, br, "zrender/mixin/Transformable", Ar, Me],
        function(t) {
            function e() {
                o.call(this)
            }
            function n(t) {
                this.name = t,
                this.zoomLimit,
                o.call(this),
                this._roamTransform = new e,
                this._viewTransform = new e,
                this._center,
                this._zoom
            }
            var r = t(wr),
            a = t(br),
            o = t("zrender/mixin/Transformable"),
            s = t(Ar),
            l = t(Me),
            u = r[_e];
            return s.mixin(e, o),
            n[xr] = {
                constructor: n,
                type: "view",
                dimensions: ["x", "y"],
                setBoundingRect: function(t, e, i, n) {
                    return this._rect = new l(t, e, i, n),
                    this._rect
                },
                getBoundingRect: function() {
                    return this._rect
                },
                setViewRect: function(t, e, i, n) {
                    i = i,
                    n = n,
                    this.transformTo(t, e, i, n),
                    this._viewRect = new l(t, e, i, n)
                },
                transformTo: function(t, e, i, n) {
                    var r = this[en](),
                    a = this._viewTransform;
                    a[k] = r.calculateTransform(new l(t, e, i, n)),
                    a.decomposeTransform(),
                    this._updateTransform()
                },
                setCenter: function(t) {
                    t && (this._center = t, this._updateCenterAndZoom())
                },
                setZoom: function(t) {
                    t = t || 1;
                    var e = this.zoomLimit;
                    e && (null != e.max && (t = Math.min(e.max, t)), null != e.min && (t = Math.max(e.min, t))),
                    this._zoom = t,
                    this._updateCenterAndZoom()
                },
                getDefaultCenter: function() {
                    var t = this[en](),
                    e = t.x + t.width / 2,
                    i = t.y + t[nr] / 2;
                    return [e, i]
                },
                getCenter: function() {
                    return this._center || this.getDefaultCenter()
                },
                getZoom: function() {
                    return this._zoom || 1
                },
                getRoamTransform: function() {
                    return this._roamTransform
                },
                _updateCenterAndZoom: function() {
                    var t = this._viewTransform[ve](),
                    e = this._roamTransform,
                    i = this.getDefaultCenter(),
                    n = this.getCenter(),
                    a = this.getZoom();
                    n = r[_e]([], n, t),
                    i = r[_e]([], i, t),
                    e.origin = n,
                    e[$i] = [i[0] - n[0], i[1] - n[1]],
                    e.scale = [a, a],
                    this._updateTransform()
                },
                _updateTransform: function() {
                    var t = this._roamTransform,
                    e = this._viewTransform;
                    e[pe] = t,
                    t[i](),
                    e[i](),
                    e[k] && a.copy(this[k] || (this[k] = []), e[k]),
                    this[k] ? (this.invTransform = this.invTransform || [], a.invert(this.invTransform, this[k])) : this.invTransform = null,
                    this.decomposeTransform()
                },
                getViewRect: function() {
                    return this._viewRect
                },
                getViewRectAfterRoam: function() {
                    var t = this[en]().clone();
                    return t[_e](this[k]),
                    t
                },
                dataToPoint: function(t) {
                    var e = this[k];
                    return e ? u([], t, e) : [t[0], t[1]]
                },
                pointToData: function(t) {
                    var e = this.invTransform;
                    return e ? u([], t, e) : [t[0], t[1]]
                }
            },
            s.mixin(n, o),
            n
        }),
        e("echarts/coord/geo/fix/textCoord", [Tr, Ar],
        function(t) {
            var e = t(Ar),
            i = {
                "南海诸岛": [32, 80],
                "广东": [0, -10],
                "香港": [10, 5],
                "澳门": [ - 10, 10],
                "天津": [5, 5]
            };
            return function(t) {
                e.each(t.regions,
                function(t) {
                    var e = i[t.name];
                    if (e) {
                        var n = t[Ji];
                        n[0] += e[0] / 10.5,
                        n[1] += -e[1] / 14
                    }
                })
            }
        }),
        e("echarts/coord/cartesian/AxisModel", [Tr, c, Ar, "../axisModelCreator", "../axisModelCommonMixin"],
        function(t) {
            function e(t, e) {
                return e.type || (e.data ? te: "value")
            }
            var i = t(c),
            n = t(Ar),
            r = t("../axisModelCreator"),
            a = i[jn]({
                type: "cartesian2dAxis",
                axis: null,
                init: function() {
                    a[Oi](this, "init", arguments),
                    this._resetRange()
                },
                mergeOption: function() {
                    a[Oi](this, Vi, arguments),
                    this._resetRange()
                },
                restoreData: function() {
                    a[Oi](this, "restoreData", arguments),
                    this._resetRange()
                },
                setRange: function(t, e) {
                    this[zi].rangeStart = t,
                    this[zi].rangeEnd = e
                },
                getMin: function() {
                    var t = this[zi];
                    return null != t.rangeStart ? t.rangeStart: t.min
                },
                getMax: function() {
                    var t = this[zi];
                    return null != t.rangeEnd ? t.rangeEnd: t.max
                },
                getNeedCrossZero: function() {
                    var t = this[zi];
                    return null != t.rangeStart || null != t.rangeEnd ? !1 : !t.scale
                },
                findGridModel: function() {
                    return this[Te][Ee]({
                        mainType: "grid",
                        index: this.get("gridIndex"),
                        id: this.get("gridId")
                    })[0]
                },
                _resetRange: function() {
                    this[zi].rangeStart = this[zi].rangeEnd = null
                }
            });
            n.merge(a[xr], t("../axisModelCommonMixin"));
            var o = {
                offset: 0
            };
            return r("x", a, e, o),
            r("y", a, e, o),
            a
        }),
        e("zrender/core/log", [Tr, "../config"],
        function(t) {
            var e = t("../config");
            return function() {
                if (0 !== e.debugMode) if (1 == e.debugMode) for (var t in arguments) throw new Error(arguments[t]);
                else if (e.debugMode > 1) for (var t in arguments) console.log(arguments[t])
            }
        }),
        e("echarts/coord/polar/AxisModel", [Tr, Ar, c, "../axisModelCreator", "../axisModelCommonMixin"],
        function(t) {
            function e(t, e) {
                return e.type || (e.data ? te: "value")
            }
            var i = t(Ar),
            n = t(c),
            r = t("../axisModelCreator"),
            a = n[jn]({
                type: "polarAxis",
                axis: null
            });
            i.merge(a[xr], t("../axisModelCommonMixin"));
            var o = {
                angle: {
                    startAngle: 90,
                    clockwise: !0,
                    splitNumber: 12,
                    axisLabel: {
                        rotate: !1
                    }
                },
                radius: {
                    splitNumber: 5
                }
            };
            r("angle", a, e, o.angle),
            r(Ze, a, e, o[Ze])
        }),
        e("zrender/animation/Animator", [Tr, "./Clip", "../tool/color", r],
        function(t) {
            function e(t, e) {
                return t[e]
            }
            function i(t, e, i) {
                t[e] = i
            }
            function n(t, e, i) {
                return (e - t) * i + t
            }
            function a(t, e, i) {
                return i > .5 ? e: t
            }
            function o(t, e, i, r, a) {
                var o = t[Wn];
                if (1 == a) for (var s = 0; o > s; s++) r[s] = n(t[s], e[s], i);
                else for (var l = t[0][Wn], s = 0; o > s; s++) for (var u = 0; l > u; u++) r[s][u] = n(t[s][u], e[s][u], i)
            }
            function s(t, e, i) {
                var n = t[Wn],
                r = e[Wn];
                if (n !== r) {
                    var a = n > r;
                    if (a) t[Wn] = r;
                    else for (var o = n; r > o; o++) t.push(1 === i ? e[o] : y.call(e[o]))
                }
                for (var s = t[0] && t[0][Wn], o = 0; o < t[Wn]; o++) if (1 === i) isNaN(t[o]) && (t[o] = e[o]);
                else for (var l = 0; s > l; l++) isNaN(t[o][l]) && (t[o][l] = e[o][l])
            }
            function l(t, e, i) {
                if (t === e) return ! 0;
                var n = t[Wn];
                if (n !== e[Wn]) return ! 1;
                if (1 === i) {
                    for (var r = 0; n > r; r++) if (t[r] !== e[r]) return ! 1
                } else for (var a = t[0][Wn], r = 0; n > r; r++) for (var o = 0; a > o; o++) if (t[r][o] !== e[r][o]) return ! 1;
                return ! 0
            }
            function u(t, e, i, n, r, a, o, s, l) {
                var u = t[Wn];
                if (1 == l) for (var h = 0; u > h; h++) s[h] = c(t[h], e[h], i[h], n[h], r, a, o);
                else for (var d = t[0][Wn], h = 0; u > h; h++) for (var f = 0; d > f; f++) s[h][f] = c(t[h][f], e[h][f], i[h][f], n[h][f], r, a, o)
            }
            function c(t, e, i, n, r, a, o) {
                var s = .5 * (i - t),
                l = .5 * (n - e);
                return (2 * (e - i) + s + l) * o + ( - 3 * (e - i) - 2 * s - l) * a + s * r + e
            }
            function h(t) {
                if (m(t)) {
                    var e = t[Wn];
                    if (m(t[0])) {
                        for (var i = [], n = 0; e > n; n++) i.push(y.call(t[n]));
                        return i
                    }
                    return y.call(t)
                }
                return t
            }
            function d(t) {
                return t[0] = Math.floor(t[0]),
                t[1] = Math.floor(t[1]),
                t[2] = Math.floor(t[2]),
                "rgba(" + t.join(",") + ")"
            }
            function f(t, e, i, r, h) {
                var f = t._getter,
                g = t._setter,
                y = "spline" === e,
                x = r[Wn];
                if (x) {
                    var _, w = r[0].value,
                    b = m(w),
                    M = !1,
                    S = !1,
                    A = b && m(w[0]) ? 2 : 1;
                    r.sort(function(t, e) {
                        return t.time - e.time
                    }),
                    _ = r[x - 1].time;
                    for (var T = [], C = [], L = r[0].value, k = !0, P = 0; x > P; P++) {
                        T.push(r[P].time / _);
                        var I = r[P].value;
                        if (b && l(I, L, A) || !b && I === L || (k = !1), L = I, typeof I == yr) {
                            var D = v.parse(I);
                            D ? (I = D, M = !0) : S = !0
                        }
                        C.push(I)
                    }
                    if (!k) {
                        for (var z = C[x - 1], P = 0; x - 1 > P; P++) b ? s(C[P], z, A) : !isNaN(C[P]) || isNaN(z) || S || M || (C[P] = z);
                        b && s(f(t._target, h), z, A);
                        var V, R, O, E, N, B, G = 0,
                        H = 0;
                        if (M) var F = [0, 0, 0, 0];
                        var Z = function(t, e) {
                            var i;
                            if (0 > e) i = 0;
                            else if (H > e) {
                                for (V = Math.min(G + 1, x - 1), i = V; i >= 0 && !(T[i] <= e); i--);
                                i = Math.min(i, x - 2)
                            } else {
                                for (i = G; x > i && !(T[i] > e); i++);
                                i = Math.min(i - 1, x - 2)
                            }
                            G = i,
                            H = e;
                            var r = T[i + 1] - T[i];
                            if (0 !== r) if (R = (e - T[i]) / r, y) if (E = C[i], O = C[0 === i ? i: i - 1], N = C[i > x - 2 ? x - 1 : i + 1], B = C[i > x - 3 ? x - 1 : i + 2], b) u(O, E, N, B, R, R * R, R * R * R, f(t, h), A);
                            else {
                                var s;
                                if (M) s = u(O, E, N, B, R, R * R, R * R * R, F, 1),
                                s = d(F);
                                else {
                                    if (S) return a(E, N, R);
                                    s = c(O, E, N, B, R, R * R, R * R * R)
                                }
                                g(t, h, s)
                            } else if (b) o(C[i], C[i + 1], R, f(t, h), A);
                            else {
                                var s;
                                if (M) o(C[i], C[i + 1], R, F, 1),
                                s = d(F);
                                else {
                                    if (S) return a(C[i], C[i + 1], R);
                                    s = n(C[i], C[i + 1], R)
                                }
                                g(t, h, s)
                            }
                        },
                        W = new p({
                            target: t._target,
                            life: _,
                            loop: t._loop,
                            delay: t._delay,
                            onframe: Z,
                            ondestroy: i
                        });
                        return e && "spline" !== e && (W.easing = e),
                        W
                    }
                }
            }
            var p = t("./Clip"),
            v = t("../tool/color"),
            g = t(r),
            m = g.isArrayLike,
            y = Array[xr].slice,
            x = function(t, n, r, a) {
                this._tracks = {},
                this._target = t,
                this._loop = n || !1,
                this._getter = r || e,
                this._setter = a || i,
                this._clipCount = 0,
                this._delay = 0,
                this._doneList = [],
                this._onframeList = [],
                this._clipList = []
            };
            return x[xr] = {
                when: function(t, e) {
                    var i = this._tracks;
                    for (var n in e) {
                        if (!i[n]) {
                            i[n] = [];
                            var r = this._getter(this._target, n);
                            if (null == r) continue;
                            0 !== t && i[n].push({
                                time: 0,
                                value: h(r)
                            })
                        }
                        i[n].push({
                            time: t,
                            value: e[n]
                        })
                    }
                    return this
                },
                during: function(t) {
                    return this._onframeList.push(t),
                    this
                },
                _doneCallback: function() {
                    this._tracks = {},
                    this._clipList[Wn] = 0;
                    for (var t = this._doneList,
                    e = t[Wn], i = 0; e > i; i++) t[i].call(this)
                },
                start: function(t) {
                    var e, i = this,
                    n = 0,
                    r = function() {
                        n--,
                        n || i._doneCallback()
                    };
                    for (var a in this._tracks) {
                        var o = f(this, t, r, this._tracks[a], a);
                        o && (this._clipList.push(o), n++, this[vr] && this[vr].addClip(o), e = o)
                    }
                    if (e) {
                        var s = e.onframe;
                        e.onframe = function(t, e) {
                            s(t, e);
                            for (var n = 0; n < i._onframeList[Wn]; n++) i._onframeList[n](t, e)
                        }
                    }
                    return n || this._doneCallback(),
                    this
                },
                stop: function(t) {
                    for (var e = this._clipList,
                    i = this[vr], n = 0; n < e[Wn]; n++) {
                        var r = e[n];
                        t && r.onframe(this._target, 1),
                        i && i.removeClip(r)
                    }
                    e[Wn] = 0
                },
                delay: function(t) {
                    return this._delay = t,
                    this
                },
                done: function(t) {
                    return t && this._doneList.push(t),
                    this
                },
                getClips: function() {
                    return this._clipList
                }
            },
            x
        }),
        e("echarts/component/axis/AxisBuilder", [Tr, Ar, G, Si, W, qe, wr],
        function(t) {
            function e(t) {
                var e = {
                    componentType: t[Ne]
                };
                return e[t[Ne] + "Index"] = t[Oe],
                e
            }
            function n(t, e, i) {
                var n, r, a = f(e - t[ni]);
                return p(a) ? (r = i > 0 ? "top": rr, n = Ji) : p(a - _) ? (r = i > 0 ? rr: "top", n = Ji) : (r = Qi, n = a > 0 && _ > a ? i > 0 ? "right": "left": i > 0 ? "left": "right"),
                {
                    rotation: a,
                    textAlign: n,
                    verticalAlign: r
                }
            }
            function r(t, e, i, n) {
                var r, a, o = f(i - t[ni]),
                s = n[0] > n[1],
                l = "start" === e && !s || "start" !== e && s;
                return p(o - _ / 2) ? (a = l ? rr: "top", r = Ji) : p(o - 1.5 * _) ? (a = l ? "top": rr, r = Ji) : (a = Qi, r = 1.5 * _ > o && o > _ / 2 ? l ? "left": "right": l ? "right": "left"),
                {
                    rotation: o,
                    textAlign: r,
                    verticalAlign: a
                }
            }
            function a(t) {
                var e = t.get("tooltip");
                return t.get(Nn) || !(t.get("triggerEvent") || e && e.show)
            }
            var s = t(Ar),
            l = t(G),
            c = t(Si),
            h = t(W),
            d = t(qe),
            f = d.remRadian,
            p = d.isRadianAroundZero,
            v = t(wr),
            y = v[_e],
            x = s[vi],
            _ = Math.PI,
            w = function(t, e) {
                this.opt = e,
                this.axisModel = t,
                s[qn](e, {
                    labelOffset: 0,
                    nameDirection: 1,
                    tickDirection: 1,
                    labelDirection: 1,
                    silent: !0
                }),
                this.group = new c.Group;
                var n = new c.Group({
                    position: e[$i].slice(),
                    rotation: e[ni]
                });
                n[i](),
                this._transform = n[k],
                this._dumbGroup = n
            };
            w[xr] = {
                constructor: w,
                hasBuilder: function(t) {
                    return !! b[t]
                },
                add: function(t) {
                    b[t].call(this)
                },
                getGroup: function() {
                    return this.group
                }
            };
            var b = {
                axisLine: function() {
                    var t = this.opt,
                    e = this.axisModel;
                    if (e.get("axisLine.show")) {
                        var i = this.axisModel.axis[Fi](),
                        n = this._transform,
                        r = [i[0], 0],
                        a = [i[1], 0];
                        n && (y(r, r, n), y(a, a, n)),
                        this.group.add(new c.Line(c.subPixelOptimizeLine({
                            anid: "line",
                            shape: {
                                x1: r[0],
                                y1: r[1],
                                x2: a[0],
                                y2: a[1]
                            },
                            style: s[jn]({
                                lineCap: "round"
                            },
                            e[fr]("axisLine.lineStyle")[ti]()),
                            strokeContainThreshold: t.strokeContainThreshold || 5,
                            silent: !0,
                            z2: 1
                        })))
                    }
                },
                axisTick: function() {
                    var t = this.axisModel;
                    if (t.get("axisTick.show")) for (var e = t.axis,
                    i = t[fr](m), n = this.opt, r = i[fr](Ke), a = i.get(Wn), o = S(i, n.labelInterval), l = e.getTicksCoords(i.get("alignWithLabel")), u = e.scale[qi](), h = [], d = [], f = this._transform, p = 0; p < l[Wn]; p++) if (!M(e, p, o)) {
                        var v = l[p];
                        h[0] = v,
                        h[1] = 0,
                        d[0] = v,
                        d[1] = n.tickDirection * a,
                        f && (y(h, h, f), y(d, d, f)),
                        this.group.add(new c.Line(c.subPixelOptimizeLine({
                            anid: "tick_" + u[p],
                            shape: {
                                x1: h[0],
                                y1: h[1],
                                x2: d[0],
                                y2: d[1]
                            },
                            style: s[qn](r[ti](), {
                                stroke: t.get("axisLine.lineStyle.color")
                            }),
                            z2: 2,
                            silent: !0
                        })))
                    }
                },
                axisLabel: function() {
                    function t(t, e) {
                        var i = t && t[en]().clone(),
                        n = e && e[en]().clone();
                        return i && n ? (i[_e](t[ve]()), n[_e](e[ve]()), i.intersect(n)) : void 0
                    }
                    var r = this.opt,
                    s = this.axisModel,
                    l = x(r.axisLabelShow, s.get("axisLabel.show"));
                    if (l) {
                        var u = s.axis,
                        d = s[fr](g),
                        f = d[fr](on),
                        p = d.get("margin"),
                        v = u.scale[qi](),
                        m = s[ee](),
                        y = x(r.labelRotation, d.get(o)) || 0;
                        y = y * _ / 180;
                        for (var w = n(r, y, r.labelDirection), b = s.get("data"), S = [], A = a(s), T = s.get("triggerEvent"), C = 0; C < v[Wn]; C++) if (!M(u, C, r.labelInterval)) {
                            var L = f;
                            b && b[C] && b[C][on] && (L = new h(b[C][on], f, s[Te]));
                            var k = L[nn]() || s.get("axisLine.lineStyle.color"),
                            P = u[B](v[C]),
                            I = [P, r.labelOffset + r.labelDirection * p],
                            D = u.scale[Wi](v[C]),
                            z = new c.Text({
                                anid: "label_" + v[C],
                                style: {
                                    text: m[C],
                                    textAlign: L.get("align", !0) || w[an],
                                    textVerticalAlign: L.get("baseline", !0) || w.verticalAlign,
                                    textFont: L[rn](),
                                    fill: typeof k === Sn ? k(D) : k
                                },
                                position: I,
                                rotation: w[ni],
                                silent: A,
                                z2: 10
                            });
                            T && (z.eventData = e(s), z.eventData.targetType = g, z.eventData.value = D),
                            this._dumbGroup.add(z),
                            z[i](),
                            S.push(z),
                            this.group.add(z),
                            z.decomposeTransform()
                        }
                        if (u.type !== te) {
                            if (s.getMin ? s.getMin() : s.get("min")) {
                                var V = S[0],
                                R = S[1];
                                t(V, R) && (V[ar] = !0)
                            }
                            if (s.getMax ? s.getMax() : s.get("max")) {
                                var O = S[S[Wn] - 1],
                                E = S[S[Wn] - 2];
                                t(E, O) && (O[ar] = !0)
                            }
                        }
                    }
                },
                axisName: function() {
                    var t = this.opt,
                    o = this.axisModel,
                    h = x(t[u], o.get("name"));
                    if (h) {
                        var d, f = o.get("nameLocation"),
                        p = t.nameDirection,
                        v = o[fr]("nameTextStyle"),
                        g = o.get("nameGap") || 0,
                        m = this.axisModel.axis[Fi](),
                        y = m[0] > m[1] ? -1 : 1,
                        w = ["start" === f ? m[0] - y * g: "end" === f ? m[1] + y * g: (m[0] + m[1]) / 2, f === Qi ? t.labelOffset + p * g: 0],
                        b = o.get("nameRotate");
                        null != b && (b = b * _ / 180);
                        var M;
                        f === Qi ? d = n(t, null != b ? b: t[ni], p) : (d = r(t, f, b || 0, m), M = t.axisNameAvailableWidth, null != M && (M = Math.abs(M / Math.sin(d[ni])), !isFinite(M) && (M = null)));
                        var S = v[rn](),
                        A = o.get("nameTruncate", !0) || {},
                        T = A.ellipsis,
                        C = x(A.maxWidth, M),
                        L = null != T && null != C ? l.truncateText(h, C, S, T, {
                            minChar: 2,
                            placeholder: A.placeholder
                        }) : h,
                        k = o.get("tooltip", !0),
                        P = o[Ne],
                        I = {
                            componentType: P,
                            name: h,
                            $vars: ["name"]
                        };
                        I[P + "Index"] = o[Oe];
                        var D = new c.Text({
                            anid: "name",
                            __fullText: h,
                            __truncatedText: L,
                            style: {
                                text: L,
                                textFont: S,
                                fill: v[nn]() || o.get("axisLine.lineStyle.color"),
                                textAlign: d[an],
                                textVerticalAlign: d.verticalAlign
                            },
                            position: w,
                            rotation: d[ni],
                            silent: a(o),
                            z2: 1,
                            tooltip: k && k.show ? s[jn]({
                                content: h,
                                formatter: function() {
                                    return h
                                },
                                formatterParams: I
                            },
                            k) : null
                        });
                        o.get("triggerEvent") && (D.eventData = e(o), D.eventData.targetType = u, D.eventData.name = h),
                        this._dumbGroup.add(D),
                        D[i](),
                        this.group.add(D),
                        D.decomposeTransform()
                    }
                }
            },
            M = w.ifIgnoreOnTick = function(t, e, i) {
                var n, r = t.scale;
                return r.type === Pe && (typeof i === Sn ? (n = r[qi]()[e], !i(n, r[Wi](n))) : e % (i + 1))
            },
            S = w.getInterval = function(t, e) {
                var i = t.get(R);
                return (null == i || "auto" == i) && (i = e),
                i
            };
            return w
        }),
        e("echarts/coord/geo/Region", [Tr, "zrender/contain/polygon", Me, "zrender/core/bbox", wr],
        function(t) {
            function e(t, e, i) {
                if (this.name = t, this.contours = e, i) i = [i[0], i[1]];
                else {
                    var n = this[en]();
                    i = [n.x + n.width / 2, n.y + n[nr] / 2]
                }
                this[Ji] = i
            }
            var i = t("zrender/contain/polygon"),
            n = t(Me),
            r = t("zrender/core/bbox"),
            a = t(wr);
            return e[xr] = {
                constructor: e,
                getBoundingRect: function() {
                    var t = this._rect;
                    if (t) return t;
                    for (var e = Number.MAX_VALUE,
                    i = [e, e], o = [ - e, -e], s = [], l = [], u = this.contours, c = 0; c < u[Wn]; c++) r.fromPoints(u[c], s, l),
                    a.min(i, i, s),
                    a.max(o, o, l);
                    return 0 === c && (i[0] = i[1] = o[0] = o[1] = 0),
                    this._rect = new n(i[0], i[1], o[0] - i[0], o[1] - i[1])
                },
                contain: function(t) {
                    var e = this[en](),
                    n = this.contours;
                    if (e[ji](t[0], t[1])) for (var r = 0,
                    a = n[Wn]; a > r; r++) if (i[ji](n[r], t[0], t[1])) return ! 0;
                    return ! 1
                },
                transformTo: function(t, e, i, r) {
                    var o = this[en](),
                    s = o.width / o[nr];
                    i ? r || (r = i / s) : i = s * r;
                    for (var l = new n(t, e, i, r), u = o.calculateTransform(l), c = this.contours, h = 0; h < c[Wn]; h++) for (var d = 0; d < c[h][Wn]; d++) a[_e](c[h][d], c[h][d], u);
                    o = this._rect,
                    o.copy(l),
                    this[Ji] = [o.x + o.width / 2, o.y + o[nr] / 2]
                }
            },
            e
        }),
        e("echarts/coord/axisModelCreator", [Tr, "./axisDefault", Ar, "../model/Component", "../util/layout"],
        function(t) {
            var e = t("./axisDefault"),
            i = t(Ar),
            n = t("../model/Component"),
            r = t("../util/layout"),
            a = ["value", te, "time", "log"];
            return function(t, o, s, l) {
                i.each(a,
                function(n) {
                    o[jn]({
                        type: t + "Axis." + n,
                        mergeDefaultAndTheme: function(e, a) {
                            var o = this.layoutMode,
                            l = o ? r.getLayoutParams(e) : {},
                            u = a.getTheme();
                            i.merge(e, u.get(n + "Axis")),
                            i.merge(e, this.getDefaultOption()),
                            e.type = s(t, e),
                            o && r.mergeLayoutParam(e, l, o)
                        },
                        defaultOption: i.mergeAll([{},
                        e[n + "Axis"], l], !0)
                    })
                }),
                n.registerSubTypeDefaulter(t + "Axis", i.curry(s, t))
            }
        }),
        e("echarts/coord/axisModelCommonMixin", [Tr, Ar, "./axisHelper"],
        function(t) {
            function e(t) {
                return r[Yn](t) && null != t.value ? t.value: t
            }
            function i() {
                return this.get("type") === te && r.map(this.get("data"), e)
            }
            function n() {
                return a[ee](this.axis, this.get("axisLabel.formatter"))
            }
            var r = t(Ar),
            a = t("./axisHelper");
            return {
                getFormattedLabels: n,
                getCategories: i
            }
        }),
        e("zrender/animation/Clip", [Tr, "./easing"],
        function(t) {
            function e(t) {
                this._target = t[Vn],
                this._life = t.life || 1e3,
                this._delay = t.delay || 0,
                this._initialized = !1,
                this.loop = null == t.loop ? !1 : t.loop,
                this.gap = t.gap || 0,
                this.easing = t.easing || "Linear",
                this.onframe = t.onframe,
                this.ondestroy = t.ondestroy,
                this.onrestart = t.onrestart
            }
            var i = t("./easing");
            return e[xr] = {
                constructor: e,
                step: function(t) {
                    this._initialized || (this._startTime = t + this._delay, this._initialized = !0);
                    var e = (t - this._startTime) / this._life;
                    if (! (0 > e)) {
                        e = Math.min(e, 1);
                        var n = this.easing,
                        r = typeof n == yr ? i[n] : n,
                        a = typeof r === Sn ? r(e) : e;
                        return this.fire("frame", a),
                        1 == e ? this.loop ? (this.restart(t), "restart") : (this._needsRemove = !0, "destroy") : null
                    }
                },
                restart: function(t) {
                    var e = (t - this._startTime) % this._life;
                    this._startTime = t - e + this.gap,
                    this._needsRemove = !1
                },
                fire: function(t, e) {
                    t = "on" + t,
                    this[t] && this[t](this._target, e)
                }
            },
            e
        }),
        e("zrender/contain/polygon", [Tr, "./windingLine"],
        function(t) {
            function e(t, e) {
                return Math.abs(t - e) < r
            }
            function i(t, i, r) {
                var a = 0,
                o = t[0];
                if (!o) return ! 1;
                for (var s = 1; s < t[Wn]; s++) {
                    var l = t[s];
                    a += n(o[0], o[1], l[0], l[1], i, r),
                    o = l
                }
                var u = t[0];
                return e(o[0], u[0]) && e(o[1], u[1]) || (a += n(o[0], o[1], u[0], u[1], i, r)),
                0 !== a
            }
            var n = t("./windingLine"),
            r = 1e-8;
            return {
                contain: i
            }
        }),
        e("echarts/coord/axisDefault", [Tr, Ar],
        function(t) {
            var e = t(Ar),
            i = {
                show: !0,
                zlevel: 0,
                z: 0,
                inverse: !1,
                name: "",
                nameLocation: "end",
                nameRotate: null,
                nameTruncate: {
                    maxWidth: null,
                    ellipsis: "...",
                    placeholder: "."
                },
                nameTextStyle: {},
                nameGap: 15,
                silent: !1,
                triggerEvent: !1,
                tooltip: {
                    show: !1
                },
                axisLine: {
                    show: !0,
                    onZero: !0,
                    lineStyle: {
                        color: "#333",
                        width: 1,
                        type: "solid"
                    }
                },
                axisTick: {
                    show: !0,
                    inside: !1,
                    length: 5,
                    lineStyle: {
                        width: 1
                    }
                },
                axisLabel: {
                    show: !0,
                    inside: !1,
                    rotate: 0,
                    margin: 8,
                    textStyle: {
                        fontSize: 12
                    }
                },
                splitLine: {
                    show: !0,
                    lineStyle: {
                        color: ["#ccc"],
                        width: 1,
                        type: "solid"
                    }
                },
                splitArea: {
                    show: !1,
                    areaStyle: {
                        color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]
                    }
                }
            },
            n = e.merge({
                boundaryGap: !0,
                splitLine: {
                    show: !1
                },
                axisTick: {
                    alignWithLabel: !1,
                    interval: "auto"
                },
                axisLabel: {
                    interval: "auto"
                }
            },
            i),
            r = e.merge({
                boundaryGap: [0, 0],
                splitNumber: 5
            },
            i),
            a = e[qn]({
                scale: !0,
                min: "dataMin",
                max: "dataMax"
            },
            r),
            o = e[qn]({
                logBase: 10
            },
            r);
            return o.scale = !0,
            {
                categoryAxis: n,
                valueAxis: r,
                timeAxis: a,
                logAxis: o
            }
        }),
        e("zrender/animation/easing", [],
        function() {
            var t = {
                linear: function(t) {
                    return t
                },
                quadraticIn: function(t) {
                    return t * t
                },
                quadraticOut: function(t) {
                    return t * (2 - t)
                },
                quadraticInOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t: -.5 * (--t * (t - 2) - 1)
                },
                cubicIn: function(t) {
                    return t * t * t
                },
                cubicOut: function(t) {
                    return--t * t * t + 1
                },
                cubicInOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t: .5 * ((t -= 2) * t * t + 2)
                },
                quarticIn: function(t) {
                    return t * t * t * t
                },
                quarticOut: function(t) {
                    return 1 - --t * t * t * t
                },
                quarticInOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t: -.5 * ((t -= 2) * t * t * t - 2)
                },
                quinticIn: function(t) {
                    return t * t * t * t * t
                },
                quinticOut: function(t) {
                    return--t * t * t * t * t + 1
                },
                quinticInOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t * t: .5 * ((t -= 2) * t * t * t * t + 2)
                },
                sinusoidalIn: function(t) {
                    return 1 - Math.cos(t * Math.PI / 2)
                },
                sinusoidalOut: function(t) {
                    return Math.sin(t * Math.PI / 2)
                },
                sinusoidalInOut: function(t) {
                    return.5 * (1 - Math.cos(Math.PI * t))
                },
                exponentialIn: function(t) {
                    return 0 === t ? 0 : Math.pow(1024, t - 1)
                },
                exponentialOut: function(t) {
                    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                },
                exponentialInOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * ( - Math.pow(2, -10 * (t - 1)) + 2)
                },
                circularIn: function(t) {
                    return 1 - Math.sqrt(1 - t * t)
                },
                circularOut: function(t) {
                    return Math.sqrt(1 - --t * t)
                },
                circularInOut: function(t) {
                    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                },
                elasticIn: function(t) {
                    var e, i = .1,
                    n = .4;
                    return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n)))
                },
                elasticOut: function(t) {
                    var e, i = .1,
                    n = .4;
                    return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / n) + 1)
                },
                elasticInOut: function(t) {
                    var e, i = .1,
                    n = .4;
                    return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) * .5 + 1)
                },
                backIn: function(t) {
                    var e = 1.70158;
                    return t * t * ((e + 1) * t - e)
                },
                backOut: function(t) {
                    var e = 1.70158;
                    return--t * t * ((e + 1) * t + e) + 1
                },
                backInOut: function(t) {
                    var e = 2.5949095;
                    return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                },
                bounceIn: function(e) {
                    return 1 - t.bounceOut(1 - e)
                },
                bounceOut: function(t) {
                    return 1 / 2.75 > t ? 7.5625 * t * t: 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                },
                bounceInOut: function(e) {
                    return.5 > e ? .5 * t.bounceIn(2 * e) : .5 * t.bounceOut(2 * e - 1) + .5
                }
            };
            return t
        }),
        e("zrender/contain/windingLine", [],
        function() {
            return function(t, e, i, n, r, a) {
                if (a > e && a > n || e > a && n > a) return 0;
                if (n === e) return 0;
                var o = e > n ? 1 : -1,
                s = (a - e) / (n - e); (1 === s || 0 === s) && (o = e > n ? .5 : -.5);
                var l = s * (i - t) + t;
                return l > r ? o: 0
            }
        }),
        e("echarts/chart/bar/barItemStyle", [Tr, "../../model/mixin/makeStyleMapper"],
        function(t) {
            var e = t("../../model/mixin/makeStyleMapper")([["fill", "color"], [ye, N], [xe, "borderWidth"], [ye, "barBorderColor"], [xe, "barBorderWidth"], [Yi], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
            return {
                getBarItemStyle: function(t) {
                    var i = e.call(this, t);
                    if (this.getBorderLineDash) {
                        var n = this.getBorderLineDash();
                        n && (i.lineDash = n)
                    }
                    return i
                }
            }
        }),
        e("zrender/contain/arc", [Tr, "./util"],
        function(t) {
            var e = t("./util").normalizeRadian,
            i = 2 * Math.PI;
            return {
                containStroke: function(t, n, r, a, o, s, l, u, c) {
                    if (0 === l) return ! 1;
                    var h = l;
                    u -= t,
                    c -= n;
                    var d = Math.sqrt(u * u + c * c);
                    if (d - h > r || r > d + h) return ! 1;
                    if (Math.abs(a - o) % i < 1e-4) return ! 0;
                    if (s) {
                        var f = a;
                        a = e(o),
                        o = e(f)
                    } else a = e(a),
                    o = e(o);
                    a > o && (o += i);
                    var p = Math.atan2(c, u);
                    return 0 > p && (p += i),
                    p >= a && o >= p || p + i >= a && o >= p + i
                }
            }
        }),
        e("zrender/contain/cubic", [Tr, "../core/curve"],
        function(t) {
            var e = t("../core/curve");
            return {
                containStroke: function(t, i, n, r, a, o, s, l, u, c, h) {
                    if (0 === u) return ! 1;
                    var d = u;
                    if (h > i + d && h > r + d && h > o + d && h > l + d || i - d > h && r - d > h && o - d > h && l - d > h || c > t + d && c > n + d && c > a + d && c > s + d || t - d > c && n - d > c && a - d > c && s - d > c) return ! 1;
                    var f = e.cubicProjectPoint(t, i, n, r, a, o, s, l, c, h, null);
                    return d / 2 >= f
                }
            }
        }),
        e("zrender/contain/line", [],
        function() {
            return {
                containStroke: function(t, e, i, n, r, a, o) {
                    if (0 === r) return ! 1;
                    var s = r,
                    l = 0,
                    u = t;
                    if (o > e + s && o > n + s || e - s > o && n - s > o || a > t + s && a > i + s || t - s > a && i - s > a) return ! 1;
                    if (t === i) return Math.abs(a - t) <= s / 2;
                    l = (e - n) / (t - i),
                    u = (t * n - i * e) / (t - i);
                    var c = l * a - o + u,
                    h = c * c / (l * l + 1);
                    return s / 2 * s / 2 >= h
                }
            }
        }),
        e("zrender/contain/quadratic", [Tr, "../core/curve"],
        function(t) {
            var e = t("../core/curve");
            return {
                containStroke: function(t, i, n, r, a, o, s, l, u) {
                    if (0 === s) return ! 1;
                    var c = s;
                    if (u > i + c && u > r + c && u > o + c || i - c > u && r - c > u && o - c > u || l > t + c && l > n + c && l > a + c || t - c > l && n - c > l && a - c > l) return ! 1;
                    var h = e.quadraticProjectPoint(t, i, n, r, a, o, l, u, null);
                    return c / 2 >= h
                }
            }
        }),
        e("zrender/contain/util", [Tr],
        function() {
            var t = 2 * Math.PI;
            return {
                normalizeRadian: function(e) {
                    return e %= t,
                    0 > e && (e += t),
                    e
                }
            }
        }),
        e("zrender/core/LRU", [Tr],
        function() {
            var t = function() {
                this.head = null,
                this.tail = null,
                this._len = 0
            },
            e = t[xr];
            e.insert = function(t) {
                var e = new i(t);
                return this.insertEntry(e),
                e
            },
            e.insertEntry = function(t) {
                this.head ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : this.head = this.tail = t,
                this._len++
            },
            e[Xn] = function(t) {
                var e = t.prev,
                i = t.next;
                e ? e.next = i: this.head = i,
                i ? i.prev = e: this.tail = e,
                t.next = t.prev = null,
                this._len--
            },
            e.len = function() {
                return this._len
            };
            var i = function(t) {
                this.value = t,
                this.next,
                this.prev
            },
            n = function(e) {
                this._list = new t,
                this._map = {},
                this._maxSize = e || 10
            },
            r = n[xr];
            return r.put = function(t, e) {
                var i = this._list,
                n = this._map;
                if (null == n[t]) {
                    var r = i.len();
                    if (r >= this._maxSize && r > 0) {
                        var a = i.head;
                        i[Xn](a),
                        delete n[a.key]
                    }
                    var o = i.insert(e);
                    o.key = t,
                    n[t] = o
                }
            },
            r.get = function(t) {
                var e = this._map[t],
                i = this._list;
                return null != e ? (e !== i.tail && (i[Xn](e), i.insertEntry(e)), e.value) : void 0
            },
            r.clear = function() {
                this._list.clear(),
                this._map = {}
            },
            n
        }),
        e("zrender/graphic/helper/poly", [Tr, "./smoothSpline", "./smoothBezier"],
        function(t) {
            var e = t("./smoothSpline"),
            i = t("./smoothBezier");
            return {
                buildPath: function(t, n, r) {
                    var a = n[z],
                    o = n.smooth;
                    if (a && a[Wn] >= 2) {
                        if (o && "spline" !== o) {
                            var s = i(a, o, r, n.smoothConstraint);
                            t[p](a[0][0], a[0][1]);
                            for (var l = a[Wn], u = 0; (r ? l: l - 1) > u; u++) {
                                var c = s[2 * u],
                                v = s[2 * u + 1],
                                g = a[(u + 1) % l];
                                t[f](c[0], c[1], v[0], v[1], g[0], g[1])
                            }
                        } else {
                            "spline" === o && (a = e(a, r)),
                            t[p](a[0][0], a[0][1]);
                            for (var u = 1,
                            m = a[Wn]; m > u; u++) t[d](a[u][0], a[u][1])
                        }
                        r && t[h]()
                    }
                }
            }
        }),
        e("zrender/Handler", [Tr, "./core/util", "./mixin/Draggable", "./mixin/Eventful"],
        function(t) {
            function e(t, e, i) {
                return {
                    type: t,
                    event: i,
                    target: e,
                    cancelBubble: !1,
                    offsetX: i.zrX,
                    offsetY: i.zrY,
                    gestureEvent: i.gestureEvent,
                    pinchX: i.pinchX,
                    pinchY: i.pinchY,
                    pinchScale: i.pinchScale,
                    wheelDelta: i.zrDelta
                }
            }
            function i() {}
            function n(t, e, i) {
                if (t[t.rectHover ? "rectContain": ji](e, i)) {
                    for (var n = t; n;) {
                        if (n[Nn] || n.clipPath && !n.clipPath[ji](e, i)) return ! 1;
                        n = n[pe]
                    }
                    return ! 0
                }
                return ! 1
            }
            var r = t("./core/util"),
            a = t("./mixin/Draggable"),
            o = t("./mixin/Eventful");
            i[xr][Hn] = function() {};
            var s = ["click", "dblclick", "mousewheel", On, "mouseup", "mousedown", Rn],
            l = function(t, e, n) {
                o.call(this),
                this[lr] = t,
                this.painter = e,
                n = n || new i,
                this.proxy = n,
                n.handler = this,
                this._hovered,
                this._lastTouchMoment,
                this._lastX,
                this._lastY,
                a.call(this),
                r.each(s,
                function(t) {
                    n.on && n.on(t, this[t], this)
                },
                this)
            };
            return l[xr] = {
                constructor: l,
                mousemove: function(t) {
                    var e = t.zrX,
                    i = t.zrY,
                    n = this.findHover(e, i, null),
                    r = this._hovered,
                    a = this.proxy;
                    this._hovered = n,
                    a.setCursor && a.setCursor(n ? n.cursor: "default"),
                    r && n !== r && r.__zr && this.dispatchToElement(r, On, t),
                    this.dispatchToElement(n, Rn, t),
                    n && n !== r && this.dispatchToElement(n, En, t)
                },
                mouseout: function(t) {
                    this.dispatchToElement(this._hovered, On, t),
                    this[Zn]("globalout", {
                        event: t
                    })
                },
                resize: function() {
                    this._hovered = null
                },
                dispatch: function(t, e) {
                    var i = this[t];
                    i && i.call(this, e)
                },
                dispose: function() {
                    this.proxy[Hn](),
                    this[lr] = this.proxy = this.painter = null
                },
                setCursorStyle: function(t) {
                    var e = this.proxy;
                    e.setCursor && e.setCursor(t)
                },
                dispatchToElement: function(t, i, n) {
                    for (var r = "on" + i,
                    a = e(i, t, n), o = t; o && (o[r] && (a.cancelBubble = o[r].call(o, a)), o[Zn](i, a), o = o[pe], !a.cancelBubble););
                    a.cancelBubble || (this[Zn](i, a), this.painter && this.painter.eachOtherLayer(function(t) {
                        typeof t[r] == Sn && t[r].call(t, a),
                        t[Zn] && t[Zn](i, a)
                    }))
                },
                findHover: function(t, e, i) {
                    for (var r = this[lr].getDisplayList(), a = r[Wn] - 1; a >= 0; a--) if (!r[a][Nn] && r[a] !== i && !r[a][ar] && n(r[a], t, e)) return r[a]
                }
            },
            r.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick"],
            function(t) {
                l[xr][t] = function(e) {
                    var i = this.findHover(e.zrX, e.zrY, null);
                    if ("mousedown" === t) this._downel = i,
                    this._upel = i;
                    else if ("mosueup" === t) this._upel = i;
                    else if ("click" === t && this._downel !== this._upel) return;
                    this.dispatchToElement(i, t, e)
                }
            }),
            r.mixin(l, o),
            r.mixin(l, a),
            l
        }),
        e("zrender/animation/Animation", [Tr, r, "../core/event", "./requestAnimationFrame", "./Animator"],
        function(t) {
            var e = t(r),
            i = t("../core/event").Dispatcher,
            n = t("./requestAnimationFrame"),
            a = t("./Animator"),
            o = function(t) {
                t = t || {},
                this.stage = t.stage || {},
                this.onframe = t.onframe ||
                function() {},
                this._clips = [],
                this._running = !1,
                this._time,
                this._pausedTime,
                this._pauseStart,
                this._paused = !1,
                i.call(this)
            };
            return o[xr] = {
                constructor: o,
                addClip: function(t) {
                    this._clips.push(t)
                },
                addAnimator: function(t) {
                    t[vr] = this;
                    for (var e = t.getClips(), i = 0; i < e[Wn]; i++) this.addClip(e[i])
                },
                removeClip: function(t) {
                    var i = e[gn](this._clips, t);
                    i >= 0 && this._clips[Gn](i, 1)
                },
                removeAnimator: function(t) {
                    for (var e = t.getClips(), i = 0; i < e[Wn]; i++) this.removeClip(e[i]);
                    t[vr] = null
                },
                _update: function() {
                    for (var t = (new Date).getTime() - this._pausedTime, e = t - this._time, i = this._clips, n = i[Wn], r = [], a = [], o = 0; n > o; o++) {
                        var s = i[o],
                        l = s.step(t);
                        l && (r.push(l), a.push(s))
                    }
                    for (var o = 0; n > o;) i[o]._needsRemove ? (i[o] = i[n - 1], i.pop(), n--) : o++;
                    n = r[Wn];
                    for (var o = 0; n > o; o++) a[o].fire(r[o]);
                    this._time = t,
                    this.onframe(e),
                    this[Zn]("frame", e),
                    this.stage[er] && this.stage[er]()
                },
                _startLoop: function() {
                    function t() {
                        e._running && (n(t), !e._paused && e._update())
                    }
                    var e = this;
                    this._running = !0,
                    n(t)
                },
                start: function() {
                    this._time = (new Date).getTime(),
                    this._pausedTime = 0,
                    this._startLoop()
                },
                stop: function() {
                    this._running = !1
                },
                pause: function() {
                    this._paused || (this._pauseStart = (new Date).getTime(), this._paused = !0)
                },
                resume: function() {
                    this._paused && (this._pausedTime += (new Date).getTime() - this._pauseStart, this._paused = !1)
                },
                clear: function() {
                    this._clips = []
                },
                animate: function(t, e) {
                    e = e || {};
                    var i = new a(t, e.loop, e.getter, e.setter);
                    return i
                }
            },
            e.mixin(o, i),
            o
        }),
        e("zrender/Storage", [Tr, "./core/util", "./core/env", "./container/Group", "./core/timsort"],
        function(t) {
            function e(t, e) {
                return t[Cn] === e[Cn] ? t.z === e.z ? t.z2 - e.z2: t.z - e.z: t[Cn] - e[Cn]
            }
            var n = t("./core/util"),
            r = t("./core/env"),
            o = t("./container/Group"),
            s = t("./core/timsort"),
            l = function() {
                this._elements = {},
                this._roots = [],
                this._displayList = [],
                this._displayListLen = 0
            };
            return l[xr] = {
                constructor: l,
                traverse: function(t, e) {
                    for (var i = 0; i < this._roots[Wn]; i++) this._roots[i][kn](t, e)
                },
                getDisplayList: function(t, e) {
                    return e = e || !1,
                    t && this.updateDisplayList(e),
                    this._displayList
                },
                updateDisplayList: function(t) {
                    this._displayListLen = 0;
                    for (var i = this._roots,
                    n = this._displayList,
                    a = 0,
                    o = i[Wn]; o > a; a++) this._updateAndAddDisplayable(i[a], null, t);
                    n[Wn] = this._displayListLen,
                    r[cr] && s(n, e)
                },
                _updateAndAddDisplayable: function(t, e, n) {
                    if (!t[ar] || n) {
                        t.beforeUpdate(),
                        t[a] && t[er](),
                        t.afterUpdate();
                        var r = t.clipPath;
                        if (r && (r[pe] = t, r[i](), e ? (e = e.slice(), e.push(r)) : e = [r]), t.isGroup) {
                            for (var o = t._children,
                            s = 0; s < o[Wn]; s++) {
                                var l = o[s];
                                t[a] && (l[a] = !0),
                                this._updateAndAddDisplayable(l, e, n)
                            }
                            t[a] = !1
                        } else t.__clipPaths = e,
                        this._displayList[this._displayListLen++] = t
                    }
                },
                addRoot: function(t) {
                    this._elements[t.id] || (t instanceof o && t.addChildrenToStorage(this), this.addToMap(t), this._roots.push(t))
                },
                delRoot: function(t) {
                    if (null == t) {
                        for (var e = 0; e < this._roots[Wn]; e++) {
                            var i = this._roots[e];
                            i instanceof o && i.delChildrenFromStorage(this)
                        }
                        return this._elements = {},
                        this._roots = [],
                        this._displayList = [],
                        void(this._displayListLen = 0)
                    }
                    if (t instanceof Array) for (var e = 0,
                    r = t[Wn]; r > e; e++) this.delRoot(t[e]);
                    else {
                        var a;
                        a = typeof t == yr ? this._elements[t] : t;
                        var s = n[gn](this._roots, a);
                        s >= 0 && (this.delFromMap(a.id), this._roots[Gn](s, 1), a instanceof o && a.delChildrenFromStorage(this))
                    }
                },
                addToMap: function(t) {
                    return t instanceof o && (t.__storage = this),
                    t.dirty(!1),
                    this._elements[t.id] = t,
                    this
                },
                get: function(t) {
                    return this._elements[t]
                },
                delFromMap: function(t) {
                    var e = this._elements,
                    i = e[t];
                    return i && (delete e[t], i instanceof o && (i.__storage = null)),
                    this
                },
                dispose: function() {
                    this._elements = this._renderList = this._roots = null
                },
                displayableSortFunc: e
            },
            l
        }),
        e("zrender/dom/HandlerProxy", [Tr, "../core/event", r, "../mixin/Eventful", "../core/env", "../core/GestureMgr"],
        function(t) {
            function e(t) {
                return "mousewheel" === t && h.browser.firefox ? "DOMMouseScroll": t
            }
            function i(t, e, i) {
                var n = t._gestureMgr;
                "start" === i && n.clear();
                var r = n.recognize(e, t.handler.findHover(e.zrX, e.zrY, null), t.dom);
                if ("end" === i && n.clear(), r) {
                    var a = r.type;
                    e.gestureEvent = a,
                    t.handler.dispatchToElement(r[Vn], a, r.event)
                }
            }
            function n(t) {
                t._touching = !0,
                clearTimeout(t._touchTimer),
                t._touchTimer = setTimeout(function() {
                    t._touching = !1
                },
                700)
            }
            function a() {
                return h.touchEventsSupported
            }
            function o(t) {
                function e(t, e) {
                    return function() {
                        return e._touching ? void 0 : t.apply(e, arguments)
                    }
                }
                for (var i = 0; i < y[Wn]; i++) {
                    var n = y[i];
                    t._handlers[n] = u.bind(x[n], t)
                }
                for (var i = 0; i < m[Wn]; i++) {
                    var n = m[i];
                    t._handlers[n] = e(x[n], t)
                }
            }
            function s(t) {
                function i(i, n) {
                    u.each(i,
                    function(i) {
                        f(t, e(i), n._handlers[i])
                    },
                    n)
                }
                c.call(this),
                this.dom = t,
                this._touching = !1,
                this._touchTimer,
                this._gestureMgr = new d,
                this._handlers = {},
                o(this),
                a() && i(y, this),
                i(m, this)
            }
            var l = t("../core/event"),
            u = t(r),
            c = t("../mixin/Eventful"),
            h = t("../core/env"),
            d = t("../core/GestureMgr"),
            f = l.addEventListener,
            p = l.removeEventListener,
            v = l.normalizeEvent,
            g = 300,
            m = ["click", "dblclick", "mousewheel", On, "mouseup", "mousedown", Rn],
            y = ["touchstart", "touchend", "touchmove"],
            x = {
                mousemove: function(t) {
                    t = v(this.dom, t),
                    this[Zn](Rn, t)
                },
                mouseout: function(t) {
                    t = v(this.dom, t);
                    var e = t.toElement || t.relatedTarget;
                    if (e != this.dom) for (; e && 9 != e.nodeType;) {
                        if (e === this.dom) return;
                        e = e[A]
                    }
                    this[Zn](On, t)
                },
                touchstart: function(t) {
                    t = v(this.dom, t),
                    this._lastTouchMoment = new Date,
                    i(this, t, "start"),
                    x[Rn].call(this, t),
                    x.mousedown.call(this, t),
                    n(this)
                },
                touchmove: function(t) {
                    t = v(this.dom, t),
                    i(this, t, "change"),
                    x[Rn].call(this, t),
                    n(this)
                },
                touchend: function(t) {
                    t = v(this.dom, t),
                    i(this, t, "end"),
                    x.mouseup.call(this, t),
                    +new Date - this._lastTouchMoment < g && x.click.call(this, t),
                    n(this)
                }
            };
            u.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick"],
            function(t) {
                x[t] = function(e) {
                    e = v(this.dom, e),
                    this[Zn](t, e)
                }
            });
            var _ = s[xr];
            return _[Hn] = function() {
                for (var t = m[Ai](y), i = 0; i < t[Wn]; i++) {
                    var n = t[i];
                    p(this.dom, e(n), this._handlers[n])
                }
            },
            _.setCursor = function(t) {
                this.dom.style.cursor = t || "default"
            },
            u.mixin(s, c),
            s
        }),
        e("zrender/graphic/helper/smoothSpline", [Tr, "../../core/vector"],
        function(t) {
            function e(t, e, i, n, r, a, o) {
                var s = .5 * (i - t),
                l = .5 * (n - e);
                return (2 * (e - i) + s + l) * o + ( - 3 * (e - i) - 2 * s - l) * a + s * r + e
            }
            var i = t("../../core/vector");
            return function(t, n) {
                for (var r = t[Wn], a = [], o = 0, s = 1; r > s; s++) o += i[ge](t[s - 1], t[s]);
                var l = o / 2;
                l = r > l ? r: l;
                for (var s = 0; l > s; s++) {
                    var u, c, h, d = s / (l - 1) * (n ? r: r - 1),
                    f = Math.floor(d),
                    p = d - f,
                    v = t[f % r];
                    n ? (u = t[(f - 1 + r) % r], c = t[(f + 1) % r], h = t[(f + 2) % r]) : (u = t[0 === f ? f: f - 1], c = t[f > r - 2 ? r - 1 : f + 1], h = t[f > r - 3 ? r - 1 : f + 2]);
                    var g = p * p,
                    m = p * g;
                    a.push([e(u[0], v[0], c[0], h[0], p, g, m), e(u[1], v[1], c[1], h[1], p, g, m)])
                }
                return a
            }
        }),
        e("zrender/mixin/Draggable", [Tr],
        function() {
            function t() {
                this.on("mousedown", this._dragStart, this),
                this.on(Rn, this._drag, this),
                this.on("mouseup", this._dragEnd, this),
                this.on("globalout", this._dragEnd, this)
            }
            return t[xr] = {
                constructor: t,
                _dragStart: function(t) {
                    var e = t[Vn];
                    e && e[L] && (this._draggingTarget = e, e.dragging = !0, this._x = t[w], this._y = t[_], this.dispatchToElement(e, "dragstart", t.event))
                },
                _drag: function(t) {
                    var e = this._draggingTarget;
                    if (e) {
                        var i = t[w],
                        n = t[_],
                        r = i - this._x,
                        a = n - this._y;
                        this._x = i,
                        this._y = n,
                        e.drift(r, a, t),
                        this.dispatchToElement(e, "drag", t.event);
                        var o = this.findHover(i, n, e),
                        s = this._dropTarget;
                        this._dropTarget = o,
                        e !== o && (s && o !== s && this.dispatchToElement(s, "dragleave", t.event), o && o !== s && this.dispatchToElement(o, "dragenter", t.event))
                    }
                },
                _dragEnd: function(t) {
                    var e = this._draggingTarget;
                    e && (e.dragging = !1),
                    this.dispatchToElement(e, "dragend", t.event),
                    this._dropTarget && this.dispatchToElement(this._dropTarget, "drop", t.event),
                    this._draggingTarget = null,
                    this._dropTarget = null
                }
            },
            t
        }),
        e("zrender/graphic/helper/smoothBezier", [Tr, "../../core/vector"],
        function(t) {
            var e = t("../../core/vector"),
            i = e.min,
            n = e.max,
            r = e.scale,
            a = e[ge],
            o = e.add;
            return function(t, s, l, u) {
                var c, h, d, f, p = [],
                v = [],
                g = [],
                m = [];
                if (u) {
                    d = [1 / 0, 1 / 0],
                    f = [ - 1 / 0, -1 / 0];
                    for (var y = 0,
                    x = t[Wn]; x > y; y++) i(d, d, t[y]),
                    n(f, f, t[y]);
                    i(d, d, u[0]),
                    n(f, f, u[1])
                }
                for (var y = 0,
                x = t[Wn]; x > y; y++) {
                    var _ = t[y];
                    if (l) c = t[y ? y - 1 : x - 1],
                    h = t[(y + 1) % x];
                    else {
                        if (0 === y || y === x - 1) {
                            p.push(e.clone(t[y]));
                            continue
                        }
                        c = t[y - 1],
                        h = t[y + 1]
                    }
                    e.sub(v, h, c),
                    r(v, v, s);
                    var w = a(_, c),
                    b = a(_, h),
                    M = w + b;
                    0 !== M && (w /= M, b /= M),
                    r(g, v, -w),
                    r(m, v, b);
                    var S = o([], _, g),
                    A = o([], _, m);
                    u && (n(S, S, d), i(S, S, f), n(A, A, d), i(A, A, f)),
                    p.push(S),
                    p.push(A)
                }
                return l && p.push(p.shift()),
                p
            }
        }),
        e("zrender/Painter", [Tr, "./config", "./core/util", "./core/log", "./core/BoundingRect", "./core/timsort", "./Layer", "./animation/requestAnimationFrame", "./graphic/Image"],
        function(t) {
            function e(t) {
                return parseInt(t, 10)
            }
            function i(t) {
                return t ? t.isBuildin ? !0 : typeof t[gr] !== Sn || typeof t.refresh !== Sn ? !1 : !0 : !1
            }
            function n(t) {
                t.__unusedCount++
            }
            function r(t) {
                1 == t.__unusedCount && t.clear()
            }
            function o(t, e, i) {
                return y.copy(t[en]()),
                t[k] && y[_e](t[k]),
                x.width = e,
                x[nr] = i,
                !y.intersect(x)
            }
            function s(t, e) {
                if (t == e) return ! 1;
                if (!t || !e || t[Wn] !== e[Wn]) return ! 0;
                for (var i = 0; i < t[Wn]; i++) if (t[i] !== e[i]) return ! 0
            }
            function l(t, e) {
                for (var i = 0; i < t[Wn]; i++) {
                    var n = t[i],
                    r = n.path;
                    n.setTransform(e),
                    r.beginPath(e),
                    n.buildPath(r, n.shape),
                    e.clip(),
                    n.restoreTransform(e)
                }
            }
            function u(t, e) {
                var i = document[Ti]("div"),
                n = i.style;
                return n[$i] = "relative",
                n.overflow = "hidden",
                n.width = t + "px",
                n[nr] = e + "px",
                i
            }
            var c = t("./config"),
            h = t("./core/util"),
            d = t("./core/log"),
            f = t("./core/BoundingRect"),
            p = t("./core/timsort"),
            v = t("./Layer"),
            g = t("./animation/requestAnimationFrame"),
            m = 5,
            y = new f(0, 0, 0, 0),
            x = new f(0, 0, 0, 0),
            _ = function(t, e, i) {
                var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
                i = i || {},
                this.dpr = i.devicePixelRatio || c.devicePixelRatio,
                this._singleCanvas = n,
                this.root = t;
                var r = t.style;
                r && (r["-webkit-tap-highlight-color"] = "transparent", r["-webkit-user-select"] = r["user-select"] = r["-webkit-touch-callout"] = "none", t.innerHTML = ""),
                this[lr] = e;
                var a = this._zlevelList = [],
                o = this._layers = {};
                if (this._layerConfig = {},
                n) {
                    var s = t.width,
                    l = t[nr];
                    this._width = s,
                    this._height = l;
                    var h = new v(t, this, 1);
                    h.initContext(),
                    o[0] = h,
                    a.push(0)
                } else {
                    this._width = this._getWidth(),
                    this._height = this._getHeight();
                    var d = this._domRoot = u(this._width, this._height);
                    t.appendChild(d)
                }
                this.pathToImage = this._createPathToImage(),
                this._progressiveLayers = [],
                this._hoverlayer,
                this._hoverElements = []
            };
            return _[xr] = {
                constructor: _,
                isSingleCanvas: function() {
                    return this._singleCanvas
                },
                getViewportRoot: function() {
                    return this._singleCanvas ? this._layers[0].dom: this._domRoot
                },
                refresh: function(t) {
                    var e = this[lr].getDisplayList(!0),
                    i = this._zlevelList;
                    this._paintList(e, t);
                    for (var n = 0; n < i[Wn]; n++) {
                        var r = i[n],
                        a = this._layers[r]; ! a.isBuildin && a.refresh && a.refresh()
                    }
                    return this.refreshHover(),
                    this._progressiveLayers[Wn] && this._startProgessive(),
                    this
                },
                addHover: function(t, e) {
                    if (!t.__hoverMir) {
                        var i = new t.constructor({
                            style: t.style,
                            shape: t.shape
                        });
                        i.__from = t,
                        t.__hoverMir = i,
                        i[Ln](e),
                        this._hoverElements.push(i)
                    }
                },
                removeHover: function(t) {
                    var e = t.__hoverMir,
                    i = this._hoverElements,
                    n = h[gn](i, e);
                    n >= 0 && i[Gn](n, 1),
                    t.__hoverMir = null
                },
                clearHover: function() {
                    for (var t = this._hoverElements,
                    e = 0; e < t[Wn]; e++) {
                        var i = t[e].__from;
                        i && (i.__hoverMir = null)
                    }
                    t[Wn] = 0
                },
                refreshHover: function() {
                    var t = this._hoverElements,
                    e = t[Wn],
                    i = this._hoverlayer;
                    if (i && i.clear(), e) {
                        p(t, this[lr].displayableSortFunc),
                        i || (i = this._hoverlayer = this.getLayer(1e5));
                        var n = {};
                        i.ctx.save();
                        for (var r = 0; e > r;) {
                            var a = t[r],
                            o = a.__from;
                            o && o.__zr ? (r++, o[M] || (a[k] = o[k], a.invTransform = o.invTransform, a.__clipPaths = o.__clipPaths, this._doPaintEl(a, i, !0, n))) : (t[Gn](r, 1), o.__hoverMir = null, e--)
                        }
                        i.ctx.restore()
                    }
                },
                _startProgessive: function() {
                    function t() {
                        i === e._progressiveToken && e[lr] && (e._doPaintList(e[lr].getDisplayList()), e._furtherProgressive ? (e._progress++, g(t)) : e._progressiveToken = -1)
                    }
                    var e = this;
                    if (e._furtherProgressive) {
                        var i = e._progressiveToken = +new Date;
                        e._progress++,
                        g(t)
                    }
                },
                _clearProgressive: function() {
                    this._progressiveToken = -1,
                    this._progress = 0,
                    h.each(this._progressiveLayers,
                    function(t) {
                        t[a] && t.clear()
                    })
                },
                _paintList: function(t, e) {
                    null == e && (e = !1),
                    this._updateLayerStatus(t),
                    this._clearProgressive(),
                    this.eachBuildinLayer(n),
                    this._doPaintList(t, e),
                    this.eachBuildinLayer(r)
                },
                _doPaintList: function(t, e) {
                    function i(t) {
                        var e = o.dpr || 1;
                        o.save(),
                        o.globalAlpha = 1,
                        o.shadowBlur = 0,
                        n[a] = !0,
                        o.setTransform(1, 0, 0, 1, 0, 0),
                        o.drawImage(t.dom, 0, 0, f * e, p * e),
                        o.restore()
                    }
                    for (var n, r, o, s, l, u, c = 0,
                    f = this._width,
                    p = this._height,
                    v = this._progress,
                    g = 0,
                    y = t[Wn]; y > g; g++) {
                        var x = t[g],
                        _ = this._singleCanvas ? 0 : x[Cn],
                        w = x.__frame;
                        if (0 > w && l && (i(l), l = null), r !== _ && (o && o.restore(), s = {},
                        r = _, n = this.getLayer(r), n.isBuildin || d("ZLevel " + r + " has been used by unkown layer " + n.id), o = n.ctx, o.save(), n.__unusedCount = 0, (n[a] || e) && n.clear()), n[a] || e) {
                            if (w >= 0) {
                                if (!l) {
                                    if (l = this._progressiveLayers[Math.min(c++, m - 1)], l.ctx.save(), l.renderScope = {},
                                    l && l.__progress > l.__maxProgress) {
                                        g = l.__nextIdxNotProg - 1;
                                        continue
                                    }
                                    u = l.__progress,
                                    l[a] || (v = u),
                                    l.__progress = v + 1
                                }
                                w === v && this._doPaintEl(x, l, !0, l.renderScope)
                            } else this._doPaintEl(x, n, e, s);
                            x[a] = !1
                        }
                    }
                    l && i(l),
                    o && o.restore(),
                    this._furtherProgressive = !1,
                    h.each(this._progressiveLayers,
                    function(t) {
                        t.__maxProgress >= t.__progress && (this._furtherProgressive = !0)
                    },
                    this)
                },
                _doPaintEl: function(t, e, i, n) {
                    var r = e.ctx,
                    u = t[k];
                    if (! (!e[a] && !i || t[M] || 0 === t.style[Yi] || u && !u[0] && !u[3] || t.culling && o(t, this._width, this._height))) {
                        var c = t.__clipPaths; (n.prevClipLayer !== e || s(c, n.prevElClipPaths)) && (n.prevElClipPaths && (n.prevClipLayer.ctx.restore(), n.prevClipLayer = n.prevElClipPaths = null, n.prevEl = null), c && (r.save(), l(c, r), n.prevClipLayer = e, n.prevElClipPaths = c)),
                        t.beforeBrush && t.beforeBrush(r),
                        t.brush(r, n.prevEl || null),
                        n.prevEl = t,
                        t.afterBrush && t.afterBrush(r)
                    }
                },
                getLayer: function(t) {
                    if (this._singleCanvas) return this._layers[0];
                    var e = this._layers[t];
                    return e || (e = new v("zr_" + t, this, this.dpr), e.isBuildin = !0, this._layerConfig[t] && h.merge(e, this._layerConfig[t], !0), this.insertLayer(t, e), e.initContext()),
                    e
                },
                insertLayer: function(t, e) {
                    var n = this._layers,
                    r = this._zlevelList,
                    a = r[Wn],
                    o = null,
                    s = -1,
                    l = this._domRoot;
                    if (n[t]) return void d("ZLevel " + t + " has been used already");
                    if (!i(e)) return void d("Layer of zlevel " + t + " is not valid");
                    if (a > 0 && t > r[0]) {
                        for (s = 0; a - 1 > s && !(r[s] < t && r[s + 1] > t); s++);
                        o = n[r[s]]
                    }
                    if (r[Gn](s + 1, 0, t), o) {
                        var u = o.dom;
                        u.nextSibling ? l.insertBefore(e.dom, u.nextSibling) : l.appendChild(e.dom)
                    } else l.firstChild ? l.insertBefore(e.dom, l.firstChild) : l.appendChild(e.dom);
                    n[t] = e
                },
                eachLayer: function(t, e) {
                    var i, n, r = this._zlevelList;
                    for (n = 0; n < r[Wn]; n++) i = r[n],
                    t.call(e, this._layers[i], i)
                },
                eachBuildinLayer: function(t, e) {
                    var i, n, r, a = this._zlevelList;
                    for (r = 0; r < a[Wn]; r++) n = a[r],
                    i = this._layers[n],
                    i.isBuildin && t.call(e, i, n)
                },
                eachOtherLayer: function(t, e) {
                    var i, n, r, a = this._zlevelList;
                    for (r = 0; r < a[Wn]; r++) n = a[r],
                    i = this._layers[n],
                    i.isBuildin || t.call(e, i, n)
                },
                getLayers: function() {
                    return this._layers
                },
                _updateLayerStatus: function(t) {
                    var e = this._layers,
                    i = this._progressiveLayers,
                    n = {},
                    r = {};
                    this.eachBuildinLayer(function(t, e) {
                        n[e] = t.elCount,
                        t.elCount = 0,
                        t[a] = !1
                    }),
                    h.each(i,
                    function(t, e) {
                        r[e] = t.elCount,
                        t.elCount = 0,
                        t[a] = !1
                    });
                    for (var o, s, l = 0,
                    u = 0,
                    c = 0,
                    d = t[Wn]; d > c; c++) {
                        var f = t[c],
                        p = this._singleCanvas ? 0 : f[Cn],
                        g = e[p],
                        y = f.progressive;
                        if (g && (g.elCount++, g[a] = g[a] || f[a]), y >= 0) {
                            s !== y && (s = y, u++);
                            var x = f.__frame = u - 1;
                            if (!o) {
                                var _ = Math.min(l, m - 1);
                                o = i[_],
                                o || (o = i[_] = new v("progressive", this, this.dpr), o.initContext()),
                                o.__maxProgress = 0
                            }
                            o[a] = o[a] || f[a],
                            o.elCount++,
                            o.__maxProgress = Math.max(o.__maxProgress, x),
                            o.__maxProgress >= o.__progress && (g[a] = !0)
                        } else f.__frame = -1,
                        o && (o.__nextIdxNotProg = c, l++, o = null)
                    }
                    o && (l++, o.__nextIdxNotProg = c),
                    this.eachBuildinLayer(function(t, e) {
                        n[e] !== t.elCount && (t[a] = !0)
                    }),
                    i[Wn] = Math.min(l, m),
                    h.each(i,
                    function(t, e) {
                        r[e] !== t.elCount && (f[a] = !0),
                        t[a] && (t.__progress = 0)
                    })
                },
                clear: function() {
                    return this.eachBuildinLayer(this._clearLayer),
                    this
                },
                _clearLayer: function(t) {
                    t.clear()
                },
                configLayer: function(t, e) {
                    if (e) {
                        var i = this._layerConfig;
                        i[t] ? h.merge(i[t], e, !0) : i[t] = e;
                        var n = this._layers[t];
                        n && h.merge(n, i[t], !0)
                    }
                },
                delLayer: function(t) {
                    var e = this._layers,
                    i = this._zlevelList,
                    n = e[t];
                    n && (n.dom[A].removeChild(n.dom), delete e[t], i[Gn](h[gn](i, t), 1))
                },
                resize: function(t, e) {
                    var i = this._domRoot;
                    if (i.style.display = "none", t = t || this._getWidth(), e = e || this._getHeight(), i.style.display = "", this._width != t || e != this._height) {
                        i.style.width = t + "px",
                        i.style[nr] = e + "px";
                        for (var n in this._layers) this._layers[n][gr](t, e);
                        this.refresh(!0)
                    }
                    return this._width = t,
                    this._height = e,
                    this
                },
                clearLayer: function(t) {
                    var e = this._layers[t];
                    e && e.clear()
                },
                dispose: function() {
                    this.root.innerHTML = "",
                    this.root = this[lr] = this._domRoot = this._layers = null
                },
                getRenderedCanvas: function(t) {
                    if (t = t || {},
                    this._singleCanvas) return this._layers[0].dom;
                    var e = new v("image", this, t.pixelRatio || this.dpr);
                    e.initContext(),
                    e.clearColor = t[ur],
                    e.clear();
                    for (var i = this[lr].getDisplayList(!0), n = {},
                    r = 0; r < i[Wn]; r++) {
                        var a = i[r];
                        this._doPaintEl(a, e, !0, n)
                    }
                    return e.dom
                },
                getWidth: function() {
                    return this._width
                },
                getHeight: function() {
                    return this._height
                },
                _getWidth: function() {
                    var t = this.root,
                    i = document.defaultView.getComputedStyle(t);
                    return (t.clientWidth || e(i.width) || e(t.style.width)) - (e(i.paddingLeft) || 0) - (e(i.paddingRight) || 0) | 0
                },
                _getHeight: function() {
                    var t = this.root,
                    i = document.defaultView.getComputedStyle(t);
                    return (t.clientHeight || e(i[nr]) || e(t.style[nr])) - (e(i.paddingTop) || 0) - (e(i.paddingBottom) || 0) | 0
                },
                _pathToImage: function(e, i, n, r, a) {
                    var o = document[Ti](mr),
                    s = o.getContext("2d");
                    o.width = n * a,
                    o[nr] = r * a,
                    s.clearRect(0, 0, n * a, r * a);
                    var l = {
                        position: i[$i],
                        rotation: i[ni],
                        scale: i.scale
                    };
                    i[$i] = [0, 0, 0],
                    i[ni] = 0,
                    i.scale = [1, 1],
                    i && i.brush(s);
                    var u = t("./graphic/Image"),
                    c = new u({
                        id: e,
                        style: {
                            x: 0,
                            y: 0,
                            image: o
                        }
                    });
                    return null != l[$i] && (c[$i] = i[$i] = l[$i]),
                    null != l[ni] && (c[ni] = i[ni] = l[ni]),
                    null != l.scale && (c.scale = i.scale = l.scale),
                    c
                },
                _createPathToImage: function() {
                    var t = this;
                    return function(e, i, n, r) {
                        return t._pathToImage(e, i, n, r, t.dpr)
                    }
                }
            },
            _
        }),
        e("zrender/animation/requestAnimationFrame", [Tr],
        function() {
            return typeof window !== Be && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) ||
            function(t) {
                setTimeout(t, 16)
            }
        }),
        e("zrender/core/event", [Tr, "../mixin/Eventful"],
        function(t) {
            function e(t) {
                return t.getBoundingClientRect ? t.getBoundingClientRect() : {
                    left: 0,
                    top: 0
                }
            }
            function i(t, i, n) {
                var r = e(t);
                return n = n || {},
                n.zrX = i.clientX - r.left,
                n.zrY = i.clientY - r.top,
                n
            }
            function n(t, e) {
                if (e = e || window.event, null != e.zrX) return e;
                var n = e.type,
                r = n && n[gn]("touch") >= 0;
                if (r) {
                    var a = "touchend" != n ? e.targetTouches[0] : e.changedTouches[0];
                    a && i(t, a, e)
                } else i(t, e, e),
                e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
                return e
            }
            function r(t, e, i) {
                s ? t.addEventListener(e, i) : t.attachEvent("on" + e, i)
            }
            function a(t, e, i) {
                s ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i)
            }
            var o = t("../mixin/Eventful"),
            s = typeof window !== Be && !!window.addEventListener,
            l = s ?
            function(t) {
                t.preventDefault(),
                t.stopPropagation(),
                t.cancelBubble = !0
            }: function(t) {
                t.returnValue = !1,
                t.cancelBubble = !0
            };
            return {
                clientToLocal: i,
                normalizeEvent: n,
                addEventListener: r,
                removeEventListener: a,
                stop: l,
                Dispatcher: o
            }
        }),
        e("zrender/graphic/helper/roundRect", [Tr],
        function() {
            return {
                buildPath: function(t, e) {
                    var i, n, r, a, o = e.x,
                    s = e.y,
                    l = e.width,
                    u = e[nr],
                    c = e.r;
                    0 > l && (o += l, l = -l),
                    0 > u && (s += u, u = -u),
                    typeof c === yn ? i = n = r = a = c: c instanceof Array ? 1 === c[Wn] ? i = n = r = a = c[0] : 2 === c[Wn] ? (i = r = c[0], n = a = c[1]) : 3 === c[Wn] ? (i = c[0], n = a = c[1], r = c[2]) : (i = c[0], n = c[1], r = c[2], a = c[3]) : i = n = r = a = 0;
                    var h;
                    i + n > l && (h = i + n, i *= l / h, n *= l / h),
                    r + a > l && (h = r + a, r *= l / h, a *= l / h),
                    n + r > u && (h = n + r, n *= u / h, r *= u / h),
                    i + a > u && (h = i + a, i *= u / h, a *= u / h),
                    t[p](o + i, s),
                    t[d](o + l - n, s),
                    0 !== n && t.quadraticCurveTo(o + l, s, o + l, s + n),
                    t[d](o + l, s + u - r),
                    0 !== r && t.quadraticCurveTo(o + l, s + u, o + l - r, s + u),
                    t[d](o + a, s + u),
                    0 !== a && t.quadraticCurveTo(o, s + u, o, s + u - a),
                    t[d](o, s + i),
                    0 !== i && t.quadraticCurveTo(o, s, o + i, s)
                }
            }
        }),
        e("zrender/core/GestureMgr", [Tr, "./event"],
        function(t) {
            function e(t) {
                var e = t[1][0] - t[0][0],
                i = t[1][1] - t[0][1];
                return Math.sqrt(e * e + i * i)
            }
            function i(t) {
                return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
            }
            var n = t("./event"),
            r = function() {
                this._track = []
            };
            r[xr] = {
                constructor: r,
                recognize: function(t, e, i) {
                    return this._doTrack(t, e, i),
                    this._recognize(t)
                },
                clear: function() {
                    return this._track[Wn] = 0,
                    this
                },
                _doTrack: function(t, e, i) {
                    var r = t.touches;
                    if (r) {
                        for (var a = {
                            points: [],
                            touches: [],
                            target: e,
                            event: t
                        },
                        o = 0, s = r[Wn]; s > o; o++) {
                            var l = r[o],
                            u = n.clientToLocal(i, l);
                            a[z].push([u.zrX, u.zrY]),
                            a.touches.push(l)
                        }
                        this._track.push(a)
                    }
                },
                _recognize: function(t) {
                    for (var e in a) if (a.hasOwnProperty(e)) {
                        var i = a[e](this._track, t);
                        if (i) return i
                    }
                }
            };
            var a = {
                pinch: function(t, n) {
                    var r = t[Wn];
                    if (r) {
                        var a = (t[r - 1] || {})[z],
                        o = (t[r - 2] || {})[z] || a;
                        if (o && o[Wn] > 1 && a && a[Wn] > 1) {
                            var s = e(a) / e(o); ! isFinite(s) && (s = 1),
                            n.pinchScale = s;
                            var l = i(a);
                            return n.pinchX = l[0],
                            n.pinchY = l[1],
                            {
                                type: "pinch",
                                target: t[0][Vn],
                                event: n
                            }
                        }
                    }
                }
            };
            return r
        }),
        e("echarts/chart/helper/LinePath", [Tr, Si, wr],
        function(t) {
            function e(t) {
                return isNaN( + t.cpx1) || isNaN( + t.cpy1)
            }
            var i = t(Si),
            n = t(wr),
            r = i.Line[xr],
            a = i.BezierCurve[xr];
            return i.extendShape({
                type: "ec-line",
                style: {
                    stroke: "#000",
                    fill: null
                },
                shape: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                    percent: 1,
                    cpx1: null,
                    cpy1: null
                },
                buildPath: function(t, i) { (e(i) ? r: a).buildPath(t, i)
                },
                pointAt: function(t) {
                    return e(this.shape) ? r.pointAt.call(this, t) : a.pointAt.call(this, t)
                },
                tangentAt: function(t) {
                    var i = this.shape,
                    r = e(i) ? [i.x2 - i.x1, i.y2 - i.y1] : a.tangentAt.call(this, t);
                    return n[Ui](r, r)
                }
            })
        }),
        e("echarts/util/symbol", [Tr, "./graphic", Me],
        function(t) {
            var e = t("./graphic"),
            i = t(Me),
            n = e.extendShape({
                type: "triangle",
                shape: {
                    cx: 0,
                    cy: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function(t, e) {
                    var i = e.cx,
                    n = e.cy,
                    r = e.width / 2,
                    a = e[nr] / 2;
                    t[p](i, n - a),
                    t[d](i + r, n + a),
                    t[d](i - r, n + a),
                    t[h]()
                }
            }),
            r = e.extendShape({
                type: "diamond",
                shape: {
                    cx: 0,
                    cy: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function(t, e) {
                    var i = e.cx,
                    n = e.cy,
                    r = e.width / 2,
                    a = e[nr] / 2;
                    t[p](i, n - a),
                    t[d](i + r, n),
                    t[d](i, n + a),
                    t[d](i - r, n),
                    t[h]()
                }
            }),
            a = e.extendShape({
                type: "pin",
                shape: {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function(t, e) {
                    var i = e.x,
                    n = e.y,
                    r = e.width / 5 * 3,
                    a = Math.max(r, e[nr]),
                    o = r / 2,
                    s = o * o / (a - o),
                    l = n - a + o + s,
                    u = Math.asin(s / o),
                    c = Math.cos(u) * o,
                    d = Math.sin(u),
                    p = Math.cos(u);
                    t.arc(i, l, o, Math.PI - u, 2 * Math.PI + u);
                    var v = .6 * o,
                    g = .7 * o;
                    t[f](i + c - d * v, l + s + p * v, i, n - g, i, n),
                    t[f](i, n - g, i - c + d * v, l + s + p * v, i - c, l + s),
                    t[h]()
                }
            }),
            o = e.extendShape({
                type: "arrow",
                shape: {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function(t, e) {
                    var i = e[nr],
                    n = e.width,
                    r = e.x,
                    a = e.y,
                    o = n / 3 * 2;
                    t[p](r, a),
                    t[d](r + o, a + i),
                    t[d](r, a + i / 4 * 3),
                    t[d](r - o, a + i),
                    t[d](r, a),
                    t[h]()
                }
            }),
            s = {
                line: e.Line,
                rect: e.Rect,
                roundRect: e.Rect,
                square: e.Rect,
                circle: e[be],
                diamond: r,
                pin: a,
                arrow: o,
                triangle: n
            },
            l = {
                line: function(t, e, i, n, r) {
                    r.x1 = t,
                    r.y1 = e + n / 2,
                    r.x2 = t + i,
                    r.y2 = e + n / 2
                },
                rect: function(t, e, i, n, r) {
                    r.x = t,
                    r.y = e,
                    r.width = i,
                    r[nr] = n
                },
                roundRect: function(t, e, i, n, r) {
                    r.x = t,
                    r.y = e,
                    r.width = i,
                    r[nr] = n,
                    r.r = Math.min(i, n) / 4
                },
                square: function(t, e, i, n, r) {
                    var a = Math.min(i, n);
                    r.x = t,
                    r.y = e,
                    r.width = a,
                    r[nr] = a
                },
                circle: function(t, e, i, n, r) {
                    r.cx = t + i / 2,
                    r.cy = e + n / 2,
                    r.r = Math.min(i, n) / 2
                },
                diamond: function(t, e, i, n, r) {
                    r.cx = t + i / 2,
                    r.cy = e + n / 2,
                    r.width = i,
                    r[nr] = n
                },
                pin: function(t, e, i, n, r) {
                    r.x = t + i / 2,
                    r.y = e + n / 2,
                    r.width = i,
                    r[nr] = n
                },
                arrow: function(t, e, i, n, r) {
                    r.x = t + i / 2,
                    r.y = e + n / 2,
                    r.width = i,
                    r[nr] = n
                },
                triangle: function(t, e, i, n, r) {
                    r.cx = t + i / 2,
                    r.cy = e + n / 2,
                    r.width = i,
                    r[nr] = n
                }
            },
            u = {};
            for (var c in s) u[c] = new s[c];
            var v = e.extendShape({
                type: "symbol",
                shape: {
                    symbolType: "",
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                beforeBrush: function() {
                    var t = this.style,
                    e = this.shape;
                    "pin" === e.symbolType && t[Z] === mi && (t[Z] = ["50%", "40%"], t[an] = Ji, t.textVerticalAlign = Qi)
                },
                buildPath: function(t, e, i) {
                    var n = e.symbolType,
                    r = u[n];
                    "none" !== e.symbolType && (r || (n = "rect", r = u[n]), l[n](e.x, e.y, e.width, e[nr], r.shape), r.buildPath(t, r.shape, i))
                }
            }),
            g = function(t) {
                if ("image" !== this.type) {
                    var e = this.style,
                    i = this.shape;
                    i && "line" === i.symbolType ? e[ye] = t: this.__isEmptyBrush ? (e[ye] = t, e.fill = "#fff") : (e.fill && (e.fill = t), e[ye] && (e[ye] = t)),
                    this.dirty(!1)
                }
            },
            m = {
                createSymbol: function(t, n, r, a, o, s) {
                    var l = 0 === t[gn]("empty");
                    l && (t = t.substr(5, 1)[_r]() + t.substr(6));
                    var u;
                    return u = 0 === t[gn]("image://") ? new e.Image({
                        style: {
                            image: t.slice(8),
                            x: n,
                            y: r,
                            width: a,
                            height: o
                        }
                    }) : 0 === t[gn]("path://") ? e.makePath(t.slice(7), {},
                    new i(n, r, a, o)) : new v({
                        shape: {
                            symbolType: t,
                            x: n,
                            y: r,
                            width: a,
                            height: o
                        }
                    }),
                    u.__isEmptyBrush = l,
                    u.setColor = g,
                    u.setColor(s),
                    u
                }
            };
            return m
        }),
        e("zrender/Layer", [Tr, "./core/util", "./config", "./graphic/Style", "./graphic/Pattern"],
        function(t) {
            function e() {
                return ! 1
            }
            function i(t, e, i, n) {
                var r = document[Ti](e),
                a = i[dr](),
                o = i[hr](),
                s = r.style;
                return s[$i] = "absolute",
                s.left = 0,
                s.top = 0,
                s.width = a + "px",
                s[nr] = o + "px",
                r.width = a * n,
                r[nr] = o * n,
                r.setAttribute("data-zr-dom-id", t),
                r
            }
            var n = t("./core/util"),
            r = t("./config"),
            a = t("./graphic/Style"),
            o = t("./graphic/Pattern"),
            s = function(t, a, o) {
                var s;
                o = o || r.devicePixelRatio,
                typeof t === yr ? s = i(t, mr, a, o) : n[Yn](t) && (s = t, t = s.id),
                this.id = t,
                this.dom = s;
                var l = s.style;
                l && (s.onselectstart = e, l["-webkit-user-select"] = "none", l["user-select"] = "none", l["-webkit-touch-callout"] = "none", l["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)"),
                this.domBack = null,
                this.ctxBack = null,
                this.painter = a,
                this.config = null,
                this.clearColor = 0,
                this.motionBlur = !1,
                this.lastFrameAlpha = .7,
                this.dpr = o
            };
            return s[xr] = {
                constructor: s,
                elCount: 0,
                __dirty: !0,
                initContext: function() {
                    this.ctx = this.dom.getContext("2d"),
                    this.ctx.dpr = this.dpr
                },
                createBackBuffer: function() {
                    var t = this.dpr;
                    this.domBack = i("back-" + this.id, mr, this.painter, t),
                    this.ctxBack = this.domBack.getContext("2d"),
                    1 != t && this.ctxBack.scale(t, t)
                },
                resize: function(t, e) {
                    var i = this.dpr,
                    n = this.dom,
                    r = n.style,
                    a = this.domBack;
                    r.width = t + "px",
                    r[nr] = e + "px",
                    n.width = t * i,
                    n[nr] = e * i,
                    a && (a.width = t * i, a[nr] = e * i, 1 != i && this.ctxBack.scale(i, i))
                },
                clear: function(t) {
                    var e = this.dom,
                    i = this.ctx,
                    n = e.width,
                    r = e[nr],
                    s = this.clearColor,
                    l = this.motionBlur && !t,
                    u = this.lastFrameAlpha,
                    c = this.dpr;
                    if (l && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(e, 0, 0, n / c, r / c)), i.clearRect(0, 0, n, r), s) {
                        var h;
                        s.colorStops ? (h = s.__canvasGradient || a.getGradient(i, s, {
                            x: 0,
                            y: 0,
                            width: n,
                            height: r
                        }), s.__canvasGradient = h) : s.image && (h = o[xr].getCanvasPattern.call(s, i)),
                        i.save(),
                        i.fillStyle = h || s,
                        i.fillRect(0, 0, n, r),
                        i.restore()
                    }
                    if (l) {
                        var d = this.domBack;
                        i.save(),
                        i.globalAlpha = u,
                        i.drawImage(d, 0, 0, n, r),
                        i.restore()
                    }
                }
            },
            s
        }),
        e("echarts/preprocessor/helper/compatStyle", [Tr, Ar],
        function(t) {
            function e(t) {
                var e = t && t[li];
                e && i.each(n,
                function(n) {
                    var r = e[ki],
                    a = e[Li];
                    r && r[n] && (t[n] = t[n] || {},
                    t[n][ki] ? i.merge(t[n][ki], r[n]) : t[n][ki] = r[n], r[n] = null),
                    a && a[n] && (t[n] = t[n] || {},
                    t[n][Li] ? i.merge(t[n][Li], a[n]) : t[n][Li] = a[n], a[n] = null)
                })
            }
            var i = t(Ar),
            n = ["areaStyle", Ke, "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
            return function(t) {
                if (t) {
                    e(t),
                    e(t.markPoint),
                    e(t.markLine);
                    var n = t.data;
                    if (n) {
                        for (var r = 0; r < n[Wn]; r++) e(n[r]);
                        var a = t.markPoint;
                        if (a && a.data) for (var o = a.data,
                        r = 0; r < o[Wn]; r++) e(o[r]);
                        var s = t.markLine;
                        if (s && s.data) for (var l = s.data,
                        r = 0; r < l[Wn]; r++) i[An](l[r]) ? (e(l[r][0]), e(l[r][1])) : e(l[r])
                    }
                }
            }
        }),
        e("echarts/component/axis/AxisView", [Tr, Ar, Si, "./AxisBuilder", Ei],
        function(t) {
            function e(t, e) {
                function i(t) {
                    var e = n[J](t);
                    return e[U](e[B](0))
                }
                var n = t[ln],
                r = e.axis,
                a = {},
                s = r[$i],
                l = r.onZero ? "onZero": s,
                u = r.dim,
                c = n[un](),
                h = [c.x, c.x + c.width, c.y, c.y + c[nr]],
                d = e.get("offset") || 0,
                f = {
                    x: {
                        top: h[2] - d,
                        bottom: h[3] + d
                    },
                    y: {
                        left: h[0] - d,
                        right: h[1] + d
                    }
                };
                f.x.onZero = Math.max(Math.min(i("y"), f.x[rr]), f.x.top),
                f.y.onZero = Math.max(Math.min(i("x"), f.y.right), f.y.left),
                a[$i] = ["y" === u ? f.y[l] : h[0], "x" === u ? f.x[l] : h[3]],
                a[ni] = Math.PI / 2 * ("x" === u ? 0 : 1);
                var p = {
                    top: -1,
                    bottom: 1,
                    left: -1,
                    right: 1
                };
                a.labelDirection = a.tickDirection = a.nameDirection = p[s],
                r.onZero && (a.labelOffset = f[u][s] - f[u].onZero),
                e[fr](m).get(mi) && (a.tickDirection = -a.tickDirection),
                e[fr](g).get(mi) && (a.labelDirection = -a.labelDirection);
                var v = e[fr](g).get(o);
                return a.labelRotation = "top" === l ? -v: v,
                a.labelInterval = r.getLabelInterval(),
                a.z2 = 1,
                a
            }
            var i = t(Ar),
            n = t(Si),
            r = t("./AxisBuilder"),
            a = r.ifIgnoreOnTick,
            s = r.getInterval,
            l = [x, g, m, u],
            c = ["splitArea", y],
            h = t(Ei)[_n]({
                type: "axis",
                render: function(t) {
                    this.group[cn]();
                    var a = this._axisGroup;
                    if (this._axisGroup = new n.Group, this.group.add(this._axisGroup), t.get("show")) {
                        var o = t.findGridModel(),
                        s = e(o, t),
                        u = new r(t, s);
                        i.each(l, u.add, u),
                        this._axisGroup.add(u.getGroup()),
                        i.each(c,
                        function(e) {
                            t.get(e + ".show") && this["_" + e](t, o, s.labelInterval)
                        },
                        this),
                        n.groupTransition(a, this._axisGroup, t)
                    }
                },
                _splitLine: function(t, e, r) {
                    var o = t.axis,
                    l = t[fr](y),
                    u = l[fr](Ke),
                    c = u.get("color"),
                    h = s(l, r);
                    c = i[An](c) ? c: [c];
                    for (var d = e[ln][un](), f = o[K](), p = 0, v = o.getTicksCoords(), g = o.scale[qi](), m = [], x = [], _ = u[ti](), w = 0; w < v[Wn]; w++) if (!a(o, w, h)) {
                        var b = o[U](v[w]);
                        f ? (m[0] = b, m[1] = d.y, x[0] = b, x[1] = d.y + d[nr]) : (m[0] = d.x, m[1] = b, x[0] = d.x + d.width, x[1] = b);
                        var M = p++%c[Wn];
                        this._axisGroup.add(new n.Line(n.subPixelOptimizeLine({
                            anid: "line_" + g[w],
                            shape: {
                                x1: m[0],
                                y1: m[1],
                                x2: x[0],
                                y2: x[1]
                            },
                            style: i[qn]({
                                stroke: c[M]
                            },
                            _),
                            silent: !0
                        })))
                    }
                },
                _splitArea: function(t, e, r) {
                    var o = t.axis,
                    l = t[fr]("splitArea"),
                    u = l[fr]("areaStyle"),
                    c = u.get("color"),
                    h = e[ln][un](),
                    d = o.getTicksCoords(),
                    f = o.scale[qi](),
                    p = o[U](d[0]),
                    v = o[U](d[0]),
                    g = 0,
                    m = s(l, r),
                    y = u[V]();
                    c = i[An](c) ? c: [c];
                    for (var x = 1; x < d[Wn]; x++) if (!a(o, x, m)) {
                        var _, w, b, M, S = o[U](d[x]);
                        o[K]() ? (_ = p, w = h.y, b = S - _, M = h[nr]) : (_ = h.x, w = v, b = h.width, M = S - w);
                        var A = g++%c[Wn];
                        this._axisGroup.add(new n.Rect({
                            anid: "area_" + f[x],
                            shape: {
                                x: _,
                                y: w,
                                width: b,
                                height: M
                            },
                            style: i[qn]({
                                fill: c[A]
                            },
                            y),
                            silent: !0
                        })),
                        p = _ + b,
                        v = w + M
                    }
                }
            });
            h[jn]({
                type: "xAxis"
            }),
            h[jn]({
                type: "yAxis"
            })
        }),
        e("echarts/chart/helper/SymbolDraw", [Tr, Si, "./Symbol"],
        function(t) {
            function e(t) {
                this.group = new n.Group,
                this._symbolCtor = t || r
            }
            function i(t, e, i) {
                var n = t[bi](e);
                return ! (!n || isNaN(n[0]) || isNaN(n[1]) || i && i(e) || "none" === t[gi](e, se))
            }
            var n = t(Si),
            r = t("./Symbol"),
            a = e[xr];
            return a[yi] = function(t, e) {
                var r = this.group,
                a = t[fi],
                o = this._data,
                s = this._symbolCtor,
                l = {
                    itemStyle: a[fr](F)[sn](["color"]),
                    hoverItemStyle: a[fr](H)[sn](),
                    symbolRotate: a.get("symbolRotate"),
                    symbolOffset: a.get("symbolOffset"),
                    hoverAnimation: a.get("hoverAnimation"),
                    labelModel: a[fr](ii),
                    hoverLabelModel: a[fr](ei)
                };
                t.diff(o).add(function(n) {
                    var a = t[bi](n);
                    if (i(t, n, e)) {
                        var o = new s(t, n, l);
                        o.attr($i, a),
                        t[$e](n, o),
                        r.add(o)
                    }
                })[er](function(u, c) {
                    var h = o[Mi](c),
                    d = t[bi](u);
                    return i(t, u, e) ? (h ? (h[yi](t, u, l), n[ui](h, {
                        position: d
                    },
                    a)) : (h = new s(t, u), h.attr($i, d)), r.add(h), void t[$e](u, h)) : void r[Xn](h)
                })[Xn](function(t) {
                    var e = o[Mi](t);
                    e && e.fadeOut(function() {
                        r[Xn](e)
                    })
                })[Qe](),
                this._data = t
            },
            a[Qn] = function() {
                var t = this._data;
                t && t[Se](function(e, i) {
                    var n = t[bi](i);
                    e.attr($i, n)
                })
            },
            a[Xn] = function(t) {
                var e = this.group,
                i = this._data;
                i && (t ? i[Se](function(t) {
                    t.fadeOut(function() {
                        e[Xn](t)
                    })
                }) : e[cn]())
            },
            e
        }),
        e("echarts/chart/line/lineAnimationDiff", [Tr],
        function() {
            function t(t) {
                return t >= 0 ? 1 : -1
            }
            function e(e, i, n) {
                for (var r, a = e[Ie](), o = e.getOtherAxis(a), s = a.onZero ? 0 : o.scale[Fi]()[0], l = o.dim, u = "x" === l || l === Ze ? 1 : 0, c = i.stackedOn, h = i.get(l, n); c && t(c.get(l, n)) === t(h);) {
                    r = c;
                    break
                }
                var d = [];
                return d[u] = i.get(a.dim, n),
                d[1 - u] = r ? r.get(l, n, !0) : s,
                e[ae](d)
            }
            function i(t, e) {
                var i = [];
                return e.diff(t).add(function(t) {
                    i.push({
                        cmd: "+",
                        idx: t
                    })
                })[er](function(t, e) {
                    i.push({
                        cmd: "=",
                        idx: e,
                        idx1: t
                    })
                })[Xn](function(t) {
                    i.push({
                        cmd: "-",
                        idx: t
                    })
                })[Qe](),
                i
            }
            return function(t, n, r, a, o, s) {
                for (var l = i(t, n), u = [], c = [], h = [], d = [], f = [], p = [], v = [], g = s[de], m = 0; m < l[Wn]; m++) {
                    var y = l[m],
                    x = !0;
                    switch (y.cmd) {
                    case "=":
                        var _ = t[bi](y.idx),
                        w = n[bi](y.idx1); (isNaN(_[0]) || isNaN(_[1])) && (_ = w.slice()),
                        u.push(_),
                        c.push(w),
                        h.push(r[y.idx]),
                        d.push(a[y.idx1]),
                        v.push(n[je](y.idx1));
                        break;
                    case "+":
                        var b = y.idx;
                        u.push(o[ae]([n.get(g[0], b, !0), n.get(g[1], b, !0)])),
                        c.push(n[bi](b).slice()),
                        h.push(e(o, n, b)),
                        d.push(a[b]),
                        v.push(n[je](b));
                        break;
                    case "-":
                        var b = y.idx,
                        M = t[je](b);
                        M !== b ? (u.push(t[bi](b)), c.push(s[ae]([t.get(g[0], b, !0), t.get(g[1], b, !0)])), h.push(r[b]), d.push(e(s, t, b)), v.push(M)) : x = !1
                    }
                    x && (f.push(y), p.push(p[Wn]))
                }
                p.sort(function(t, e) {
                    return v[t] - v[e]
                });
                for (var S = [], A = [], T = [], C = [], L = [], m = 0; m < p[Wn]; m++) {
                    var b = p[m];
                    S[m] = u[b],
                    A[m] = c[b],
                    T[m] = h[b],
                    C[m] = d[b],
                    L[m] = f[b]
                }
                return {
                    current: S,
                    next: A,
                    stackedOnCurrent: T,
                    stackedOnNext: C,
                    status: L
                }
            }
        }),
        e("echarts/chart/helper/Symbol", [Tr, Ar, I, Si, qe],
        function(t) {
            function e(t) {
                return t instanceof Array || (t = [ + t, +t]),
                t
            }
            function i(t, e, i) {
                o.Group.call(this),
                this[yi](t, e, i)
            }
            function n(t, e) {
                this[pe].drift(t, e)
            }
            var r = t(Ar),
            a = t(I),
            o = t(Si),
            s = t(qe),
            l = i[xr];
            l._createSymbol = function(t, i, r) {
                this[cn]();
                var s = i[fi],
                l = i[gi](r, "color"),
                u = a[P](t, -.5, -.5, 1, 1, l);
                u.attr({
                    z2: 100,
                    culling: !0,
                    scale: [0, 0]
                }),
                u.drift = n;
                var c = e(i[gi](r, oe));
                o[Xe](u, {
                    scale: c
                },
                s, r),
                this._symbolType = t,
                this.add(u)
            },
            l.stopSymbolAnimation = function(t) {
                this[di](0)[sr](t)
            },
            l.getSymbolPath = function() {
                return this[di](0)
            },
            l.getScale = function() {
                return this[di](0).scale
            },
            l[Jn] = function() {
                this[di](0)[Zn](Li)
            },
            l[$n] = function() {
                this[di](0)[Zn](ki)
            },
            l.setZ = function(t, e) {
                var i = this[di](0);
                i[Cn] = t,
                i.z = e
            },
            l.setDraggable = function(t) {
                var e = this[di](0);
                e[L] = t,
                e.cursor = t ? "move": "pointer"
            },
            l[yi] = function(t, i, n) {
                this[Nn] = !1;
                var r = t[gi](i, se) || fn,
                a = t[fi],
                s = e(t[gi](i, oe));
                if (r !== this._symbolType) this._createSymbol(r, t, i);
                else {
                    var l = this[di](0);
                    o[ui](l, {
                        scale: s
                    },
                    a, i)
                }
                this._updateCommon(t, i, s, n),
                this._seriesModel = a
            };
            var u = [li, ki],
            c = [li, Li],
            h = ["label", ki],
            d = ["label", Li];
            return l._updateCommon = function(t, i, n, a) {
                var l = this[di](0),
                f = t[fi],
                p = t[gi](i, "color");
                "image" !== l.type && l[si]({
                    strokeNoScale: !0
                }),
                a = a || null;
                var v = a && a[li],
                g = a && a.hoverItemStyle,
                m = a && a.symbolRotate,
                y = a && a.symbolOffset,
                x = a && a.labelModel,
                _ = a && a.hoverLabelModel,
                w = a && a.hoverAnimation;
                if (!a || t[fe]) {
                    var b = t[hi](i);
                    v = b[fr](u)[sn](["color"]),
                    g = b[fr](c)[sn](),
                    m = b[Ce]("symbolRotate"),
                    y = b[Ce]("symbolOffset"),
                    x = b[fr](h),
                    _ = b[fr](d),
                    w = b[Ce]("hoverAnimation")
                } else g = r[jn]({},
                g);
                var M = l.style;
                l[ni] = (m || 0) * Math.PI / 180 || 0,
                y && l.attr($i, [s[We](y[0], n[0]), s[We](y[1], n[1])]),
                l.setColor(p),
                l[Ln](v);
                var S = t[gi](i, Yi);
                null != S && (M[Yi] = S);
                for (var A, T, C = t[de].slice(); C[Wn] && (A = C.pop(), T = t.getDimensionInfo(A).type, T === Pe || "time" === T););
                null != A && x[Ce]("show") ? (o[me](M, x, p), M.text = r[vi](f[pi](i, ki), t.get(A, i))) : M.text = "",
                null != A && _[Ce]("show") ? (o[me](g, _, p), g.text = r[vi](f[pi](i, Li), t.get(A, i))) : g.text = "";
                var L = e(t[gi](i, oe));
                if (l.off(En).off(On).off(Li).off(ki), l[oi] = g, o[ri](l), w && f.ifEnableAnimation()) {
                    var k = function() {
                        var t = L[1] / L[0];
                        this.animateTo({
                            scale: [Math.max(1.1 * L[0], L[0] + 3), Math.max(1.1 * L[1], L[1] + 3 * t)]
                        },
                        400, "elasticOut")
                    },
                    P = function() {
                        this.animateTo({
                            scale: L
                        },
                        400, "elasticOut")
                    };
                    l.on(En, k).on(On, P).on(Li, k).on(ki, P)
                }
            },
            l.fadeOut = function(t) {
                var e = this[di](0);
                this[Nn] = !0,
                e.style.text = "",
                o[ui](e, {
                    scale: [0, 0]
                },
                this._seriesModel, this[zn], t)
            },
            r[vn](i, o.Group),
            i
        }),
        e("echarts/chart/line/poly", [Tr, "zrender/graphic/Path", wr],
        function(t) {
            function e(t) {
                return isNaN(t[0]) || isNaN(t[1])
            }
            function i(t, i, n, r, h, m, y, x, _, w, b) {
                for (var M = 0,
                S = n,
                A = 0; r > A; A++) {
                    var T = i[S];
                    if (S >= h || 0 > S) break;
                    if (e(T)) {
                        if (b) {
                            S += m;
                            continue
                        }
                        break
                    }
                    if (S === n) t[m > 0 ? p: d](T[0], T[1]),
                    u(v, T);
                    else if (_ > 0) {
                        var C = S + m,
                        L = i[C];
                        if (b) for (; L && e(i[C]);) C += m,
                        L = i[C];
                        var k = .5,
                        P = i[M],
                        L = i[C];
                        if (!L || e(L)) u(g, T);
                        else {
                            e(L) && !b && (L = T),
                            a.sub(c, L, P);
                            var I, D;
                            if ("x" === w || "y" === w) {
                                var z = "x" === w ? 0 : 1;
                                I = Math.abs(T[z] - P[z]),
                                D = Math.abs(T[z] - L[z])
                            } else I = a.dist(T, P),
                            D = a.dist(T, L);
                            k = D / (D + I),
                            l(g, T, c, -_ * (1 - k))
                        }
                        o(v, v, x),
                        s(v, v, y),
                        o(g, g, x),
                        s(g, g, y),
                        t[f](v[0], v[1], g[0], g[1], T[0], T[1]),
                        l(v, T, c, _ * k)
                    } else t[d](T[0], T[1]);
                    M = S,
                    S += m
                }
                return A
            }
            function n(t, e) {
                var i = [1 / 0, 1 / 0],
                n = [ - 1 / 0, -1 / 0];
                if (e) for (var r = 0; r < t[Wn]; r++) {
                    var a = t[r];
                    a[0] < i[0] && (i[0] = a[0]),
                    a[1] < i[1] && (i[1] = a[1]),
                    a[0] > n[0] && (n[0] = a[0]),
                    a[1] > n[1] && (n[1] = a[1])
                }
                return {
                    min: e ? i: n,
                    max: e ? n: i
                }
            }
            var r = t("zrender/graphic/Path"),
            a = t(wr),
            o = a.min,
            s = a.max,
            l = a.scaleAndAdd,
            u = a.copy,
            c = [],
            v = [],
            g = [];
            return {
                Polyline: r[jn]({
                    type: "ec-polyline",
                    shape: {
                        points: [],
                        smooth: 0,
                        smoothConstraint: !0,
                        smoothMonotone: null,
                        connectNulls: !1
                    },
                    style: {
                        fill: null,
                        stroke: "#000"
                    },
                    buildPath: function(t, r) {
                        var a = r[z],
                        o = 0,
                        s = a[Wn],
                        l = n(a, r.smoothConstraint);
                        if (r.connectNulls) {
                            for (; s > 0 && e(a[s - 1]); s--);
                            for (; s > o && e(a[o]); o++);
                        }
                        for (; s > o;) o += i(t, a, o, s, s, 1, l.min, l.max, r.smooth, r.smoothMonotone, r.connectNulls) + 1
                    }
                }),
                Polygon: r[jn]({
                    type: "ec-polygon",
                    shape: {
                        points: [],
                        stackedOnPoints: [],
                        smooth: 0,
                        stackedOnSmooth: 0,
                        smoothConstraint: !0,
                        smoothMonotone: null,
                        connectNulls: !1
                    },
                    buildPath: function(t, r) {
                        var a = r[z],
                        o = r.stackedOnPoints,
                        s = 0,
                        l = a[Wn],
                        u = r.smoothMonotone,
                        c = n(a, r.smoothConstraint),
                        d = n(o, r.smoothConstraint);
                        if (r.connectNulls) {
                            for (; l > 0 && e(a[l - 1]); l--);
                            for (; l > s && e(a[s]); s++);
                        }
                        for (; l > s;) {
                            var f = i(t, a, s, l, l, 1, c.min, c.max, r.smooth, u, r.connectNulls);
                            i(t, o, s + f - 1, f, l, -1, d.min, d.max, r.stackedOnSmooth, u, r.connectNulls),
                            s += f + 1,
                            t[h]()
                        }
                    }
                })
            }
        }),
        e("echarts/chart/pie/labelLayout", [Tr, "zrender/contain/text"],
        function(t) {
            function e(t, e, i, n, r, a, o) {
                function s(e, i, n) {
                    for (var r = e; i > r; r++) if (t[r].y += n, r > e && i > r + 1 && t[r + 1].y > t[r].y + t[r][nr]) return void l(r, n / 2);
                    l(i - 1, n / 2)
                }
                function l(e, i) {
                    for (var n = e; n >= 0 && (t[n].y -= i, !(n > 0 && t[n].y > t[n - 1].y + t[n - 1][nr])); n--);
                }
                function u(t, e, i, n, r, a) {
                    for (var o = a > 0 ? e ? Number.MAX_VALUE: 0 : e ? Number.MAX_VALUE: 0, s = 0, l = t[Wn]; l > s; s++) if (t[s][$i] !== Ji) {
                        var u = Math.abs(t[s].y - n),
                        c = t[s].len,
                        h = t[s].len2,
                        d = r + c > u ? Math.sqrt((r + c + h) * (r + c + h) - u * u) : Math.abs(t[s].x - i);
                        e && d >= o && (d = o - 10),
                        !e && o >= d && (d = o + 10),
                        t[s].x = i + d * a,
                        o = d
                    }
                }
                t.sort(function(t, e) {
                    return t.y - e.y
                });
                for (var c, h = 0,
                d = t[Wn], f = [], p = [], v = 0; d > v; v++) c = t[v].y - h,
                0 > c && s(v, d, -c, r),
                h = t[v].y + t[v][nr];
                0 > o - h && l(d - 1, h - o);
                for (var v = 0; d > v; v++) t[v].y >= i ? p.push(t[v]) : f.push(t[v]);
                u(f, !1, e, i, n, r),
                u(p, !0, e, i, n, r)
            }
            function i(t, i, n, r, a, o) {
                for (var s = [], l = [], u = 0; u < t[Wn]; u++) t[u].x < i ? s.push(t[u]) : l.push(t[u]);
                e(l, i, n, r, 1, a, o),
                e(s, i, n, r, -1, a, o);
                for (var u = 0; u < t[Wn]; u++) {
                    var c = t[u].linePoints;
                    if (c) {
                        var h = c[1][0] - c[2][0];
                        c[2][0] = t[u].x < i ? t[u].x + 3 : t[u].x - 3,
                        c[1][1] = c[2][1] = t[u].y,
                        c[1][0] = c[2][0] + h
                    }
                }
            }
            var n = t("zrender/contain/text");
            return function(t, e, r, a) {
                var s, l, u = t[Kn](),
                c = [],
                h = !1;
                u.each(function(i) {
                    var r, a, d, f, p = u[bi](i),
                    v = u[hi](i),
                    g = v[fr](ii),
                    m = g.get($i) || v.get("label.emphasis.position"),
                    y = v[fr]("labelLine.normal"),
                    x = y.get(Wn),
                    _ = y.get("length2"),
                    w = (p.startAngle + p.endAngle) / 2,
                    b = Math.cos(w),
                    M = Math.sin(w);
                    s = p.cx,
                    l = p.cy;
                    var S = m === mi || "inner" === m;
                    if (m === Ji) r = p.cx,
                    a = p.cy,
                    f = Ji;
                    else {
                        var A = (S ? (p.r + p.r0) / 2 * b: p.r * b) + s,
                        T = (S ? (p.r + p.r0) / 2 * M: p.r * M) + l;
                        if (r = A + 3 * b, a = T + 3 * M, !S) {
                            var C = A + b * (x + e - p.r),
                            L = T + M * (x + e - p.r),
                            k = C + (0 > b ? -1 : 1) * _,
                            P = L;
                            r = k + (0 > b ? -5 : 5),
                            a = P,
                            d = [[A, T], [C, L], [k, P]]
                        }
                        f = S ? Ji: b > 0 ? "left": "right"
                    }
                    var I = g[fr](on)[rn](),
                    D = g.get(o) ? 0 > b ? -w + Math.PI: -w: 0,
                    z = t[pi](i, ki) || u[Ci](i),
                    V = n[en](z, I, f, "top");
                    h = !!D,
                    p.label = {
                        x: r,
                        y: a,
                        position: m,
                        height: V[nr],
                        len: x,
                        len2: _,
                        linePoints: d,
                        textAlign: f,
                        verticalAlign: "middle",
                        font: I,
                        rotation: D
                    },
                    S || c.push(p.label)
                }),
                !h && t.get("avoidLabelOverlap") && i(c, s, l, e, r, a)
            }
        }),
        e("echarts/chart/helper/LargeSymbolDraw", [Tr, Si, I],
        function(t) {
            function e() {
                this.group = new i.Group,
                this._symbolEl = new r({})
            }
            var i = t(Si),
            n = t(I),
            r = i.extendShape({
                shape: {
                    points: null,
                    sizes: null
                },
                symbolProxy: null,
                buildPath: function(t, e) {
                    for (var i = e[z], n = e.sizes, r = this.symbolProxy, a = r.shape, o = 0; o < i[Wn]; o++) {
                        var s = i[o],
                        l = n[o];
                        l[0] < 4 ? t.rect(s[0] - l[0] / 2, s[1] - l[1] / 2, l[0], l[1]) : (a.x = s[0] - l[0] / 2, a.y = s[1] - l[1] / 2, a.width = l[0], a[nr] = l[1], r.buildPath(t, a, !0))
                    }
                },
                findDataIndex: function(t, e) {
                    for (var i = this.shape,
                    n = i[z], r = i.sizes, a = n[Wn] - 1; a >= 0; a--) {
                        var o = n[a],
                        s = r[a],
                        l = o[0] - s[0] / 2,
                        u = o[1] - s[1] / 2;
                        if (t >= l && e >= u && t <= l + s[0] && e <= u + s[1]) return a
                    }
                    return - 1
                }
            }),
            a = e[xr];
            return a[yi] = function(t) {
                this.group[cn]();
                var e = this._symbolEl,
                i = t[fi];
                e[ci]({
                    points: t[he](t[bi]),
                    sizes: t[he](function(e) {
                        var i = t[gi](e, oe);
                        return i instanceof Array || (i = [i, i]),
                        i
                    })
                }),
                e.symbolProxy = n[P](t[ce](se), 0, 0, 0, 0),
                e.setColor = e.symbolProxy.setColor,
                e[si](i[fr](F)[sn](["color"]));
                var r = t[ce]("color");
                r && e.setColor(r),
                e[Dn] = i[Dn],
                e.on(Rn,
                function(t) {
                    e[zn] = null;
                    var i = e.findDataIndex(t[w], t[_]);
                    i > 0 && (e[zn] = i)
                }),
                this.group.add(e)
            },
            a[Qn] = function(t) {
                var e = t[Kn]();
                this._symbolEl[ci]({
                    points: e[he](e[bi])
                })
            },
            a[Xn] = function() {
                this.group[cn]()
            },
            e
        }),
        e("echarts/chart/helper/whiskerBoxCommon", [Tr, Gi, Ni, "../helper/WhiskerBoxDraw", Ar],
        function(t) {
            function e(t) {
                return null == t.value ? t: t.value
            }
            var i = t(Gi),
            n = t(Ni),
            r = t("../helper/WhiskerBoxDraw"),
            a = t(Ar),
            o = {
                _baseAxisDim: null,
                getInitialData: function(t, r) {
                    var a, o, l = r[Re]("xAxis", this.get("xAxisIndex")),
                    u = r[Re]("yAxis", this.get("yAxisIndex")),
                    c = l.get("type"),
                    h = u.get("type");
                    c === te ? (t[E] = O, a = l.getCategories(), o = !0) : h === te ? (t[E] = s, a = u.getCategories(), o = !0) : t[E] = t[E] || O,
                    this._baseAxisDim = t[E] === O ? "x": "y";
                    var d = t.data,
                    f = this[de] = ["base"][Ai](this.valueDimensions);
                    n(f, d);
                    var p = new i(f, this);
                    return p[Di](d, a ? a.slice() : null,
                    function(t, i, n, r) {
                        var a = e(t);
                        return o ? "base" === i ? n: a[r - 1] : a[r]
                    }),
                    p
                },
                coordDimToDataDim: function(t) {
                    var e = this.valueDimensions.slice(),
                    i = ["base"],
                    n = {
                        horizontal: {
                            x: i,
                            y: e
                        },
                        vertical: {
                            x: e,
                            y: i
                        }
                    };
                    return n[this.get(E)][t]
                },
                dataDimToCoordDim: function(t) {
                    var e;
                    return a.each(["x", "y"],
                    function(i) {
                        var n = this[j](i);
                        a[gn](n, t) >= 0 && (e = i)
                    },
                    this),
                    e
                },
                getBaseAxis: function() {
                    var t = this._baseAxisDim;
                    return this[Te][Re](t + "Axis", this.get(t + "AxisIndex")).axis
                }
            },
            l = {
                init: function() {
                    var t = this._whiskerBoxDraw = new r(this.getStyleUpdater());
                    this.group.add(t.group)
                },
                render: function(t) {
                    this._whiskerBoxDraw[yi](t[Kn]())
                },
                remove: function() {
                    this._whiskerBoxDraw[Xn]()
                }
            };
            return {
                seriesModelMixin: o,
                viewMixin: l
            }
        }),
        e("echarts/coord/radar/Radar", [Tr, Ar, "./IndicatorAxis", "../../scale/Interval", qe, "../axisHelper", ne],
        function(t) {
            function e(t, e, a) {
                this[pr] = t,
                this[de] = [],
                this._indicatorAxes = i.map(t.getIndicatorModels(),
                function(t, e) {
                    var i = "indicator_" + e,
                    a = new n(i, new r);
                    return a.name = t.get("name"),
                    a.model = t,
                    t.axis = a,
                    this[de].push(i),
                    a
                },
                this),
                this[gr](t, a),
                this.cx,
                this.cy,
                this.r,
                this.startAngle
            }
            var i = t(Ar),
            n = t("./IndicatorAxis"),
            r = t("../../scale/Interval"),
            a = t(qe),
            o = t("../axisHelper");
            return e[xr].getIndicatorAxes = function() {
                return this._indicatorAxes
            },
            e[xr][ae] = function(t, e) {
                var i = this._indicatorAxes[e];
                return this.coordToPoint(i[B](t), e)
            },
            e[xr].coordToPoint = function(t, e) {
                var i = this._indicatorAxes[e],
                n = i.angle,
                r = this.cx + t * Math.cos(n),
                a = this.cy - t * Math.sin(n);
                return [r, a]
            },
            e[xr].pointToData = function(t) {
                var e = t[0] - this.cx,
                i = t[1] - this.cy,
                n = Math.sqrt(e * e + i * i);
                e /= n,
                i /= n;
                for (var r, a = Math.atan2( - i, e), o = 1 / 0, s = -1, l = 0; l < this._indicatorAxes[Wn]; l++) {
                    var u = this._indicatorAxes[l],
                    c = Math.abs(a - u.angle);
                    o > c && (r = u, s = l, o = c)
                }
                return [s, +(r && r.coodToData(n))]
            },
            e[xr][gr] = function(t, e) {
                var n = t.get(Ji),
                r = e[dr](),
                o = e[hr](),
                s = Math.min(r, o) / 2;
                this.cx = a[We](n[0], r),
                this.cy = a[We](n[1], o),
                this.startAngle = t.get("startAngle") * Math.PI / 180,
                this.r = a[We](t.get(Ze), s),
                i.each(this._indicatorAxes,
                function(t, e) {
                    t[Zi](0, this.r);
                    var i = this.startAngle + e * Math.PI * 2 / this._indicatorAxes[Wn];
                    i = Math.atan2(Math.sin(i), Math.cos(i)),
                    t.angle = i
                },
                this)
            },
            e[xr][er] = function(t) {
                function e(t) {
                    var e = Math.pow(10, Math.floor(Math.log(t) / Math.LN10)),
                    i = t / e;
                    return 2 === i ? i = 5 : i *= 2,
                    i * e
                }
                var n = this._indicatorAxes,
                r = this[pr];
                i.each(n,
                function(t) {
                    t.scale[Zi](1 / 0, -1 / 0)
                }),
                t[dn]("radar",
                function(e) {
                    if ("radar" === e.get(ln) && t[Re]("radar", e.get("radarIndex")) === r) {
                        var a = e[Kn]();
                        i.each(n,
                        function(t) {
                            t.scale[Hi](a[Fe](t.dim))
                        })
                    }
                },
                this);
                var s = r.get("splitNumber");
                i.each(n,
                function(t) {
                    var i = o.getScaleExtent(t, t.model);
                    o[ie](t, t.model);
                    var n = t.model,
                    r = t.scale,
                    l = n.get("min"),
                    u = n.get("max"),
                    c = r.getInterval();
                    if (null != l && null != u) r.setInterval((u - l) / s);
                    else if (null != l) {
                        var h;
                        do h = l + c * s,
                        r[Zi]( + l, h),
                        r.setInterval(c),
                        c = e(c);
                        while (h < i[1] && isFinite(h) && isFinite(i[1]))
                    } else if (null != u) {
                        var d;
                        do d = u - c * s,
                        r[Zi](d, +u),
                        r.setInterval(c),
                        c = e(c);
                        while (d > i[0] && isFinite(d) && isFinite(i[0]))
                    } else {
                        var f = r[qi]()[Wn] - 1;
                        f > s && (c = e(c));
                        var p = Math.round((i[0] + i[1]) / 2 / c) * c,
                        v = Math.round(s / 2);
                        r[Zi](a.round(p - v * c), a.round(p + (s - v) * c)),
                        r.setInterval(c)
                    }
                })
            },
            e[de] = [],
            e[ir] = function(t, i) {
                var n = [];
                return t[or]("radar",
                function(r) {
                    var a = new e(r, t, i);
                    n.push(a),
                    r[ln] = a
                }),
                t[dn]("radar",
                function(t) {
                    "radar" === t.get(ln) && (t[ln] = n[t.get("radarIndex") || 0])
                }),
                n
            },
            t(ne)[bn]("radar", e),
            e
        }),
        e("echarts/coord/radar/RadarModel", [Tr, "../axisDefault", W, Ar, "../axisModelCommonMixin", Ei],
        function(t) {
            function e(t, e) {
                return a[qn]({
                    show: e
                },
                t)
            }
            var i = t("../axisDefault"),
            n = i.valueAxis,
            r = t(W),
            a = t(Ar),
            o = t("../axisModelCommonMixin"),
            s = t(Ei)[wn]({
                type: "radar",
                optionUpdated: function() {
                    var t = this.get(X),
                    e = this.get("splitNumber"),
                    i = this.get("scale"),
                    n = this.get(x),
                    s = this.get(m),
                    l = this.get(g),
                    u = this.get("name.textStyle"),
                    c = this.get("name.show"),
                    h = this.get("name.formatter"),
                    d = this.get("nameGap"),
                    f = a.map(this.get("indicator") || [],
                    function(f) {
                        return null != f.max && f.max > 0 && !f.min ? f.min = 0 : null != f.min && f.min < 0 && !f.max && (f.max = 0),
                        f = a.merge(a.clone(f), {
                            boundaryGap: t,
                            splitNumber: e,
                            scale: i,
                            axisLine: n,
                            axisTick: s,
                            axisLabel: l,
                            name: f.text,
                            nameLocation: "end",
                            nameGap: d,
                            nameTextStyle: u
                        },
                        !1),
                        c || (f.name = ""),
                        typeof h === yr ? f.name = h[Tn]("{value}", f.name) : typeof h === Sn && (f.name = h(f.name, f)),
                        a[jn](new r(f, null, this[Te]), o)
                    },
                    this);
                    this.getIndicatorModels = function() {
                        return f
                    }
                },
                defaultOption: {
                    zlevel: 0,
                    z: 0,
                    center: ["50%", "50%"],
                    radius: "75%",
                    startAngle: 90,
                    name: {
                        show: !0
                    },
                    boundaryGap: [0, 0],
                    splitNumber: 5,
                    nameGap: 15,
                    scale: !1,
                    shape: "polygon",
                    axisLine: a.merge({
                        lineStyle: {
                            color: "#bbb"
                        }
                    },
                    n[x]),
                    axisLabel: e(n[g], !1),
                    axisTick: e(n[m], !1),
                    splitLine: e(n[y], !0),
                    splitArea: e(n.splitArea, !0),
                    indicator: []
                }
            });
            return s
        }),
        e("echarts/component/radar/RadarView", [Tr, "../axis/AxisBuilder", Ar, Si, Ei],
        function(t) {
            var e = t("../axis/AxisBuilder"),
            i = t(Ar),
            n = t(Si),
            r = [x, g, m, u];
            return t(Ei)[_n]({
                type: "radar",
                render: function(t) {
                    var e = this.group;
                    e[cn](),
                    this._buildAxes(t),
                    this._buildSplitLineAndArea(t)
                },
                _buildAxes: function(t) {
                    var n = t[ln],
                    a = n.getIndicatorAxes(),
                    o = i.map(a,
                    function(t) {
                        var i = new e(t.model, {
                            position: [n.cx, n.cy],
                            rotation: t.angle,
                            labelDirection: -1,
                            tickDirection: -1,
                            nameDirection: 1
                        });
                        return i
                    });
                    i.each(o,
                    function(t) {
                        i.each(r, t.add, t),
                        this.group.add(t.getGroup())
                    },
                    this)
                },
                _buildSplitLineAndArea: function(t) {
                    function e(t, e, i) {
                        var n = i % e[Wn];
                        return t[n] = t[n] || [],
                        n
                    }
                    var r = t[ln],
                    a = t.get("splitNumber"),
                    o = r.getIndicatorAxes();
                    if (o[Wn]) {
                        var s = t.get("shape"),
                        l = t[fr](y),
                        u = t[fr]("splitArea"),
                        c = l[fr](Ke),
                        h = u[fr]("areaStyle"),
                        d = l.get("show"),
                        f = u.get("show"),
                        p = c.get("color"),
                        v = h.get("color");
                        p = i[An](p) ? p: [p],
                        v = i[An](v) ? v: [v];
                        var g = [],
                        m = [];
                        if (s === fn) for (var x = o[0].getTicksCoords(), _ = r.cx, w = r.cy, b = 0; b < x[Wn]; b++) {
                            if (d) {
                                var M = e(g, p, b);
                                g[M].push(new n[be]({
                                    shape: {
                                        cx: _,
                                        cy: w,
                                        r: x[b]
                                    }
                                }))
                            }
                            if (f && b < x[Wn] - 1) {
                                var M = e(m, v, b);
                                m[M].push(new n.Ring({
                                    shape: {
                                        cx: _,
                                        cy: w,
                                        r0: x[b],
                                        r: x[b + 1]
                                    }
                                }))
                            }
                        } else for (var A = i.map(o,
                        function(t, e) {
                            var n = t.getTicksCoords();
                            return i.map(n,
                            function(t) {
                                return r.coordToPoint(t, e)
                            })
                        }), T = [], b = 0; a >= b; b++) {
                            for (var C = [], L = 0; L < o[Wn]; L++) C.push(A[L][b]);
                            if (C[0] && C.push(C[0].slice()), d) {
                                var M = e(g, p, b);
                                g[M].push(new n[xi]({
                                    shape: {
                                        points: C
                                    }
                                }))
                            }
                            if (f && T) {
                                var M = e(m, v, b - 1);
                                m[M].push(new n[we]({
                                    shape: {
                                        points: C[Ai](T)
                                    }
                                }))
                            }
                            T = C.slice()[S]()
                        }
                        var k = c[ti](),
                        P = h[V]();
                        i.each(m,
                        function(t, e) {
                            this.group.add(n.mergePath(t, {
                                style: i[qn]({
                                    stroke: "none",
                                    fill: v[e % v[Wn]]
                                },
                                P),
                                silent: !0
                            }))
                        },
                        this),
                        i.each(g,
                        function(t, e) {
                            this.group.add(n.mergePath(t, {
                                style: i[qn]({
                                    fill: "none",
                                    stroke: p[e % p[Wn]]
                                },
                                k),
                                silent: !0
                            }))
                        },
                        this)
                    }
                }
            })
        }),
        e("echarts/component/helper/MapDraw", [Tr, "./RoamController", Si, Ar],
        function(t) {
            function e(t) {
                var e = t[sn](),
                i = t.get("areaColor");
                return i && (e.fill = i),
                e
            }
            function i(t, e, i, r) {
                e.off("click"),
                t.get("selectedMode") && e.on("click",
                function(a) {
                    for (var o = a[Vn]; ! o.__region;) o = o[pe];
                    if (o) {
                        var s = o.__region,
                        l = {
                            type: ("geo" === t[Ne] ? "geo": "map") + "ToggleSelect",
                            name: s.name,
                            from: r.uid
                        };
                        l[t[Ne] + "Id"] = t.id,
                        i[Un](l),
                        n(t, e)
                    }
                })
            }
            function n(t, e) {
                e[Je](function(e) {
                    e.__region && e[Zn](t.isSelected(e.__region.name) ? Li: ki)
                })
            }
            function r(t, e) {
                var i = new o.Group;
                this._controller = new a(t.getZr(), e ? i: null, null),
                this.group = i,
                this._updateGroup = e
            }
            var a = t("./RoamController"),
            o = t(Si),
            s = t(Ar);
            return r[xr] = {
                constructor: r,
                draw: function(t, r, a, l, u) {
                    var c = t[Kn] && t[Kn](),
                    h = t[ln],
                    d = this.group,
                    f = h.scale,
                    p = {
                        position: h[$i],
                        scale: f
                    }; ! d[di](0) || u ? d.attr(p) : o[ui](d, p, t),
                    d[cn]();
                    var v = [li, ki],
                    g = [li, Li],
                    m = ["label", ki],
                    y = ["label", Li];
                    s.each(h.regions,
                    function(i) {
                        var n = new o.Group,
                        r = new o.CompoundPath({
                            shape: {
                                paths: []
                            }
                        });
                        n.add(r);
                        var a, l = t.getRegionModel(i.name) || t,
                        u = l[fr](v),
                        h = l[fr](g),
                        p = e(u, f),
                        x = e(h, f),
                        _ = l[fr](m),
                        w = l[fr](y);
                        if (c) {
                            a = c[Ae](i.name);
                            var b = c[gi](a, "color", !0);
                            b && (p.fill = b)
                        }
                        var M = _[fr](on),
                        S = w[fr](on);
                        s.each(i.contours,
                        function(t) {
                            var e = new o[we]({
                                shape: {
                                    points: t
                                }
                            });
                            r.shape.paths.push(e)
                        }),
                        r[Ln](p),
                        r.style.strokeNoScale = !0,
                        r.culling = !0;
                        var A = _.get("show"),
                        T = w.get("show"),
                        C = c && isNaN(c.get("value", a)),
                        L = c && c[bi](a);
                        if (!c || C && (A || T) || L && L.showLabel) {
                            var k = c ? a: i.name,
                            P = t[pi](k, ki),
                            I = t[pi](k, Li),
                            D = new o.Text({
                                style: {
                                    text: A ? P || i.name: "",
                                    fill: M[nn](),
                                    textFont: M[rn](),
                                    textAlign: "center",
                                    textVerticalAlign: "middle"
                                },
                                hoverStyle: {
                                    text: T ? I || i.name: "",
                                    fill: S[nn](),
                                    textFont: S[rn]()
                                },
                                position: i[Ji].slice(),
                                scale: [1 / f[0], 1 / f[1]],
                                z2: 10,
                                silent: !0
                            });
                            n.add(D)
                        }
                        if (c) c[$e](a, n);
                        else {
                            var l = t.getRegionModel(i.name);
                            r.eventData = {
                                componentType: "geo",
                                geoIndex: t[Oe],
                                name: i.name,
                                region: l && l[zi] || {}
                            }
                        }
                        n.__region = i,
                        o[ri](n, x),
                        d.add(n)
                    }),
                    this._updateController(t, r, a),
                    i(t, d, a, l),
                    n(t, d)
                },
                remove: function() {
                    this.group[cn](),
                    this._controller[Hn]()
                },
                _updateController: function(t, e, i) {
                    function n() {
                        var e = {
                            type: "geoRoam",
                            componentType: o
                        };
                        return e[o + "Id"] = t.id,
                        e
                    }
                    var r = t[ln],
                    a = this._controller;
                    a.zoomLimit = t.get("scaleLimit"),
                    a.zoom = r.getZoom(),
                    a.enable(t.get("roam") || !1);
                    var o = t[Ne];
                    a.off("pan").on("pan",
                    function(t, e) {
                        i[Un](s[jn](n(), {
                            dx: t,
                            dy: e
                        }))
                    }),
                    a.off("zoom").on("zoom",
                    function(t, e, r) {
                        if (i[Un](s[jn](n(), {
                            zoom: t,
                            originX: e,
                            originY: r
                        })), this._updateGroup) {
                            var a = this.group,
                            o = a.scale;
                            a[kn](function(t) {
                                "text" === t.type && t.attr("scale", [1 / o[0], 1 / o[1]])
                            })
                        }
                    },
                    this),
                    a[T] = function() {
                        return r.getViewRectAfterRoam()
                    }
                }
            },
            r
        }),
        e("echarts/coord/parallel/parallelCreator", [Tr, "./Parallel", ne],
        function(t) {
            function e(t, e) {
                var n = [];
                return t[or]("parallel",
                function(r, a) {
                    var o = new i(r, t, e);
                    o.name = "parallel_" + a,
                    o[gr](r, e),
                    r[ln] = o,
                    o.model = r,
                    n.push(o)
                }),
                t[tr](function(e) {
                    if ("parallel" === e.get(ln)) {
                        var i = t[Ee]({
                            mainType: "parallel",
                            index: e.get("parallelIndex"),
                            id: e.get("parallelId")
                        })[0];
                        e[ln] = i[ln]
                    }
                }),
                n
            }
            var i = t("./Parallel");
            t(ne)[bn]("parallel", {
                create: e
            })
        }),
        e("echarts/data/Tree", [Tr, Ar, "../model/Model", "./List", "./helper/linkList", "./helper/completeDimensions"],
        function(t) {
            function e(t, e) {
                this.root,
                this.data,
                this._nodes = [],
                this[fi] = t,
                this.levelModels = n.map(e || [],
                function(e) {
                    return new r(e, t, t[Te])
                })
            }
            function i(t, e) {
                var i = e.children;
                t[A] !== e && (i.push(t), t[A] = e)
            }
            var n = t(Ar),
            r = t("../model/Model"),
            a = t("./List"),
            o = t("./helper/linkList"),
            s = t("./helper/completeDimensions"),
            l = function(t, e) {
                this.name = t || "",
                this.depth = 0,
                this[nr] = 0,
                this[A] = null,
                this[zn] = -1,
                this.children = [],
                this.viewChildren = [],
                this.hostTree = e
            };
            return l[xr] = {
                constructor: l,
                isRemoved: function() {
                    return this[zn] < 0
                },
                eachNode: function(t, e, i) {
                    typeof t === Sn && (i = e, e = t, t = null),
                    t = t || {},
                    n[pn](t) && (t = {
                        order: t
                    });
                    var r, a = t.order || "preorder",
                    o = this[t.attr || "children"];
                    "preorder" === a && (r = e.call(i, this));
                    for (var s = 0; ! r && s < o[Wn]; s++) o[s][C](t, e, i);
                    "postorder" === a && e.call(i, this)
                },
                updateDepthAndHeight: function(t) {
                    var e = 0;
                    this.depth = t;
                    for (var i = 0; i < this.children[Wn]; i++) {
                        var n = this.children[i];
                        n.updateDepthAndHeight(t + 1),
                        n[nr] > e && (e = n[nr])
                    }
                    this[nr] = e + 1
                },
                getNodeById: function(t) {
                    if (this.getId() === t) return this;
                    for (var e = 0,
                    i = this.children,
                    n = i[Wn]; n > e; e++) {
                        var r = i[e].getNodeById(t);
                        if (r) return r
                    }
                },
                contains: function(t) {
                    if (t === this) return ! 0;
                    for (var e = 0,
                    i = this.children,
                    n = i[Wn]; n > e; e++) {
                        var r = i[e].contains(t);
                        if (r) return r
                    }
                },
                getAncestors: function(t) {
                    for (var e = [], i = t ? this: this[A]; i;) e.push(i),
                    i = i[A];
                    return e[S](),
                    e
                },
                getValue: function(t) {
                    var e = this.hostTree.data;
                    return e.get(e.getDimension(t || "value"), this[zn])
                },
                setLayout: function(t, e) {
                    this[zn] >= 0 && this.hostTree.data[He](this[zn], t, e)
                },
                getLayout: function() {
                    return this.hostTree.data[bi](this[zn])
                },
                getModel: function(t) {
                    if (! (this[zn] < 0)) {
                        var e = this.hostTree,
                        i = e.data[hi](this[zn]),
                        n = this.getLevelModel();
                        return i[fr](t, (n || e[fi])[fr](t))
                    }
                },
                getLevelModel: function() {
                    return (this.hostTree.levelModels || [])[this.depth]
                },
                setVisual: function(t, e) {
                    this[zn] >= 0 && this.hostTree.data[Ue](this[zn], t, e)
                },
                getVisual: function(t, e) {
                    return this.hostTree.data[gi](this[zn], t, e)
                },
                getRawIndex: function() {
                    return this.hostTree.data[je](this[zn])
                },
                getId: function() {
                    return this.hostTree.data.getId(this[zn])
                }
            },
            e[xr] = {
                constructor: e,
                type: "tree",
                eachNode: function(t, e, i) {
                    this.root[C](t, e, i)
                },
                getNodeByDataIndex: function(t) {
                    var e = this.data[je](t);
                    return this._nodes[e]
                },
                getNodeByName: function(t) {
                    return this.root.getNodeByName(t)
                },
                update: function() {
                    for (var t = this.data,
                    e = this._nodes,
                    i = 0,
                    n = e[Wn]; n > i; i++) e[i][zn] = -1;
                    for (var i = 0,
                    n = t.count(); n > i; i++) e[t[je](i)][zn] = i
                },
                clearLayouts: function() {
                    this.data.clearItemLayouts()
                }
            },
            e.createTree = function(t, n, r) {
                function u(t, e) {
                    h.push(t);
                    var n = new l(t.name, c);
                    e ? i(n, e) : c.root = n,
                    c._nodes.push(n);
                    var r = t.children;
                    if (r) for (var a = 0; a < r[Wn]; a++) u(r[a], n)
                }
                var c = new e(n, r),
                h = [];
                u(t),
                c.root.updateDepthAndHeight(0);
                var d = s([{
                    name: "value"
                }], h),
                f = new a(d, n);
                return f[Di](h),
                o({
                    mainData: f,
                    struct: c,
                    structAttr: "tree"
                }),
                c[er](),
                c
            },
            e
        }),
        e("echarts/chart/helper/createGraphFromNodeEdge", [Tr, Gi, "../../data/Graph", "../../data/helper/linkList", Ni, ne, Ar, "./createListFromArray"],
        function(t) {
            var e = t(Gi),
            i = t("../../data/Graph"),
            n = t("../../data/helper/linkList"),
            r = t(Ni),
            a = t(ne),
            o = t(Ar),
            s = t("./createListFromArray");
            return function(t, l, u, c, h) {
                for (var d = new i(c), f = 0; f < t[Wn]; f++) d.addNode(o[vi](t[f].id, t[f].name, f), f);
                for (var p = [], v = [], g = 0, f = 0; f < l[Wn]; f++) {
                    var m = l[f],
                    y = m.source,
                    x = m[Vn];
                    d.addEdge(y, x, g) && (v.push(m), p.push(o[vi](m.id, y + " > " + x)), g++)
                }
                var _, w = u.get(ln);
                if (w === q || "polar" === w) _ = s(t, u, u[Te]);
                else {
                    var b = a.get(w),
                    M = r((b && "view" !== b.type ? b[de] || [] : [])[Ai](["value"]), t);
                    _ = new e(M, u),
                    _[Di](t)
                }
                var S = new e(["value"], u);
                return S[Di](v, p),
                h && h(_, S),
                n({
                    mainData: _,
                    struct: d,
                    structAttr: "graph",
                    datas: {
                        node: _,
                        edge: S
                    },
                    datasAttr: {
                        node: "data",
                        edge: "edgeData"
                    }
                }),
                d[er](),
                d
            }
        }),
        e("echarts/coord/parallel/ParallelModel", [Tr, Ar, c, "./AxisModel"],
        function(t) {
            var e = t(Ar),
            i = t(c);
            t("./AxisModel"),
            i[jn]({
                type: "parallel",
                dependencies: ["parallelAxis"],
                coordinateSystem: null,
                dimensions: null,
                parallelAxisIndex: null,
                layoutMode: "box",
                defaultOption: {
                    zlevel: 0,
                    z: 0,
                    left: 80,
                    top: 60,
                    right: 80,
                    bottom: 60,
                    layout: "horizontal",
                    axisExpandable: !1,
                    axisExpandCenter: null,
                    axisExpandCount: 0,
                    axisExpandWidth: 50,
                    parallelAxisDefault: null
                },
                init: function() {
                    i[xr].init.apply(this, arguments),
                    this[Vi]({})
                },
                mergeOption: function(t) {
                    var i = this[zi];
                    t && e.merge(i, t, !0),
                    this._initDimensions()
                },
                contains: function(t, e) {
                    var i = t.get("parallelIndex");
                    return null != i && e[Re]("parallel", i) === this
                },
                setAxisExpand: function(t) {
                    e.each(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth"],
                    function(e) {
                        t.hasOwnProperty(e) && (this[zi][e] = t[e])
                    },
                    this)
                },
                _initDimensions: function() {
                    var t = this[de] = [],
                    i = this.parallelAxisIndex = [],
                    n = e[mn](this.dependentModels.parallelAxis,
                    function(t) {
                        return t.get("parallelIndex") === this[Oe]
                    });
                    e.each(n,
                    function(e) {
                        t.push("dim" + e.get("dim")),
                        i.push(e[Oe])
                    })
                }
            })
        }),
        e("echarts/component/parallelAxis", [Tr, "../coord/parallel/parallelCreator", "./axis/parallelAxisAction", "./axis/ParallelAxisView"],
        function(t) {
            t("../coord/parallel/parallelCreator"),
            t("./axis/parallelAxisAction"),
            t("./axis/ParallelAxisView")
        }),
        e("echarts/coord/parallel/parallelPreprocessor", [Tr, Ar, Bi],
        function(t) {
            function e(t) {
                if (!t.parallel) {
                    var e = !1;
                    n.each(t[Fn],
                    function(t) {
                        t && "parallel" === t.type && (e = !0)
                    }),
                    e && (t.parallel = [{}])
                }
            }
            function i(t) {
                var e = r.normalizeToArray(t.parallelAxis);
                n.each(e,
                function(e) {
                    if (n[Yn](e)) {
                        var i = e.parallelIndex || 0,
                        a = r.normalizeToArray(t.parallel)[i];
                        a && a.parallelAxisDefault && n.merge(e, a.parallelAxisDefault, !1)
                    }
                })
            }
            var n = t(Ar),
            r = t(Bi);
            return function(t) {
                e(t),
                i(t)
            }
        }),
        e("echarts/component/axis/AngleAxisView", [Tr, Ar, Si, W, Ei],
        function(t) {
            function e(t, e, i, n) {
                var r = t.coordToPoint([e, n]),
                a = t.coordToPoint([i, n]);
                return {
                    x1: r[0],
                    y1: r[1],
                    x2: a[0],
                    y2: a[1]
                }
            }
            var i = t(Ar),
            n = t(Si),
            r = t(W),
            a = [x, g, m, y, "splitArea"];
            t(Ei)[_n]({
                type: "angleAxis",
                render: function(t, e) {
                    if (this.group[cn](), t.get("show")) {
                        var n = e[Re]("polar", t.get(D)),
                        r = t.axis,
                        o = n[ln],
                        s = o.getRadiusAxis()[Fi](),
                        l = r.getTicksCoords();
                        r.type !== te && l.pop(),
                        i.each(a,
                        function(e) {
                            t.get(e + ".show") && this["_" + e](t, o, l, s)
                        },
                        this)
                    }
                },
                _axisLine: function(t, e, i, r) {
                    var a = t[fr]("axisLine.lineStyle"),
                    o = new n[be]({
                        shape: {
                            cx: e.cx,
                            cy: e.cy,
                            r: r[1]
                        },
                        style: a[ti](),
                        z2: 1,
                        silent: !0
                    });
                    o.style.fill = null,
                    this.group.add(o)
                },
                _axisTick: function(t, r, a, o) {
                    var s = t[fr](m),
                    l = (s.get(mi) ? -1 : 1) * s.get(Wn),
                    u = i.map(a,
                    function(t) {
                        return new n.Line({
                            shape: e(r, o[1], o[1] + l, t)
                        })
                    });
                    this.group.add(n.mergePath(u, {
                        style: i[qn](s[fr](Ke)[ti](), {
                            stroke: t.get("axisLine.lineStyle.color")
                        })
                    }))
                },
                _axisLabel: function(t, e, i, a) {
                    for (var o = t.axis,
                    s = t.get("data"), l = t[fr](g), u = l[fr](on), c = t[ee](), h = l.get("margin"), d = o.getLabelsCoords(), f = 0; f < i[Wn]; f++) {
                        var p = a[1],
                        v = e.coordToPoint([p + h, d[f]]),
                        m = e.cx,
                        y = e.cy,
                        x = Math.abs(v[0] - m) / p < .3 ? Ji: v[0] > m ? "left": "right",
                        _ = Math.abs(v[1] - y) / p < .3 ? Qi: v[1] > y ? "top": rr,
                        w = u;
                        s && s[f] && s[f][on] && (w = new r(s[f][on], u)),
                        this.group.add(new n.Text({
                            style: {
                                x: v[0],
                                y: v[1],
                                fill: w[nn]() || t.get("axisLine.lineStyle.color"),
                                text: c[f],
                                textAlign: x,
                                textVerticalAlign: _,
                                textFont: w[rn]()
                            },
                            silent: !0
                        }))
                    }
                },
                _splitLine: function(t, r, a, o) {
                    var s = t[fr](y),
                    l = s[fr](Ke),
                    u = l.get("color"),
                    c = 0;
                    u = u instanceof Array ? u: [u];
                    for (var h = [], d = 0; d < a[Wn]; d++) {
                        var f = c++%u[Wn];
                        h[f] = h[f] || [],
                        h[f].push(new n.Line({
                            shape: e(r, o[0], o[1], a[d])
                        }))
                    }
                    for (var d = 0; d < h[Wn]; d++) this.group.add(n.mergePath(h[d], {
                        style: i[qn]({
                            stroke: u[d % u[Wn]]
                        },
                        l[ti]()),
                        silent: !0,
                        z: t.get("z")
                    }))
                },
                _splitArea: function(t, e, r, a) {
                    var o = t[fr]("splitArea"),
                    s = o[fr]("areaStyle"),
                    l = s.get("color"),
                    u = 0;
                    l = l instanceof Array ? l: [l];
                    for (var c = [], h = Math.PI / 180, d = -r[0] * h, f = Math.min(a[0], a[1]), p = Math.max(a[0], a[1]), v = t.get(Ye), g = 1; g < r[Wn]; g++) {
                        var m = u++%l[Wn];
                        c[m] = c[m] || [],
                        c[m].push(new n[_i]({
                            shape: {
                                cx: e.cx,
                                cy: e.cy,
                                r0: f,
                                r: p,
                                startAngle: d,
                                endAngle: -r[g] * h,
                                clockwise: v
                            },
                            silent: !0
                        })),
                        d = -r[g] * h
                    }
                    for (var g = 0; g < c[Wn]; g++) this.group.add(n.mergePath(c[g], {
                        style: i[qn]({
                            fill: l[g % l[Wn]]
                        },
                        s[V]()),
                        silent: !0
                    }))
                }
            })
        }),
        e("echarts/component/helper/listComponent", [Tr, re, G, Si],
        function(t) {
            function e(t, e, n) {
                i.positionGroup(t, e[tn](), {
                    width: n[dr](),
                    height: n[hr]()
                },
                e.get("padding"))
            }
            var i = t(re),
            n = t(G),
            r = t(Si);
            return {
                layout: function(t, n, r) {
                    var a = i[Ki](n[tn](), {
                        width: r[dr](),
                        height: r[hr]()
                    },
                    n.get("padding"));
                    i.box(n.get(l), t, n.get("itemGap"), a.width, a[nr]),
                    e(t, n, r)
                },
                addBackground: function(t, e) {
                    var i = n.normalizeCssArray(e.get("padding")),
                    a = t[en](),
                    o = e[sn](["color", Yi]);
                    o.fill = e.get(ur);
                    var s = new r.Rect({
                        shape: {
                            x: a.x - i[3],
                            y: a.y - i[0],
                            width: a.width + i[1] + i[3],
                            height: a[nr] + i[0] + i[2]
                        },
                        style: o,
                        silent: !0,
                        z2: -1
                    });
                    r.subPixelOptimizeRect(s),
                    t.add(s)
                }
            }
        }),
        e("echarts/chart/helper/EffectSymbol", [Tr, Ar, I, Si, qe, "./Symbol"],
        function(t) {
            function e(t) {
                return r[An](t) || (t = [ + t, +t]),
                t
            }
            function i(t, e) {
                t[Je](function(t) {
                    t.attr({
                        z: e.z,
                        zlevel: e[Cn],
                        style: {
                            stroke: e.brushType === ye ? e.color: null,
                            fill: "fill" === e.brushType ? e.color: null
                        }
                    })
                })
            }
            function n(t, e) {
                u.call(this);
                var i = new l(t, e),
                n = new u;
                this.add(i),
                this.add(n),
                n.beforeUpdate = function() {
                    this.attr(i.getScale())
                },
                this[yi](t, e)
            }
            var r = t(Ar),
            a = t(I),
            o = t(Si),
            s = t(qe),
            l = t("./Symbol"),
            u = o.Group,
            c = 3,
            h = n[xr];
            return h.stopEffectAnimation = function() {
                this[di](1)[cn]()
            },
            h.startEffectAnimation = function(t) {
                for (var e = t.symbolType,
                n = t.color,
                r = this[di](1), o = 0; c > o; o++) {
                    var s = a[P](e, -.5, -.5, 1, 1, n);
                    s.attr({
                        style: {
                            strokeNoScale: !0
                        },
                        z2: 99,
                        silent: !0,
                        scale: [1, 1]
                    });
                    var l = -o / c * t.period + t.effectOffset;
                    s[wi]("", !0).when(t.period, {
                        scale: [t.rippleScale, t.rippleScale]
                    }).delay(l).start(),
                    s.animateStyle(!0).when(t.period, {
                        opacity: 0
                    }).delay(l).start(),
                    r.add(s)
                }
                i(r, t)
            },
            h.updateEffectAnimation = function(t) {
                for (var e = this._effectCfg,
                n = this[di](1), r = ["symbolType", "period", "rippleScale"], a = 0; r > a; a++) {
                    var o = r[a];
                    if (e[o] !== t[o]) return this.stopEffectAnimation(),
                    void this.startEffectAnimation(t)
                }
                i(n, t)
            },
            h[Jn] = function() {
                this[Zn](Li)
            },
            h[$n] = function() {
                this[Zn](ki)
            },
            h[yi] = function(t, i) {
                var n = t[fi];
                this[di](0)[yi](t, i);
                var r = this[di](1),
                a = t[hi](i),
                o = t[gi](i, se),
                l = e(t[gi](i, oe)),
                u = t[gi](i, "color");
                r.attr("scale", l),
                r[kn](function(t) {
                    t.attr({
                        fill: u
                    })
                });
                var c = a[Ce]("symbolOffset");
                if (c) {
                    var h = r[$i];
                    h[0] = s[We](c[0], l[0]),
                    h[1] = s[We](c[1], l[1])
                }
                r[ni] = (a[Ce]("symbolRotate") || 0) * Math.PI / 180 || 0;
                var d = {};
                if (d.showEffectOn = n.get("showEffectOn"), d.rippleScale = a.get("rippleEffect.scale"), d.brushType = a.get("rippleEffect.brushType"), d.period = 1e3 * a.get("rippleEffect.period"), d.effectOffset = i / t.count(), d.z = a[Ce]("z") || 0, d[Cn] = a[Ce](Cn) || 0, d.symbolType = o, d.color = u, this.off(En).off(On).off(Li).off(ki), d.showEffectOn === Bn) this._effectCfg ? this.updateEffectAnimation(d) : this.startEffectAnimation(d),
                this._effectCfg = d;
                else {
                    this._effectCfg = null,
                    this.stopEffectAnimation();
                    var f = this[di](0),
                    p = function() {
                        f[Zn](Li),
                        d.showEffectOn !== Bn && this.startEffectAnimation(d)
                    },
                    v = function() {
                        f[Zn](ki),
                        d.showEffectOn !== Bn && this.stopEffectAnimation()
                    };
                    this.on(En, p, this).on(On, v, this).on(Li, p, this).on(ki, v, this)
                }
                this._effectCfg = d
            },
            h.fadeOut = function(t) {
                this.off(En).off(On).off(Li).off(ki),
                t && t()
            },
            r[vn](n, u),
            n
        }),
        e("echarts/component/tooltip/TooltipContent", [Tr, Ar, Mr, "zrender/core/event", G, Sr],
        function(t) {
            function e(t) {
                var e = "cubic-bezier(0.23, 1, 0.32, 1)",
                i = "left " + t + "s " + e + ",top " + t + "s " + e;
                return o.map(f,
                function(t) {
                    return t + "transition:" + i
                }).join(";")
            }
            function i(t) {
                var e = [],
                i = t.get("fontSize"),
                n = t[nn]();
                return n && e.push("color:" + n),
                e.push("font:" + t[rn]()),
                i && e.push("line-height:" + Math.round(3 * i / 2) + "px"),
                c(["decoration", "align"],
                function(i) {
                    var n = t.get(i);
                    n && e.push("text-" + i + ":" + n)
                }),
                e.join(";")
            }
            function n(t) {
                t = t;
                var n = [],
                r = t.get("transitionDuration"),
                a = t.get(ur),
                o = t[fr](on),
                l = t.get("padding");
                return r && n.push(e(r)),
                a && (d[cr] ? n.push("background-Color:" + a) : (n.push("background-Color:#" + s.toHex(a)), n.push("filter:alpha(opacity=70)"))),
                c(["width", "color", Ze],
                function(e) {
                    var i = "border-" + e,
                    r = h(i),
                    a = t.get(r);
                    null != a && n.push(i + ":" + a + ("color" === e ? "": "px"))
                }),
                n.push(i(o)),
                null != l && n.push("padding:" + u.normalizeCssArray(l).join("px ") + "px"),
                n.join(";") + ";"
            }
            function r(t, e) {
                var i = document[Ti]("div"),
                n = e.getZr();
                this.el = i,
                this._x = e[dr]() / 2,
                this._y = e[hr]() / 2,
                t.appendChild(i),
                this._container = t,
                this._show = !1,
                this._hideTimeout;
                var r = this;
                i.onmouseenter = function() {
                    r.enterable && (clearTimeout(r._hideTimeout), r._show = !0),
                    r._inContent = !0
                },
                i.onmousemove = function(e) {
                    if (!r.enterable) {
                        var i = n.handler;
                        l.normalizeEvent(t, e),
                        i.dispatch(Rn, e)
                    }
                },
                i.onmouseleave = function() {
                    r.enterable && r._show && r.hideLater(r._hideDelay),
                    r._inContent = !1
                },
                a(i, t)
            }
            function a(t, e) {
                function i(t) {
                    n(t[Vn]) && t.preventDefault()
                }
                function n(i) {
                    for (; i && i !== e;) {
                        if (i === t) return ! 0;
                        i = i[A]
                    }
                }
                l.addEventListener(e, "touchstart", i),
                l.addEventListener(e, "touchmove", i),
                l.addEventListener(e, "touchend", i)
            }
            var o = t(Ar),
            s = t(Mr),
            l = t("zrender/core/event"),
            u = t(G),
            c = o.each,
            h = u.toCamelCase,
            d = t(Sr),
            f = ["", "-webkit-", "-moz-", "-o-"],
            p = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
            return r[xr] = {
                constructor: r,
                enterable: !0,
                update: function() {
                    var t = this._container,
                    e = t.currentStyle || document.defaultView.getComputedStyle(t),
                    i = t.style;
                    "absolute" !== i[$i] && "absolute" !== e[$i] && (i[$i] = "relative")
                },
                show: function(t) {
                    clearTimeout(this._hideTimeout);
                    var e = this.el;
                    e.style.cssText = p + n(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""),
                    e.style.display = e.innerHTML ? "block": "none",
                    this._show = !0
                },
                setContent: function(t) {
                    var e = this.el;
                    e.innerHTML = t,
                    e.style.display = t ? "block": "none"
                },
                moveTo: function(t, e) {
                    var i = this.el.style;
                    i.left = t + "px",
                    i.top = e + "px",
                    this._x = t,
                    this._y = e
                },
                hide: function() {
                    this.el.style.display = "none",
                    this._show = !1
                },
                hideLater: function(t) { ! this._show || this._inContent && this.enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(o.bind(this.hide, this), t)) : this.hide())
                },
                isShow: function() {
                    return this._show
                }
            },
            r
        }),
        e("echarts/component/marker/markerHelper", [Tr, Ar, qe],
        function(t) {
            function e(t) {
                return ! (isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y)))
            }
            function i(t) {
                return ! isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y))
            }
            function n(t, e, i) {
                var n = -1;
                do n = Math.max(o.getPrecision(t.get(e, i)), n),
                t = t.stackedOn;
                while (t);
                return n
            }
            function r(t, e, i, r, a, o) {
                var s = [],
                l = p(e, r, t),
                u = e.indexOfNearest(r, l, !0);
                s[a] = e.get(i, u, !0),
                s[o] = e.get(r, u, !0);
                var c = n(e, r, u);
                return c >= 0 && (s[o] = +s[o][Ii](c)),
                s
            }
            var a = t(Ar),
            o = t(qe),
            s = a[gn],
            l = a.curry,
            u = {
                min: l(r, "min"),
                max: l(r, "max"),
                average: l(r, "average")
            },
            c = function(t, e) {
                var n = t[Kn](),
                r = t[ln];
                if (e && !i(e) && !a[An](e.coord) && r) {
                    var o = r[de],
                    l = h(e, n, r, t);
                    if (e = a.clone(e), e.type && u[e.type] && l.baseAxis && l.valueAxis) {
                        var c = s(o, l.baseAxis.dim),
                        d = s(o, l.valueAxis.dim);
                        e.coord = u[e.type](n, l.baseDataDim, l.valueDataDim, c, d),
                        e.value = e.coord[d]
                    } else {
                        for (var f = [null != e.xAxis ? e.xAxis: e.radiusAxis, null != e.yAxis ? e.yAxis: e.angleAxis], v = 0; 2 > v; v++) if (u[f[v]]) {
                            var g = t[j](o[v])[0];
                            f[v] = p(n, g, f[v])
                        }
                        e.coord = f
                    }
                }
                return e
            },
            h = function(t, e, i, n) {
                var r = {};
                return null != t.valueIndex || null != t.valueDim ? (r.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, r.valueAxis = i[J](n.dataDimToCoordDim(r.valueDataDim)), r.baseAxis = i.getOtherAxis(r.valueAxis), r.baseDataDim = n[j](r.baseAxis.dim)[0]) : (r.baseAxis = n[Ie](), r.valueAxis = i.getOtherAxis(r.baseAxis), r.baseDataDim = n[j](r.baseAxis.dim)[0], r.valueDataDim = n[j](r.valueAxis.dim)[0]),
                r
            },
            d = function(t, i) {
                return t && t.containData && i.coord && !e(i) ? t.containData(i.coord) : !0
            },
            f = function(t, e, i, n) {
                return 2 > n ? t.coord && t.coord[n] : t.value
            },
            p = function(t, e, i) {
                if ("average" === i) {
                    var n = 0,
                    r = 0;
                    return t.each(e,
                    function(t) {
                        isNaN(t) || (n += t, r++)
                    },
                    !0),
                    n / r
                }
                return t[Fe](e, !0)["max" === i ? 1 : 0]
            };
            return {
                dataTransform: c,
                dataFilter: d,
                dimValueGetter: f,
                getAxisInfo: h,
                numCalculate: p
            }
        }),
        e("echarts/component/marker/MarkerView", [Tr, Ei],
        function(t) {
            return t(Ei)[_n]({
                type: "marker",
                init: function() {
                    this.markerGroupMap = {}
                },
                render: function(t, e, i) {
                    var n = this.markerGroupMap;
                    for (var r in n) n[r].__keep = !1;
                    var a = this.type + "Model";
                    e[tr](function(t) {
                        var n = t[a];
                        n && this.renderSeries(t, n, e, i)
                    },
                    this);
                    for (var r in n) n[r].__keep || this.group[Xn](n[r].group)
                },
                renderSeries: function() {}
            })
        }),
        e("echarts/util/throttle", [],
        function() {
            var t = {},
            e = "\x00__throttleOriginMethod",
            i = "\x00__throttleRate",
            n = "\x00__throttleType";
            return t.throttle = function(t, e, i) {
                function n() {
                    u = (new Date).getTime(),
                    c = null,
                    t.apply(o, s || [])
                }
                var r, a, o, s, l = 0,
                u = 0,
                c = null;
                e = e || 0;
                var h = function() {
                    r = (new Date).getTime(),
                    o = this,
                    s = arguments,
                    a = r - (i ? l: u) - e,
                    clearTimeout(c),
                    i ? c = setTimeout(n, e) : a >= 0 ? n() : c = setTimeout(n, -a),
                    l = r
                };
                return h.clear = function() {
                    c && (clearTimeout(c), c = null)
                },
                h
            },
            t.createOrUpdate = function(r, a, o, s) {
                var l = r[a];
                if (l) {
                    var u = l[e] || l,
                    c = l[n],
                    h = l[i];
                    if (h !== o || c !== s) {
                        if (null == o || !s) return r[a] = u;
                        l = r[a] = t.throttle(u, o, "debounce" === s),
                        l[e] = u,
                        l[n] = s,
                        l[i] = o
                    }
                    return l
                }
            },
            t.clear = function(t, i) {
                var n = t[i];
                n && n[e] && (t[i] = n[e])
            },
            t
        }),
        e("echarts/component/timeline/TimelineModel", [Tr, c, Gi, Ar, Bi],
        function(t) {
            var e = t(c),
            i = t(Gi),
            n = t(Ar),
            r = t(Bi),
            a = e[jn]({
                type: "timeline",
                layoutMode: "box",
                defaultOption: {
                    zlevel: 0,
                    z: 4,
                    show: !0,
                    axisType: "time",
                    realtime: !0,
                    left: "20%",
                    top: null,
                    right: "20%",
                    bottom: 0,
                    width: null,
                    height: 40,
                    padding: 5,
                    controlPosition: "left",
                    autoPlay: !1,
                    rewind: !1,
                    loop: !0,
                    playInterval: 2e3,
                    currentIndex: 0,
                    itemStyle: {
                        normal: {},
                        emphasis: {}
                    },
                    label: {
                        normal: {
                            textStyle: {
                                color: "#000"
                            }
                        },
                        emphasis: {}
                    },
                    data: []
                },
                init: function(t, e, i) {
                    this._data,
                    this._names,
                    this[De](t, i),
                    this._initData()
                },
                mergeOption: function() {
                    a[Oi](this, Vi, arguments),
                    this._initData()
                },
                setCurrentIndex: function(t) {
                    null == t && (t = this[zi].currentIndex);
                    var e = this._data.count();
                    this[zi].loop ? t = (t % e + e) % e: (t >= e && (t = e - 1), 0 > t && (t = 0)),
                    this[zi].currentIndex = t
                },
                getCurrentIndex: function() {
                    return this[zi].currentIndex
                },
                isIndexMax: function() {
                    return this.getCurrentIndex() >= this._data.count() - 1
                },
                setPlayState: function(t) {
                    this[zi].autoPlay = !!t
                },
                getPlayState: function() {
                    return !! this[zi].autoPlay
                },
                _initData: function() {
                    var t = this[zi],
                    e = t.data || [],
                    a = t.axisType,
                    o = this._names = [];
                    if (a === te) {
                        var s = [];
                        n.each(e,
                        function(t, e) {
                            var i, a = r.getDataItemValue(t);
                            n[Yn](t) ? (i = n.clone(t), i.value = e) : i = e,
                            s.push(i),
                            n[pn](a) || null != a && !isNaN(a) || (a = ""),
                            o.push(a + "")
                        }),
                        e = s
                    }
                    var l = {
                        category: "ordinal",
                        time: "time"
                    } [a] || yn,
                    u = this._data = new i([{
                        name: "value",
                        type: l
                    }], this);
                    u[Di](e, o)
                },
                getData: function() {
                    return this._data
                },
                getCategories: function() {
                    return this.get("axisType") === te ? this._names.slice() : void 0
                }
            });
            return a
        }),
        e("echarts/component/helper/sliderMove", [Tr],
        function() {
            return function(t, e, i, n, r) {
                function a(t, e, i) {
                    var n = e[Wn] ? e.slice() : [e, e];
                    return e[0] > e[1] && n[S](),
                    0 > t && n[0] + t < i[0] && (t = i[0] - n[0]),
                    t > 0 && n[1] + t > i[1] && (t = i[1] - n[1]),
                    t
                }
                return t ? ("rigid" === n ? (t = a(t, e, i), e[0] += t, e[1] += t) : (t = a(t, e[r], i), e[r] += t, "push" === n && e[0] > e[1] && (e[1 - r] = e[r])), e) : e
            }
        }),
        e("echarts/visual/visualSolution", [Tr, Ar, "./VisualMapping"],
        function(t) {
            function e(t) {
                if (t) for (var e in t) if (t.hasOwnProperty(e)) return ! 0
            }
            var i = t(Ar),
            n = t("./VisualMapping"),
            r = i.each,
            a = {
                createVisualMappings: function(t, e, a) {
                    function o() {
                        var t = function() {};
                        t[xr].__hidden = t[xr];
                        var e = new t;
                        return e
                    }
                    var s = {};
                    return r(e,
                    function(e) {
                        var l = s[e] = o();
                        r(t[e],
                        function(t, r) {
                            if (n.isValidType(r)) {
                                var o = {
                                    type: r,
                                    visual: t
                                };
                                a && a(o, e),
                                l[r] = new n(o),
                                r === Yi && (o = i.clone(o), o.type = "colorAlpha", l.__hidden.__alphaForOpacity = new n(o))
                            }
                        })
                    }),
                    s
                },
                replaceVisualOption: function(t, n, r) {
                    var a;
                    i.each(r,
                    function(t) {
                        n.hasOwnProperty(t) && e(n[t]) && (a = !0)
                    }),
                    a && i.each(r,
                    function(r) {
                        n.hasOwnProperty(r) && e(n[r]) ? t[r] = i.clone(n[r]) : delete t[r]
                    })
                },
                applyVisual: function(t, e, r, a, o, s) {
                    function l(t) {
                        return r[gi](d, t)
                    }
                    function u(t, e) {
                        r[Ue](d, t, e)
                    }
                    function c(t, i) {
                        d = null == s ? t: i;
                        for (var n = a.call(o, t), r = e[n], c = h[n], f = 0, p = c[Wn]; p > f; f++) {
                            var v = c[f];
                            r[v] && r[v].applyVisual(t, l, u)
                        }
                    }
                    var h = {};
                    i.each(t,
                    function(t) {
                        var i = n.prepareVisualTypes(e[t]);
                        h[t] = i
                    });
                    var d;
                    null == s ? r.each(c, !0) : r.each([s], c, !0)
                }
            };
            return a
        }),
        e("echarts/component/brush/selector", [Tr, "zrender/contain/polygon", Me],
        function(t) {
            function e(t) {
                var e = ["x", "y"],
                n = ["width", nr];
                return {
                    point: function(e, n, r) {
                        var a = r.range,
                        o = e[t];
                        return i(o, a)
                    },
                    rect: function(r, a, o) {
                        var s = o.range;
                        return i(r[e[t]], s) || i(r[e[t]] + r[n[t]], s)
                    }
                }
            }
            function i(t, e) {
                return e[0] <= t && t <= e[1]
            }
            function n(t, e, i, n, a) {
                for (var o = 0,
                s = a[a[Wn] - 1]; o < a[Wn]; o++) {
                    var l = a[o];
                    if (r(t, e, i, n, l[0], l[1], s[0], s[1])) return ! 0;
                    s = l
                }
            }
            function r(t, e, i, n, r, s, l, u) {
                var c = o(i - t, r - l, n - e, s - u);
                if (a(c)) return ! 1;
                var h = o(r - t, r - l, s - e, s - u) / c;
                if (0 > h || h > 1) return ! 1;
                var d = o(i - t, r - t, n - e, s - e) / c;
                return 0 > d || d > 1 ? !1 : !0
            }
            function a(t) {
                return 1e-6 >= t && t >= -1e-6
            }
            function o(t, e, i, n) {
                return t * n - e * i
            }
            function s(t) {
                var e = t.x,
                i = t.y,
                n = t.width,
                r = t[nr];
                return 0 > n && (e += n, n = -n),
                0 > r && (i += r, r = -r),
                new u(e, i, n, r)
            }
            var l = t("zrender/contain/polygon")[ji],
            u = t(Me),
            c = {
                lineX: e(0),
                lineY: e(1),
                rect: {
                    point: function(t, e, i) {
                        return i.boundingRect[ji](t[0], t[1])
                    },
                    rect: function(t, e, i) {
                        return i.boundingRect.intersect(s(t))
                    }
                },
                polygon: {
                    point: function(t, e, i) {
                        return i.boundingRect[ji](t[0], t[1]) && l(i.range, t[0], t[1])
                    },
                    rect: function(t, e, i) {
                        var r = i.range;
                        if (r[Wn] <= 1) return ! 1;
                        var a = t.x,
                        o = t.y,
                        u = t.width,
                        c = t[nr],
                        h = r[0];
                        return l(r, a, o) || l(r, a + u, o) || l(r, a, o + c) || l(r, a + u, o + c) || s(t)[ji](h[0], h[1]) || n(a, o, a + u, o, r) || n(a, o, a, o + c, r) || n(a + u, o, a + u, o + c, r) || n(a, o + c, a + u, o + c, r) ? !0 : void 0
                    }
                }
            };
            return c
        }),
        e("echarts/chart/helper/WhiskerBoxDraw", [Tr, Ar, Si, "zrender/graphic/Path"],
        function(t) {
            function e(t, e, i, n) {
                o.Group.call(this),
                this.bodyIndex,
                this.whiskerIndex,
                this.styleUpdater = i,
                this._createContent(t, e, n),
                this[yi](t, e, n),
                this._seriesModel
            }
            function i(t, e, i) {
                return a.map(t,
                function(t) {
                    return t = t.slice(),
                    t[e] = i.initBaseline,
                    t
                })
            }
            function n(t) {
                var e = {};
                return a.each(t,
                function(t, i) {
                    e["ends" + i] = t
                }),
                e
            }
            function r(t) {
                this.group = new o.Group,
                this.styleUpdater = t
            }
            var a = t(Ar),
            o = t(Si),
            s = t("zrender/graphic/Path"),
            l = s[jn]({
                type: "whiskerInBox",
                shape: {},
                buildPath: function(t, e) {
                    for (var i in e) if (0 === i[gn]("ends")) {
                        var n = e[i];
                        t[p](n[0][0], n[0][1]),
                        t[d](n[1][0], n[1][1])
                    }
                }
            }),
            u = e[xr];
            u._createContent = function(t, e, r) {
                var s = t[bi](e),
                u = s.chartLayout === O ? 1 : 0,
                c = 0;
                this.add(new o[we]({
                    shape: {
                        points: r ? i(s.bodyEnds, u, s) : s.bodyEnds
                    },
                    style: {
                        strokeNoScale: !0
                    },
                    z2: 100
                })),
                this.bodyIndex = c++;
                var h = a.map(s.whiskerEnds,
                function(t) {
                    return r ? i(t, u, s) : t
                });
                this.add(new l({
                    shape: n(h),
                    style: {
                        strokeNoScale: !0
                    },
                    z2: 100
                })),
                this.whiskerIndex = c++
            },
            u[yi] = function(t, e, i) {
                var r = this._seriesModel = t[fi],
                a = t[bi](e),
                s = o[i ? Xe: ui];
                s(this[di](this.bodyIndex), {
                    shape: {
                        points: a.bodyEnds
                    }
                },
                r, e),
                s(this[di](this.whiskerIndex), {
                    shape: n(a.whiskerEnds)
                },
                r, e),
                this.styleUpdater.call(null, this, t, e)
            },
            a[vn](e, o.Group);
            var c = r[xr];
            return c[yi] = function(t) {
                var i = this.group,
                n = this._data,
                r = this.styleUpdater;
                t.diff(n).add(function(n) {
                    if (t.hasValue(n)) {
                        var a = new e(t, n, r, !0);
                        t[$e](n, a),
                        i.add(a)
                    }
                })[er](function(a, o) {
                    var s = n[Mi](o);
                    return t.hasValue(a) ? (s ? s[yi](t, a) : s = new e(t, a, r), i.add(s), void t[$e](a, s)) : void i[Xn](s)
                })[Xn](function(t) {
                    var e = n[Mi](t);
                    e && i[Xn](e)
                })[Qe](),
                this._data = t
            },
            c[Xn] = function() {
                var t = this.group,
                e = this._data;
                this._data = null,
                e && e[Se](function(e) {
                    e && t[Xn](e)
                })
            },
            r
        }),
        e("echarts/component/helper/brushHelper", [Tr, Ar, Si],
        function(t) {
            function e(t) {
                return t[0] > t[1] && t[S](),
                t
            }
            function i(t, e) {
                for (var i = !0,
                n = 0; n < u[Wn]; n++) {
                    var r = u[n] + "Index";
                    if (t[r] >= 0) {
                        i = !1;
                        for (var a = 0; a < e[Wn]; a++) if (e[a][r] === t[r]) return e[a]
                    }
                }
                return i
            }
            function r(t, i, r, o) {
                var s = r.coordSys[J](t);
                return e(a.map([0, 1],
                function(t) {
                    return i ? s[n](s.toLocalCoord(o[t])) : s[U](s[B](o[t]))
                }))
            }
            var a = t(Ar),
            o = t(Si),
            s = a.each,
            l = {},
            u = ["geo", "xAxis", "yAxis"],
            c = "--",
            h = [ae, "pointToData"];
            l.parseOutputRanges = function(t, e, n, r) {
                s(t,
                function(t, n) {
                    var a = t.panelId;
                    if (a) {
                        a = a.split(c),
                        t[a[0] + "Index"] = +a[1];
                        var o = i(t, e);
                        t.coordRange = d[t.brushType](1, o, t.range),
                        r && (r[n] = o)
                    }
                })
            },
            l.parseInputRanges = function(t) {
                s(t.areas,
                function(e) {
                    var n = i(e, t.coordInfoList);
                    e.range = e.range || [],
                    n && n !== !0 && (e.range = d[e.brushType](0, n, e.coordRange), e.panelId = n.panelId)
                })
            },
            l.makePanelOpts = function(t) {
                var e = [];
                return s(t,
                function(t) {
                    var i, n = t.coordSys;
                    t.geoIndex >= 0 ? (i = n[en]().clone(), i[_e](o.getTransform(n))) : i = n.grid[un]().clone(),
                    e.push({
                        panelId: t.panelId,
                        rect: i
                    })
                }),
                e
            },
            l.makeCoordInfoList = function(t, e) {
                var i = [];
                return s(u,
                function(n) {
                    var r = t[n + "Index"];
                    null != r && "none" !== r && ("all" === r || a[An](r) || (r = [r]), e[or]({
                        mainType: n
                    },
                    function(t, e) {
                        if (! ("all" !== r && a[gn](r, e) < 0)) {
                            var o, s;
                            "xAxis" === n || "yAxis" === n ? o = t.axis.grid: s = t[ln];
                            for (var l, u = 0,
                            h = i[Wn]; h > u; u++) {
                                var d = i[u];
                                if ("yAxis" === n && !d.yAxis && d.xAxis) {
                                    var f = o.getCartesian(d.xAxisIndex, e);
                                    if (f) {
                                        s = f,
                                        l = d;
                                        break
                                    }
                                }
                            } ! l && i.push(l = {}),
                            l[n] = t,
                            l[n + "Index"] = e,
                            l.panelId = n + c + e,
                            l.coordSys = s || o.getCartesian(l.xAxisIndex, l.yAxisIndex),
                            l.coordSys ? i[n + "Has"] = !0 : i.pop()
                        }
                    }))
                }),
                i
            },
            l.controlSeries = function(t, e, n) {
                var r = i(t, e.coordInfoList);
                return r === !0 || r && r.coordSys === n[ln]
            };
            var d = {
                lineX: a.curry(r, "x"),
                lineY: a.curry(r, "y"),
                rect: function(t, i, n) {
                    var r = i.coordSys,
                    a = r[h[t]]([n[0][0], n[1][0]]),
                    o = r[h[t]]([n[0][1], n[1][1]]);
                    return [e([a[0], o[0]]), e([a[1], o[1]])]
                },
                polygon: function(t, e, i) {
                    var n = e.coordSys;
                    return a.map(i, n[h[t]], n)
                }
            };
            return l
        }),
        e("echarts/coord/radar/IndicatorAxis", [Tr, Ar, "../Axis"],
        function(t) {
            function e(t, e, i) {
                n.call(this, t, e, i),
                this.type = "value",
                this.angle = 0,
                this.name = "",
                this.model
            }
            var i = t(Ar),
            n = t("../Axis");
            return i[vn](e, n),
            e
        }),
        e("echarts/component/helper/RoamController", [Tr, "zrender/mixin/Eventful", Ar, "zrender/core/event", "./interactionMutex"],
        function(t) {
            function e(t) {
                if (!t[Vn] || !t[Vn][L]) {
                    var e = t[w],
                    i = t[_],
                    n = this[T] && this[T]();
                    n && n[ji](e, i) && (this._x = e, this._y = i, this._dragging = !0)
                }
            }
            function i(t) {
                if (this._dragging && (c.stop(t.event), "pinch" !== t.gestureEvent)) {
                    if (h.isTaken(this._zr, "globalPan")) return;
                    var e = t[w],
                    i = t[_],
                    n = e - this._x,
                    r = i - this._y;
                    this._x = e,
                    this._y = i;
                    var a = this[Vn];
                    if (a) {
                        var o = a[$i];
                        o[0] += n,
                        o[1] += r,
                        a.dirty()
                    }
                    c.stop(t.event),
                    this[Zn]("pan", n, r)
                }
            }
            function n() {
                this._dragging = !1
            }
            function r(t) {
                var e = t.wheelDelta > 0 ? 1.1 : 1 / 1.1;
                o.call(this, t, e, t[w], t[_])
            }
            function a(t) {
                if (!h.isTaken(this._zr, "globalPan")) {
                    var e = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
                    o.call(this, t, e, t.pinchX, t.pinchY)
                }
            }
            function o(t, e, i, n) {
                var r = this[T] && this[T]();
                if (r && r[ji](i, n)) {
                    c.stop(t.event);
                    var a = this[Vn],
                    o = this.zoomLimit;
                    if (a) {
                        var s = a[$i],
                        l = a.scale,
                        u = this.zoom = this.zoom || 1;
                        if (u *= e, o) {
                            var h = o.min || 0,
                            d = o.max || 1 / 0;
                            u = Math.max(Math.min(d, u), h)
                        }
                        var f = u / this.zoom;
                        this.zoom = u,
                        s[0] -= (i - s[0]) * (f - 1),
                        s[1] -= (n - s[1]) * (f - 1),
                        l[0] *= f,
                        l[1] *= f,
                        a.dirty()
                    }
                    this[Zn]("zoom", e, i, n)
                }
            }
            function s(t, o, s) {
                this[Vn] = o,
                this[T] = s,
                this.zoomLimit,
                this.zoom,
                this._zr = t;
                var c = u.bind,
                h = c(e, this),
                d = c(i, this),
                f = c(n, this),
                p = c(r, this),
                v = c(a, this);
                l.call(this),
                this.enable = function(e) {
                    this.disable(),
                    null == e && (e = !0),
                    (e === !0 || "move" === e || "pan" === e) && (t.on("mousedown", h), t.on(Rn, d), t.on("mouseup", f)),
                    (e === !0 || "scale" === e || "zoom" === e) && (t.on("mousewheel", p), t.on("pinch", v))
                },
                this.disable = function() {
                    t.off("mousedown", h),
                    t.off(Rn, d),
                    t.off("mouseup", f),
                    t.off("mousewheel", p),
                    t.off("pinch", v)
                },
                this[Hn] = this.disable,
                this.isDragging = function() {
                    return this._dragging
                },
                this.isPinching = function() {
                    return this._pinching
                }
            }
            var l = t("zrender/mixin/Eventful"),
            u = t(Ar),
            c = t("zrender/core/event"),
            h = t("./interactionMutex");
            return u.mixin(s, l),
            s
        }),
        e("echarts/coord/parallel/Parallel", [Tr, re, "../../coord/axisHelper", Ar, "./ParallelAxis", Si, br],
        function(t) {
            function e(t, e, i) {
                this._axesMap = {},
                this._axesLayout = {},
                this[de] = t[de],
                this._rect,
                this[pr] = t,
                this._init(t, e, i)
            }
            var i = t(re),
            n = t("../../coord/axisHelper"),
            r = t(Ar),
            a = t("./ParallelAxis"),
            s = t(Si),
            l = t(br),
            u = r.each,
            c = Math.PI;
            return e[xr] = {
                type: "parallel",
                constructor: e,
                _init: function(t, e) {
                    var i = t[de],
                    r = t.parallelAxisIndex;
                    u(i,
                    function(t, i) {
                        var o = r[i],
                        s = e[Re]("parallelAxis", o),
                        l = this._axesMap[t] = new a(t, n[$](s), [0, 0], s.get("type"), o),
                        u = l.type === te;
                        l[Y] = u && s.get(X),
                        l[Q] = s.get(Q),
                        s.axis = l,
                        l.model = s
                    },
                    this)
                },
                update: function(t) {
                    this._updateAxesFromSeries(this[pr], t)
                },
                _updateAxesFromSeries: function(t, e) {
                    e[tr](function(i) {
                        if (t.contains(i, e)) {
                            var r = i[Kn]();
                            u(this[de],
                            function(t) {
                                var e = this._axesMap[t];
                                e.scale[Hi](r[Fe](t)),
                                n[ie](e, e.model)
                            },
                            this)
                        }
                    },
                    this)
                },
                resize: function(t, e) {
                    this._rect = i[Ki](t[tn](), {
                        width: e[dr](),
                        height: e[hr]()
                    }),
                    this._layoutAxes(t)
                },
                getRect: function() {
                    return this._rect
                },
                _layoutAxes: function(t) {
                    var e = this._rect,
                    i = t.get(E),
                    n = this._axesMap,
                    r = this[de],
                    a = [e.width, e[nr]],
                    s = i === O ? 0 : 1,
                    h = a[s],
                    d = a[1 - s],
                    f = [0, d];
                    u(n,
                    function(t) {
                        var e = t[Q] ? 1 : 0;
                        t[Zi](f[e], f[1 - e])
                    });
                    var p, v = t.get("axisExpandable"),
                    g = t.get("axisExpandWidth"),
                    m = t.get("axisExpandCenter"),
                    y = t.get("axisExpandCount") || 0;
                    if (null != m) {
                        var x = Math.max(0, Math.floor(m - (y - 1) / 2)),
                        _ = x + y - 1;
                        _ >= r[Wn] && (_ = r[Wn] - 1, x = Math.max(0, Math.floor(_ - y + 1))),
                        p = [x, _]
                    }
                    var w = v && p && g ?
                    function(t, e, i) {
                        var n, r = p[1] - p[0],
                        a = (e - g * r) / (i - 1 - r);
                        return n = t < p[0] ? (t - 1) * a: t <= p[1] ? p[0] * a + (t - p[0]) * g: t === i - 1 ? e: p[0] * a + r * g + (t - p[1]) * a,
                        {
                            position: n,
                            axisNameAvailableWidth: p[0] < t && t < p[1] ? g: a
                        }
                    }: function(t, e, i) {
                        var n = e / (i - 1);
                        return {
                            position: n * t,
                            axisNameAvailableWidth: n
                        }
                    };
                    u(r,
                    function(t, n) {
                        var a = w(n, h, r[Wn]),
                        s = {
                            horizontal: {
                                x: a[$i],
                                y: d
                            },
                            vertical: {
                                x: 0,
                                y: a[$i]
                            }
                        },
                        u = {
                            horizontal: c / 2,
                            vertical: 0
                        },
                        f = [s[i].x + e.x, s[i].y + e.y],
                        v = u[i],
                        g = l[ir]();
                        l[o](g, g, v),
                        l.translate(g, g, f),
                        this._axesLayout[t] = {
                            position: f,
                            rotation: v,
                            transform: g,
                            axisNameAvailableWidth: a.axisNameAvailableWidth,
                            tickDirection: 1,
                            labelDirection: 1,
                            axisExpandWindow: p
                        }
                    },
                    this)
                },
                getAxis: function(t) {
                    return this._axesMap[t]
                },
                dataToPoint: function(t, e) {
                    return this.axisCoordToPoint(this._axesMap[e][B](t), e)
                },
                eachActiveState: function(t, e, i) {
                    for (var n = this[de], r = this._axesMap, a = this.hasAxisbrushed(), o = 0, s = t.count(); s > o; o++) {
                        var l, u = t.getValues(n, o);
                        if (a) {
                            l = "active";
                            for (var c = 0,
                            h = n[Wn]; h > c; c++) {
                                var d = n[c],
                                f = r[d].model.getActiveState(u[c], c);
                                if ("inactive" === f) {
                                    l = "inactive";
                                    break
                                }
                            }
                        } else l = ki;
                        e.call(i, l, o)
                    }
                },
                hasAxisbrushed: function() {
                    for (var t = this[de], e = this._axesMap, i = !1, n = 0, r = t[Wn]; r > n; n++) e[t[n]].model.getActiveState() !== ki && (i = !0);
                    return i
                },
                axisCoordToPoint: function(t, e) {
                    var i = this._axesLayout[e];
                    return s[_e]([t, 0], i[k])
                },
                getAxisLayout: function(t) {
                    return r.clone(this._axesLayout[t])
                },
                findClosestAxisDim: function(t) {
                    var e, i = 1 / 0;
                    return r.each(this._axesLayout,
                    function(n, r) {
                        var a = s[_e](t, n[k], !0),
                        o = this._axesMap[r][Fi]();
                        if (! (a[0] < o[0] || a[0] > o[1])) {
                            var l = Math.abs(a[1]);
                            i > l && (i = l, e = r)
                        }
                    },
                    this),
                    e
                }
            },
            e
        }),
        e("echarts/data/helper/linkList", [Tr, Ar],
        function(t) {
            function e(t) {
                var e = t.mainData,
                a = t.datas;
                a || (a = {
                    main: e
                },
                t.datasAttr = {
                    main: "data"
                }),
                t.datas = t.mainData = null,
                s(e, a, t),
                c(a,
                function(n) {
                    c(e.TRANSFERABLE_METHODS,
                    function(e) {
                        n.wrapMethod(e, u.curry(i, t))
                    })
                }),
                e.wrapMethod("cloneShallow", u.curry(r, t)),
                c(e.CHANGABLE_METHODS,
                function(i) {
                    e.wrapMethod(i, u.curry(n, t))
                }),
                u.assert(a[e[Pn]] === e)
            }
            function i(t, e) {
                if (o(this)) {
                    var i = u[jn]({},
                    this[h]);
                    i[this[Pn]] = e,
                    s(e, i, t)
                } else l(e, this[Pn], this[d], t);
                return e
            }
            function n(t, e) {
                return t.struct && t.struct[er](this),
                e
            }
            function r(t, e) {
                return c(e[h],
                function(i, n) {
                    i !== e && l(i.cloneShallow(), n, e, t)
                }),
                e
            }
            function a(t) {
                var e = this[d];
                return null == t || null == e ? e: e[h][t]
            }
            function o(t) {
                return t[d] === t
            }
            function s(t, e, i) {
                t[h] = {},
                c(e,
                function(e, n) {
                    l(e, n, t, i)
                })
            }
            function l(t, e, i, n) {
                i[h][e] = t,
                t[d] = i,
                t[Pn] = e,
                n.struct && (t[n.structAttr] = n.struct, n.struct[n.datasAttr[e]] = t),
                t.getLinkedData = a
            }
            var u = t(Ar),
            c = u.each,
            h = "\x00__link_datas",
            d = "\x00__link_mainData";
            return e
        }),
        e("echarts/data/Graph", [Tr, Ar],
        function(t) {
            function e(t, e) {
                this.id = null == t ? "": t,
                this.inEdges = [],
                this.outEdges = [],
                this.edges = [],
                this.hostGraph,
                this[zn] = null == e ? -1 : e
            }
            function i(t, e, i) {
                this.node1 = t,
                this.node2 = e,
                this[zn] = null == i ? -1 : i
            }
            var n = t(Ar),
            r = function(t) {
                this._directed = t || !1,
                this.nodes = [],
                this.edges = [],
                this._nodesMap = {},
                this._edgesMap = {},
                this.data,
                this.edgeData
            },
            a = r[xr];
            a.type = "graph",
            a.isDirected = function() {
                return this._directed
            },
            a.addNode = function(t, i) {
                t = t || "" + i;
                var n = this._nodesMap;
                if (!n[t]) {
                    var r = new e(t, i);
                    return r.hostGraph = this,
                    this.nodes.push(r),
                    n[t] = r,
                    r
                }
            },
            a.getNodeByIndex = function(t) {
                var e = this.data[je](t);
                return this.nodes[e]
            },
            a.getNodeById = function(t) {
                return this._nodesMap[t]
            },
            a.addEdge = function(t, n, r) {
                var a = this._nodesMap,
                o = this._edgesMap;
                if (typeof t === yn && (t = this.nodes[t]), typeof n === yn && (n = this.nodes[n]), t instanceof e || (t = a[t]), n instanceof e || (n = a[n]), t && n) {
                    var s = t.id + "-" + n.id;
                    if (!o[s]) {
                        var l = new i(t, n, r);
                        return l.hostGraph = this,
                        this._directed && (t.outEdges.push(l), n.inEdges.push(l)),
                        t.edges.push(l),
                        t !== n && n.edges.push(l),
                        this.edges.push(l),
                        o[s] = l,
                        l
                    }
                }
            },
            a.getEdgeByIndex = function(t) {
                var e = this.edgeData[je](t);
                return this.edges[e]
            },
            a.getEdge = function(t, i) {
                t instanceof e && (t = t.id),
                i instanceof e && (i = i.id);
                var n = this._edgesMap;
                return this._directed ? n[t + "-" + i] : n[t + "-" + i] || n[i + "-" + t]
            },
            a[C] = function(t, e) {
                for (var i = this.nodes,
                n = i[Wn], r = 0; n > r; r++) i[r][zn] >= 0 && t.call(e, i[r], r)
            },
            a.eachEdge = function(t, e) {
                for (var i = this.edges,
                n = i[Wn], r = 0; n > r; r++) i[r][zn] >= 0 && i[r].node1[zn] >= 0 && i[r].node2[zn] >= 0 && t.call(e, i[r], r)
            },
            a.breadthFirstTraverse = function(t, i, n, r) {
                if (i instanceof e || (i = this._nodesMap[i]), i) {
                    for (var a = "out" === n ? "outEdges": "in" === n ? "inEdges": "edges", o = 0; o < this.nodes[Wn]; o++) this.nodes[o].__visited = !1;
                    if (!t.call(r, i, null)) for (var s = [i]; s[Wn];) for (var l = s.shift(), u = l[a], o = 0; o < u[Wn]; o++) {
                        var c = u[o],
                        h = c.node1 === l ? c.node2: c.node1;
                        if (!h.__visited) {
                            if (t.call(h, h, l)) return;
                            s.push(h),
                            h.__visited = !0
                        }
                    }
                }
            },
            a[er] = function() {
                for (var t = this.data,
                e = this.edgeData,
                i = this.nodes,
                n = this.edges,
                r = 0,
                a = i[Wn]; a > r; r++) i[r][zn] = -1;
                for (var r = 0,
                a = t.count(); a > r; r++) i[t[je](r)][zn] = r;
                e.filterSelf(function(t) {
                    var i = n[e[je](t)];
                    return i.node1[zn] >= 0 && i.node2[zn] >= 0
                });
                for (var r = 0,
                a = n[Wn]; a > r; r++) n[r][zn] = -1;
                for (var r = 0,
                a = e.count(); a > r; r++) n[e[je](r)][zn] = r
            },
            a.clone = function() {
                for (var t = new r(this._directed), e = this.nodes, i = this.edges, n = 0; n < e[Wn]; n++) t.addNode(e[n].id, e[n][zn]);
                for (var n = 0; n < i[Wn]; n++) {
                    var a = i[n];
                    t.addEdge(a.node1.id, a.node2.id, a[zn])
                }
                return t
            },
            e[xr] = {
                constructor: e,
                degree: function() {
                    return this.edges[Wn]
                },
                inDegree: function() {
                    return this.inEdges[Wn]
                },
                outDegree: function() {
                    return this.outEdges[Wn]
                },
                getModel: function(t) {
                    if (! (this[zn] < 0)) {
                        var e = this.hostGraph,
                        i = e.data[hi](this[zn]);
                        return i[fr](t)
                    }
                }
            },
            i[xr][fr] = function(t) {
                if (! (this[zn] < 0)) {
                    var e = this.hostGraph,
                    i = e.edgeData[hi](this[zn]);
                    return i[fr](t)
                }
            };
            var o = function(t, e) {
                return {
                    getValue: function(i) {
                        var n = this[t][e];
                        return n.get(n.getDimension(i || "value"), this[zn])
                    },
                    setVisual: function(i, n) {
                        this[zn] >= 0 && this[t][e][Ue](this[zn], i, n)
                    },
                    getVisual: function(i, n) {
                        return this[t][e][gi](this[zn], i, n)
                    },
                    setLayout: function(i, n) {
                        this[zn] >= 0 && this[t][e][He](this[zn], i, n)
                    },
                    getLayout: function() {
                        return this[t][e][bi](this[zn])
                    },
                    getGraphicEl: function() {
                        return this[t][e][Mi](this[zn])
                    },
                    getRawIndex: function() {
                        return this[t][e][je](this[zn])
                    }
                }
            };
            return n.mixin(e, o("hostGraph", "data")),
            n.mixin(i, o("hostGraph", "edgeData")),
            r.Node = e,
            r.Edge = i,
            r
        }),
        e("echarts/component/axis/RadiusAxisView", [Tr, Ar, Si, "./AxisBuilder", Ei],
        function(t) {
            function e(t, e, i) {
                return {
                    position: [t.cx, t.cy],
                    rotation: i / 180 * Math.PI,
                    labelDirection: -1,
                    tickDirection: -1,
                    nameDirection: 1,
                    labelRotation: e[fr](g).get(o),
                    z2: 1
                }
            }
            var i = t(Ar),
            n = t(Si),
            r = t("./AxisBuilder"),
            a = [x, g, m, u],
            s = [y, "splitArea"];
            t(Ei)[_n]({
                type: "radiusAxis",
                render: function(t, n) {
                    if (this.group[cn](), t.get("show")) {
                        var o = n[Re]("polar", t.get(D)),
                        l = o[ln].getAngleAxis(),
                        u = t.axis,
                        c = o[ln],
                        h = u.getTicksCoords(),
                        d = l[Fi]()[0],
                        f = u[Fi](),
                        p = e(c, t, d),
                        v = new r(t, p);
                        i.each(a, v.add, v),
                        this.group.add(v.getGroup()),
                        i.each(s,
                        function(e) {
                            t.get(e + ".show") && this["_" + e](t, c, d, f, h)
                        },
                        this)
                    }
                },
                _splitLine: function(t, e, r, a, o) {
                    var s = t[fr](y),
                    l = s[fr](Ke),
                    u = l.get("color"),
                    c = 0;
                    u = u instanceof Array ? u: [u];
                    for (var h = [], d = 0; d < o[Wn]; d++) {
                        var f = c++%u[Wn];
                        h[f] = h[f] || [],
                        h[f].push(new n[be]({
                            shape: {
                                cx: e.cx,
                                cy: e.cy,
                                r: o[d]
                            },
                            silent: !0
                        }))
                    }
                    for (var d = 0; d < h[Wn]; d++) this.group.add(n.mergePath(h[d], {
                        style: i[qn]({
                            stroke: u[d % u[Wn]],
                            fill: null
                        },
                        l[ti]()),
                        silent: !0
                    }))
                },
                _splitArea: function(t, e, r, a, o) {
                    var s = t[fr]("splitArea"),
                    l = s[fr]("areaStyle"),
                    u = l.get("color"),
                    c = 0;
                    u = u instanceof Array ? u: [u];
                    for (var h = [], d = o[0], f = 1; f < o[Wn]; f++) {
                        var p = c++%u[Wn];
                        h[p] = h[p] || [],
                        h[p].push(new n[_i]({
                            shape: {
                                cx: e.cx,
                                cy: e.cy,
                                r0: d,
                                r: o[f],
                                startAngle: 0,
                                endAngle: 2 * Math.PI
                            },
                            silent: !0
                        })),
                        d = o[f]
                    }
                    for (var f = 0; f < h[Wn]; f++) this.group.add(n.mergePath(h[f], {
                        style: i[qn]({
                            fill: u[f % u[Wn]]
                        },
                        l[V]()),
                        silent: !0
                    }))
                }
            })
        }),
        e("echarts/component/dataZoom/history", [Tr, Ar],
        function(t) {
            function e(t) {
                var e = t[r];
                return e || (e = t[r] = [{}]),
                e
            }
            var i = t(Ar),
            n = i.each,
            r = "\x00_ec_hist_store",
            a = {
                push: function(t, i) {
                    var r = e(t);
                    n(i,
                    function(e, i) {
                        for (var n = r[Wn] - 1; n >= 0; n--) {
                            var a = r[n];
                            if (a[i]) break
                        }
                        if (0 > n) {
                            var o = t[Ee]({
                                mainType: "dataZoom",
                                subType: "select",
                                id: i
                            })[0];
                            if (o) {
                                var s = o.getPercentRange();
                                r[0][i] = {
                                    dataZoomId: i,
                                    start: s[0],
                                    end: s[1]
                                }
                            }
                        }
                    }),
                    r.push(i)
                },
                pop: function(t) {
                    var i = e(t),
                    r = i[i[Wn] - 1];
                    i[Wn] > 1 && i.pop();
                    var a = {};
                    return n(r,
                    function(t, e) {
                        for (var n = i[Wn] - 1; n >= 0; n--) {
                            var t = i[n][e];
                            if (t) {
                                a[e] = t;
                                break
                            }
                        }
                    }),
                    a
                },
                clear: function(t) {
                    t[r] = null
                },
                count: function(t) {
                    return e(t)[Wn]
                }
            };
            return a
        }),
        e("echarts/component/dataZoomSelect", [Tr, "./dataZoom/typeDefaulter", "./dataZoom/DataZoomModel", "./dataZoom/DataZoomView", "./dataZoom/SelectZoomModel", "./dataZoom/SelectZoomView", "./dataZoom/dataZoomProcessor", "./dataZoom/dataZoomAction"],
        function(t) {
            t("./dataZoom/typeDefaulter"),
            t("./dataZoom/DataZoomModel"),
            t("./dataZoom/DataZoomView"),
            t("./dataZoom/SelectZoomModel"),
            t("./dataZoom/SelectZoomView"),
            t("./dataZoom/dataZoomProcessor"),
            t("./dataZoom/dataZoomAction")
        }),
        e("echarts/component/timeline/TimelineView", [Tr, "../../view/Component"],
        function(t) {
            var e = t("../../view/Component");
            return e[jn]({
                type: "timeline"
            })
        }),
        e("echarts/component/timeline/TimelineAxis", [Tr, Ar, "../../coord/Axis", "../../coord/axisHelper"],
        function(t) {
            var e = t(Ar),
            i = t("../../coord/Axis"),
            n = t("../../coord/axisHelper"),
            r = function(t, e, n, r) {
                i.call(this, t, e, n),
                this.type = r || "value",
                this._autoLabelInterval,
                this.model = null
            };
            return r[xr] = {
                constructor: r,
                getLabelInterval: function() {
                    var t = this.model,
                    i = t[fr](ii),
                    r = i.get(R);
                    if (null != r && "auto" != r) return r;
                    var r = this._autoLabelInterval;
                    return r || (r = this._autoLabelInterval = n.getAxisLabelInterval(e.map(this.scale[qi](), this[B], this), n[ee](this, i.get(v)), i[fr](on)[rn](), t.get(l) === O)),
                    r
                },
                isLabelIgnored: function(t) {
                    if (this.type === te) {
                        var e = this.getLabelInterval();
                        return typeof e === Sn && !e(t, this.scale[Wi](t)) || t % (e + 1)
                    }
                }
            },
            e[vn](r, i),
            r
        }),
        e("echarts/component/dataZoom/roams", [Tr, Ar, "../../component/helper/RoamController", "../../util/throttle"],
        function(t) {
            function e(t) {
                var e = t.getZr();
                return e[d] || (e[d] = {})
            }
            function i(t, e, i) {
                var n = new u(t.getZr());
                return n.enable(),
                n.on("pan", h(r, i)),
                n.on("zoom", h(a, i)),
                n
            }
            function n(t) {
                l.each(t,
                function(e, i) {
                    e.count || (e.controller.off("pan").off("zoom"), delete t[i])
                })
            }
            function r(t, e, i) {
                o(t,
                function(n) {
                    return n.panGetRange(t.controller, e, i)
                })
            }
            function a(t, e, i, n) {
                o(t,
                function(r) {
                    return r.zoomGetRange(t.controller, e, i, n)
                })
            }
            function o(t, e) {
                var i = [];
                l.each(t.dataZoomInfos,
                function(t) {
                    var n = e(t);
                    n && i.push({
                        dataZoomId: t.dataZoomId,
                        start: n[0],
                        end: n[1]
                    })
                }),
                t[Un](i)
            }
            function s(t, e) {
                t[Un]({
                    type: "dataZoom",
                    batch: e
                })
            }
            var l = t(Ar),
            u = t("../../component/helper/RoamController"),
            c = t("../../util/throttle"),
            h = l.curry,
            d = "\x00_ec_dataZoom_roams",
            f = {
                register: function(t, r) {
                    var a = e(t),
                    o = r.dataZoomId,
                    u = r.coordId;
                    l.each(a,
                    function(t) {
                        var e = t.dataZoomInfos;
                        e[o] && l[gn](r.allCoordIds, u) < 0 && (delete e[o], t.count--)
                    }),
                    n(a);
                    var h = a[u];
                    h || (h = a[u] = {
                        coordId: u,
                        dataZoomInfos: {},
                        count: 0
                    },
                    h.controller = i(t, r, h), h[Un] = l.curry(s, t));
                    var d = r[ln][un]().clone();
                    h.controller[T] = function() {
                        return d
                    },
                    c.createOrUpdate(h, Un, r.throttleRate, "fixRate"),
                    !h.dataZoomInfos[o] && h.count++,
                    h.dataZoomInfos[o] = r
                },
                unregister: function(t, i) {
                    var r = e(t);
                    l.each(r,
                    function(t) {
                        var e = t.dataZoomInfos;
                        e[i] && (delete e[i], t.count--)
                    }),
                    n(r)
                },
                shouldRecordRange: function(t, e) {
                    if (t && "dataZoom" === t.type && t.batch) for (var i = 0,
                    n = t.batch[Wn]; n > i; i++) if (t.batch[i].dataZoomId === e) return ! 1;
                    return ! 0
                },
                generateCoordId: function(t) {
                    return t.type + "\x00_" + t.id
                }
            };
            return f
        }),
        e("echarts/visual/VisualMapping", [Tr, Ar, Mr, Xi],
        function(t) {
            function e(t) {
                var e = t.pieceList;
                t.hasSpecialVisual = !1,
                d.each(e,
                function(e, i) {
                    e.originIndex = i,
                    null != e.visual && (t.hasSpecialVisual = !0)
                })
            }
            function i(t) {
                var e = t.categories,
                i = t.visual,
                n = t.categoryMap = {};
                if (v(e,
                function(t, e) {
                    n[t] = e
                }), !d[An](i)) {
                    var r = [];
                    d[Yn](i) ? v(i,
                    function(t, e) {
                        var i = n[e];
                        r[null != i ? i: m] = t
                    }) : r[m] = i,
                    i = t.visual = r
                }
                for (var a = e[Wn] - 1; a >= 0; a--) null == i[a] && (delete n[e[a]], e.pop())
            }
            function n(t, e) {
                var i = t.visual,
                n = [];
                d[Yn](i) ? v(i,
                function(t) {
                    n.push(t)
                }) : null != i && n.push(i);
                var r = {
                    color: 1,
                    symbol: 1
                };
                e || 1 !== n[Wn] || t.type in r || (n[1] = n[0]),
                t.visual = n
            }
            function r(t) {
                return {
                    applyVisual: function(e, i, n) {
                        e = this.mapValueToVisual(e),
                        n("color", t(i("color"), e))
                    },
                    _doMap: u([0, 1])
                }
            }
            function a(t, e) {
                var i = this[zi].visual;
                return i[Math.round(p(e, [0, 1], [0, i[Wn] - 1], !0))] || {}
            }
            function o(t) {
                return function(e, i, n) {
                    n(t, this.mapValueToVisual(e))
                }
            }
            function s(t) {
                var e = this[zi].visual;
                return e[this[zi].loop && t !== m ? t % e[Wn] : t]
            }
            function l() {
                return this[zi].visual[0]
            }
            function u(t) {
                return {
                    linear: function(e) {
                        return p(e, t, this[zi].visual, !0)
                    },
                    category: s,
                    piecewise: function(e, i) {
                        var n = c.call(this, i);
                        return null == n && (n = p(e, t, this[zi].visual, !0)),
                        n
                    },
                    fixed: l
                }
            }
            function c(t) {
                var e = this[zi],
                i = e.pieceList;
                if (e.hasSpecialVisual) {
                    var n = y.findPieceIndex(t, i),
                    r = i[n];
                    if (r && r.visual) return r.visual[this.type]
                }
            }
            function h(t, e, i) {
                return t ? i >= e: i > e
            }
            var d = t(Ar),
            f = t(Mr),
            p = t(Xi)[Ge],
            v = d.each,
            g = d[Yn],
            m = -1,
            y = function(t) {
                var r = t.mappingMethod,
                a = t.type,
                o = this[zi] = d.clone(t);
                this.type = a,
                this.mappingMethod = r,
                this._normalizeData = _[r];
                var s = x[a];
                this.applyVisual = s.applyVisual,
                this.getColorMapper = s.getColorMapper,
                this._doMap = s._doMap[r],
                "piecewise" === r ? (n(o), e(o)) : r === te ? o.categories ? i(o) : n(o, !0) : (d.assert(r !== b || o.dataExtent), n(o))
            };
            y[xr] = {
                constructor: y,
                mapValueToVisual: function(t) {
                    var e = this._normalizeData(t);
                    return this._doMap(e, t)
                },
                getNormalizer: function() {
                    return d.bind(this._normalizeData, this)
                }
            };
            var x = y.visualHandlers = {
                color: {
                    applyVisual: o("color"),
                    getColorMapper: function() {
                        var t = this[zi],
                        e = d.map(t.visual, f.parse);
                        return d.bind(t.mappingMethod === te ?
                        function(t, e) {
                            return ! e && (t = this._normalizeData(t)),
                            s(this, t)
                        }: function(t, i, n) {
                            var r = !!n;
                            return ! i && (t = this._normalizeData(t)),
                            n = f.fastMapToColor(t, e, n),
                            r ? n: d.stringify(n, "rgba")
                        },
                        this)
                    },
                    _doMap: {
                        linear: function(t) {
                            return f.mapToColor(t, this[zi].visual)
                        },
                        category: s,
                        piecewise: function(t, e) {
                            var i = c.call(this, e);
                            return null == i && (i = f.mapToColor(t, this[zi].visual)),
                            i
                        },
                        fixed: l
                    }
                },
                colorHue: r(function(t, e) {
                    return f.modifyHSL(t, e)
                }),
                colorSaturation: r(function(t, e) {
                    return f.modifyHSL(t, null, e)
                }),
                colorLightness: r(function(t, e) {
                    return f.modifyHSL(t, null, null, e)
                }),
                colorAlpha: r(function(t, e) {
                    return f.modifyAlpha(t, e)
                }),
                opacity: {
                    applyVisual: o(Yi),
                    _doMap: u([0, 1])
                },
                symbol: {
                    applyVisual: function(t, e, i) {
                        var n = this.mapValueToVisual(t);
                        if (d[pn](n)) i(se, n);
                        else if (g(n)) for (var r in n) n.hasOwnProperty(r) && i(r, n[r])
                    },
                    _doMap: {
                        linear: a,
                        category: s,
                        piecewise: function(t, e) {
                            var i = c.call(this, e);
                            return null == i && (i = a.call(this, t)),
                            i
                        },
                        fixed: l
                    }
                },
                symbolSize: {
                    applyVisual: o(oe),
                    _doMap: u([0, 1])
                }
            },
            _ = {
                linear: function(t) {
                    return p(t, this[zi].dataExtent, [0, 1], !0)
                },
                piecewise: function(t) {
                    var e = this[zi].pieceList,
                    i = y.findPieceIndex(t, e, !0);
                    return null != i ? p(i, [0, e[Wn] - 1], [0, 1], !0) : void 0
                },
                category: function(t) {
                    var e = this[zi].categories ? this[zi].categoryMap[t] : t;
                    return null == e ? m: e
                },
                fixed: d.noop
            };
            return y.addVisualHandler = function(t, e) {
                x[t] = e
            },
            y.isValidType = function(t) {
                return x.hasOwnProperty(t)
            },
            y.eachVisual = function(t, e, i) {
                d[Yn](t) ? d.each(t, e, i) : e.call(i, t)
            },
            y.mapVisual = function(t, e, i) {
                var n, r = d[An](t) ? [] : d[Yn](t) ? {}: (n = !0, null);
                return y.eachVisual(t,
                function(t, a) {
                    var o = e.call(i, t, a);
                    n ? r = o: r[a] = o
                }),
                r
            },
            y.retrieveVisuals = function(t) {
                var e, i = {};
                return t && v(x,
                function(n, r) {
                    t.hasOwnProperty(r) && (i[r] = t[r], e = !0)
                }),
                e ? i: null
            },
            y.prepareVisualTypes = function(t) {
                if (g(t)) {
                    var e = [];
                    v(t,
                    function(t, i) {
                        e.push(i)
                    }),
                    t = e
                } else {
                    if (!d[An](t)) return [];
                    t = t.slice()
                }
                return t.sort(function(t, e) {
                    return "color" === e && "color" !== t && 0 === t[gn]("color") ? 1 : -1
                }),
                t
            },
            y.dependsOn = function(t, e) {
                return "color" === e ? !(!t || 0 !== t[gn](e)) : t === e
            },
            y.findPieceIndex = function(t, e, i) {
                function n(e, i) {
                    var n = Math.abs(e - t);
                    a > n && (a = n, r = i)
                }
                for (var r, a = 1 / 0,
                o = 0,
                s = e[Wn]; s > o; o++) {
                    var l = e[o].value;
                    if (null != l) {
                        if (l === t) return o;
                        i && n(l, o)
                    }
                }
                for (var o = 0,
                s = e[Wn]; s > o; o++) {
                    var u = e[o],
                    c = u[R],
                    d = u.close;
                    if (c) {
                        if (c[0] === -1 / 0) {
                            if (h(d[1], t, c[1])) return o
                        } else if (1 / 0 === c[1]) {
                            if (h(d[0], c[0], t)) return o
                        } else if (h(d[0], c[0], t) && h(d[1], t, c[1])) return o;
                        i && n(c[0], o),
                        i && n(c[1], o)
                    }
                }
                return i ? 1 / 0 === t ? e[Wn] - 1 : t === -1 / 0 ? 0 : r: void 0
            },
            y
        }),
        e("echarts/component/helper/BrushController", [Tr, "zrender/mixin/Eventful", Ar, Si, "./interactionMutex", "../../data/DataDiffer"],
        function(t) {
            function e(t) {
                B.call(this),
                this._zr = t,
                this.group = new H.Group,
                this._brushType,
                this._brushOption,
                this._panels,
                this._track = [],
                this._dragging,
                this._covers = [],
                this._creatingCover,
                this._creatingPanel,
                this._enableGlobalPan,
                this._uid = "brushController_" + ne++,
                this._handlers = {},
                q(re,
                function(t, e) {
                    this._handlers[e] = G.bind(t, this)
                },
                this)
            }
            function i(t, e) {
                var i = t._zr;
                t._enableGlobalPan || F.take(i, K, t._uid),
                q(t._handlers,
                function(t, e) {
                    i.on(e, t)
                }),
                t._brushType = e.brushType,
                t._brushOption = G.merge(G.clone(ie), e, !0)
            }
            function n(t) {
                var e = t._zr;
                F.release(e, K, t._uid),
                q(t._handlers,
                function(t, i) {
                    e.off(i, t)
                }),
                t._brushType = t._brushOption = null
            }
            function r(t, e) {
                var i = ae[e.brushType].createCover(t, e);
                return s(i),
                i.__brushOption = e,
                t.group.add(i),
                i
            }
            function a(t, e) {
                var i = u(e);
                return i.endCreating && (i.endCreating(t, e), s(e)),
                e
            }
            function o(t, e) {
                var i = e.__brushOption;
                u(e).updateCoverShape(t, e, i.range, i)
            }
            function s(t) {
                t[kn](function(t) {
                    t.z = $,
                    t.z2 = $
                })
            }
            function l(t, e) {
                u(e).updateCommon(t, e),
                o(t, e)
            }
            function u(t) {
                return ae[t.__brushOption.brushType]
            }
            function c(t, e, i) {
                var n = t._panels;
                if (!n) return ! 0;
                var r;
                return q(n,
                function(t) {
                    t[ji](e, i) && (r = t)
                }),
                r
            }
            function h(t, e) {
                var i = t._panels;
                if (!i) return ! 0;
                var n = e.__brushOption.panelId;
                return null != n ? i[n] : !0
            }
            function d(t) {
                var e = t._covers,
                i = e[Wn];
                return q(e,
                function(e) {
                    t.group[Xn](e)
                },
                t),
                e[Wn] = 0,
                !!i
            }
            function f(t, e) {
                var i = U(t._covers,
                function(t) {
                    var e = t.__brushOption,
                    i = G.clone(e.range);
                    return {
                        brushType: e.brushType,
                        panelId: e.panelId,
                        range: i
                    }
                });
                t[Zn]("brush", i, {
                    isEnd: !!e.isEnd,
                    removeOnClick: !!e.removeOnClick
                })
            }
            function p(t) {
                var e = t._track;
                if (!e[Wn]) return ! 1;
                var i = e[e[Wn] - 1],
                n = e[0],
                r = i[0] - n[0],
                a = i[1] - n[1],
                o = Y(r * r + a * a, .5);
                return o > J
            }
            function v(t) {
                var e = t[Wn] - 1;
                return 0 > e && (e = 0),
                [t[0], t[e]]
            }
            function g(t, e, i, n) {
                var r = new H.Group;
                return r.add(new H.Rect({
                    name: "main",
                    style: b(i),
                    silent: !0,
                    draggable: !0,
                    cursor: "move",
                    drift: W(t, e, r, "nswe"),
                    ondragend: W(f, e, {
                        isEnd: !0
                    })
                })),
                q(n,
                function(i) {
                    r.add(new H.Rect({
                        name: i,
                        style: {
                            opacity: 0
                        },
                        draggable: !0,
                        silent: !0,
                        invisible: !0,
                        drift: W(t, e, r, i),
                        ondragend: W(f, e, {
                            isEnd: !0
                        })
                    }))
                }),
                r
            }
            function m(t, e, i, n) {
                var r = n.brushStyle[xe] || 0,
                a = X(r, Q),
                o = i[0][0],
                s = i[1][0],
                l = o - r / 2,
                u = s - r / 2,
                c = i[0][1],
                h = i[1][1],
                d = c - a + r / 2,
                f = h - a + r / 2,
                p = c - o,
                v = h - s,
                g = p + r,
                m = v + r;
                x(t, e, "main", o, s, p, v),
                n.transformable && (x(t, e, "w", l, u, a, m), x(t, e, "e", d, u, a, m), x(t, e, "n", l, u, g, a), x(t, e, "s", l, f, g, a), x(t, e, "nw", l, u, a, a), x(t, e, "ne", d, u, a, a), x(t, e, "sw", l, f, a, a), x(t, e, "se", d, f, a, a))
            }
            function y(t, e) {
                var i = e.__brushOption,
                n = i.transformable,
                r = e[di](0);
                r[si](b(i)),
                r.attr({
                    silent: !n,
                    cursor: n ? "move": "default"
                }),
                q(["w", "e", "n", "s", "se", "sw", "ne", "nw"],
                function(i) {
                    var r = e.childOfName(i),
                    a = T(t, i);
                    r && r.attr({
                        silent: !n,
                        invisible: !n,
                        cursor: n ? ee[a] + "-resize": null
                    })
                })
            }
            function x(t, e, i, n, r, a, o) {
                var s = e.childOfName(i);
                s && s[ci](D(I(t, e, [[n, r], [n + a, r + o]])))
            }
            function b(t) {
                return G[qn]({
                    strokeNoScale: !0
                },
                t.brushStyle)
            }
            function M(t, e, i, n) {
                var r = [j(t, i), j(e, n)],
                a = [X(t, i), X(e, n)];
                return [[r[0], a[0]], [r[1], a[1]]]
            }
            function A(t) {
                return H.getTransform(t.group)
            }
            function T(t, e) {
                if (e[Wn] > 1) {
                    e = e.split("");
                    var i = [T(t, e[0]), T(t, e[1])];
                    return ("e" === i[0] || "w" === i[0]) && i[S](),
                    i.join("")
                }
                var n = {
                    w: "left",
                    e: "right",
                    n: "top",
                    s: "bottom"
                },
                r = {
                    left: "w",
                    right: "e",
                    top: "n",
                    bottom: "s"
                },
                i = H.transformDirection(n[e], A(t));
                return r[i]
            }
            function C(t, e, i, n, r, a, o) {
                var s = n.__brushOption,
                u = t(s.range),
                c = P(i, a, o);
                q(r.split(""),
                function(t) {
                    var e = te[t];
                    u[e[0]][e[1]] += c[e[0]]
                }),
                s.range = e(M(u[0][0], u[1][0], u[0][1], u[1][1])),
                l(i, n),
                f(i, {
                    isEnd: !1
                })
            }
            function k(t, e, i, n) {
                var r = e.__brushOption.range,
                a = P(t, i, n);
                q(r,
                function(t) {
                    t[0] += a[0],
                    t[1] += a[1]
                }),
                l(t, e),
                f(t, {
                    isEnd: !1
                })
            }
            function P(t, e, i) {
                var n = t.group,
                r = n.transformCoordToLocal(e, i),
                a = n.transformCoordToLocal(0, 0);
                return [r[0] - a[0], r[1] - a[1]]
            }
            function I(t, e, i) {
                var n = h(t, e);
                if (n === !0) return G.clone(i);
                var r = n[en]();
                return G.map(i,
                function(t) {
                    var e = t[0];
                    e = X(e, r.x),
                    e = j(e, r.x + r.width);
                    var i = t[1];
                    return i = X(i, r.y),
                    i = j(i, r.y + r[nr]),
                    [e, i]
                })
            }
            function D(t) {
                var e = j(t[0][0], t[1][0]),
                i = j(t[0][1], t[1][1]),
                n = X(t[0][0], t[1][0]),
                r = X(t[0][1], t[1][1]);
                return {
                    x: e,
                    y: i,
                    width: n - e,
                    height: r - i
                }
            }
            function z(t, e) {
                var i = e[w],
                n = e[_],
                r = t._zr;
                if (t._brushType) {
                    for (var a, o = t._panels,
                    s = t._covers,
                    l = 0; l < s[Wn]; l++) if (ae[s[l].__brushOption.brushType][ji](s[l], i, n)) {
                        a = !0;
                        break
                    }
                    a || (o ? q(o,
                    function(t) {
                        t[ji](i, n) && r.setCursorStyle("crosshair")
                    }) : r.setCursorStyle("crosshair"))
                }
            }
            function V(t) {
                var e = t.event;
                e.preventDefault && e.preventDefault()
            }
            function R(t, e, i) {
                return t.childOfName("main")[ji](e, i)
            }
            function O(t, e, i) {
                var n, s = e[w],
                l = e[_],
                u = t._creatingCover,
                h = t._creatingPanel,
                f = t._brushOption;
                if (t._track.push(t.group.transformCoordToLocal(s, l)), p(t) || u) {
                    if (h && !u) {
                        "single" === f.brushMode && d(t);
                        var v = G.clone(f);
                        v.panelId = h === !0 ? null: h.__brushPanelId,
                        u = t._creatingCover = r(t, v),
                        t._covers.push(u)
                    }
                    if (u) {
                        var g = ae[t._brushType],
                        m = u.__brushOption;
                        m.range = g.getCreatingRange(I(t, u, t._track)),
                        i && (a(t, u), g.updateCommon(t, u)),
                        o(t, u),
                        n = {
                            isEnd: i
                        }
                    }
                } else i && "single" === f.brushMode && f.removeOnClick && c(t, s, l) && d(t) && (n = {
                    isEnd: i,
                    removeOnClick: !0
                });
                return n
            }
            function E(t) {
                if (this._dragging) {
                    V(t);
                    var e = O(this, t, !0);
                    this._dragging = !1,
                    this._track = [],
                    this._creatingCover = null,
                    e && f(this, e)
                }
            }
            function N(t) {
                return {
                    createCover: function(e, i) {
                        return g(W(C,
                        function(e) {
                            var i = [e, [0, 100]];
                            return t && i[S](),
                            i
                        },
                        function(e) {
                            return e[t]
                        }), e, i, [["w", "e"], ["n", "s"]][t])
                    },
                    getCreatingRange: function(e) {
                        var i = v(e),
                        n = j(i[0][t], i[1][t]),
                        r = X(i[0][t], i[1][t]);
                        return [n, r]
                    },
                    updateCoverShape: function(e, i, n, r) {
                        var a, o = r.brushStyle.width;
                        if (null == o) {
                            var s = h(e, i),
                            l = 0;
                            if (s !== !0) {
                                var u = s[en]();
                                o = t ? u.width: u[nr],
                                l = t ? u.x: u.y
                            }
                            a = [l, l + (o || 0)]
                        } else a = [ - o / 2, o / 2];
                        var c = [n, a];
                        t && c[S](),
                        m(e, i, c, r)
                    },
                    updateCommon: y,
                    contain: R
                }
            }
            var B = t("zrender/mixin/Eventful"),
            G = t(Ar),
            H = t(Si),
            F = t("./interactionMutex"),
            Z = t("../../data/DataDiffer"),
            W = G.curry,
            q = G.each,
            U = G.map,
            j = Math.min,
            X = Math.max,
            Y = Math.pow,
            $ = 1e4,
            J = 6,
            Q = 6,
            K = "globalPan",
            te = {
                w: [0, 0],
                e: [0, 1],
                n: [1, 0],
                s: [1, 1]
            },
            ee = {
                w: "ew",
                e: "ew",
                n: "ns",
                s: "ns",
                ne: "nesw",
                sw: "nesw",
                nw: "nwse",
                se: "nwse"
            },
            ie = {
                brushStyle: {
                    lineWidth: 2,
                    stroke: "rgba(0,0,0,0.3)",
                    fill: "rgba(0,0,0,0.1)"
                },
                transformable: !0,
                brushMode: "single",
                removeOnClick: !1
            },
            ne = 0;
            e[xr] = {
                constructor: e,
                enableBrush: function(t) {
                    return this._brushType && n(this),
                    t.brushType && i(this, t),
                    this
                },
                setPanels: function(t) {
                    var e = this._panels || {},
                    i = this._panels = t && t[Wn] && {},
                    n = this.group;
                    return i && q(t,
                    function(t) {
                        var r = t.panelId,
                        a = e[r];
                        a || (a = new H.Rect({
                            silent: !0,
                            invisible: !0
                        }), n.add(a)),
                        a.attr("shape", t.rect),
                        a.__brushPanelId = r,
                        i[r] = a,
                        e[r] = null
                    }),
                    q(e,
                    function(t) {
                        t && n[Xn](t)
                    }),
                    this
                },
                mount: function(t) {
                    t = t || {},
                    this._enableGlobalPan = t.enableGlobalPan;
                    var e = this.group;
                    return this._zr.add(e),
                    e.attr({
                        position: t[$i] || [0, 0],
                        rotation: t[ni] || 0,
                        scale: t.scale || [1, 1]
                    }),
                    this
                },
                eachCover: function(t, e) {
                    q(this._covers, t, e)
                },
                updateCovers: function(t) {
                    function e(t, e) {
                        return (null != t.id ? t.id: s + e) + "-" + t.brushType
                    }
                    function i(t, i) {
                        return e(t.__brushOption, i)
                    }
                    function n(e, i) {
                        var n = t[e];
                        if (null != i && u[i] === d) c[e] = u[i];
                        else {
                            var o = c[e] = null != i ? (u[i].__brushOption = n, u[i]) : a(h, r(h, n));
                            l(h, o)
                        }
                    }
                    function o(t) {
                        u[t] !== d && h.group[Xn](u[t])
                    }
                    t = G.map(t,
                    function(t) {
                        return G.merge(G.clone(ie), t, !0)
                    });
                    var s = "\x00-brush-index-",
                    u = this._covers,
                    c = this._covers = [],
                    h = this,
                    d = this._creatingCover;
                    return new Z(u, t, i, e).add(n)[er](n)[Xn](o)[Qe](),
                    this
                },
                unmount: function() {
                    return this.enableBrush(!1),
                    d(this),
                    this._zr[Xn](this.group),
                    this
                },
                dispose: function() {
                    this.unmount(),
                    this.off()
                }
            },
            G.mixin(e, B);
            var re = {
                mousedown: function(t) {
                    if (this._dragging) E.call(this, t);
                    else if (!t[Vn] || !t[Vn][L]) {
                        V(t);
                        var e = t[w],
                        i = t[_];
                        this._creatingCover = null;
                        var n = this._creatingPanel = c(this, e, i);
                        n && (this._dragging = !0, this._track = [this.group.transformCoordToLocal(e, i)])
                    }
                },
                mousemove: function(t) {
                    if (z(this, t), this._dragging) {
                        V(t);
                        var e = O(this, t, !1);
                        e && f(this, e)
                    }
                },
                mouseup: E
            },
            ae = {
                lineX: N(0),
                lineY: N(1),
                rect: {
                    createCover: function(t, e) {
                        return g(W(C,
                        function(t) {
                            return t
                        },
                        function(t) {
                            return t
                        }), t, e, ["w", "e", "n", "s", "se", "sw", "ne", "nw"])
                    },
                    getCreatingRange: function(t) {
                        var e = v(t);
                        return M(e[1][0], e[1][1], e[0][0], e[0][1])
                    },
                    updateCoverShape: function(t, e, i, n) {
                        m(t, e, i, n)
                    },
                    updateCommon: y,
                    contain: R
                },
                polygon: {
                    createCover: function(t, e) {
                        var i = new H.Group;
                        return i.add(new H[xi]({
                            name: "main",
                            style: b(e),
                            silent: !0
                        })),
                        i
                    },
                    getCreatingRange: function(t) {
                        return t
                    },
                    endCreating: function(t, e) {
                        e[Xn](e[di](0)),
                        e.add(new H[we]({
                            name: "main",
                            draggable: !0,
                            drift: W(k, t, e),
                            ondragend: W(f, t, {
                                isEnd: !0
                            })
                        }))
                    },
                    updateCoverShape: function(t, e, i) {
                        e[di](0)[ci]({
                            points: I(t, e, i)
                        })
                    },
                    updateCommon: y,
                    contain: R
                }
            };
            return e
        }),
        e("echarts/component/helper/interactionMutex", [Tr, Ei],
        function(t) {
            function e(t) {
                return t[i] || (t[i] = {})
            }
            var i = "\x00_ec_interaction_mutex",
            n = {
                take: function(t, i, n) {
                    var r = e(t);
                    r[i] = n
                },
                release: function(t, i, n) {
                    var r = e(t),
                    a = r[i];
                    a === n && (r[i] = null)
                },
                isTaken: function(t, i) {
                    return !! e(t)[i]
                }
            };
            return t(Ei)[Mn]({
                type: "takeGlobalCursor",
                event: "globalCursorTaken",
                update: "update"
            },
            function() {}),
            n
        }),
        e("echarts/coord/parallel/ParallelAxis", [Tr, Ar, "../Axis"],
        function(t) {
            var e = t(Ar),
            i = t("../Axis"),
            n = function(t, e, n, r, a) {
                i.call(this, t, e, n),
                this.type = r || "value",
                this.axisIndex = a
            };
            return n[xr] = {
                constructor: n,
                model: null
            },
            e[vn](n, i),
            n
        }),
        e("echarts/chart/treemap/helper", [Tr, Ar],
        function(t) {
            var e = t(Ar),
            i = {
                retrieveTargetInfo: function(t, e) {
                    if (t && ("treemapZoomToNode" === t.type || "treemapRootToNode" === t.type)) {
                        var i = e[Kn]().tree.root,
                        n = t.targetNode;
                        if (n && i.contains(n)) return {
                            node: n
                        };
                        var r = t.targetNodeId;
                        if (null != r && (n = i.getNodeById(r))) return {
                            node: n
                        }
                    }
                },
                getPathToRoot: function(t) {
                    for (var e = []; t;) t = t[A],
                    t && e.push(t);
                    return e[S]()
                },
                aboveViewRoot: function(t, n) {
                    var r = i.getPathToRoot(t);
                    return e[gn](r, n) >= 0
                }
            };
            return i
        }),
        e("echarts/chart/treemap/Breadcrumb", [Tr, Si, re, Ar],
        function(t) {
            function e(t, e) {
                this.group = new n.Group,
                t.add(this.group),
                this._onSelect = e || a.noop
            }
            function i(t, e, i, n, r, a) {
                var o = [[r ? t: t - l, e], [t + i, e], [t + i, e + n], [r ? t: t - l, e + n]];
                return ! a && o[Gn](2, 0, [t + i + l, e + n / 2]),
                !r && o.push([t, e + n / 2]),
                o
            }
            var n = t(Si),
            r = t(re),
            a = t(Ar),
            o = 8,
            s = 8,
            l = 5;
            return e[xr] = {
                constructor: e,
                render: function(t, e, i) {
                    var n = t[fr]("breadcrumb"),
                    a = this.group;
                    if (a[cn](), n.get("show") && i) {
                        var o = n[fr](F),
                        s = o[fr](on),
                        l = {
                            pos: {
                                left: n.get("left"),
                                right: n.get("right"),
                                top: n.get("top"),
                                bottom: n.get(rr)
                            },
                            box: {
                                width: e[dr](),
                                height: e[hr]()
                            },
                            emptyItemWidth: n.get("emptyItemWidth"),
                            totalWidth: 0,
                            renderList: []
                        };
                        this._prepare(n, i, l, s),
                        this._renderContent(n, i, l, o, s),
                        r.positionGroup(a, l.pos, l.box)
                    }
                },
                _prepare: function(t, e, i, n) {
                    for (var r = e; r; r = r[A]) {
                        var a = r[fr]().get("name"),
                        l = n.getTextRect(a),
                        u = Math.max(l.width + 2 * o, i.emptyItemWidth);
                        i.totalWidth += u + s,
                        i.renderList.push({
                            node: r,
                            text: a,
                            width: u
                        })
                    }
                },
                _renderContent: function(t, e, o, l, u) {
                    for (var c = 0,
                    h = o.emptyItemWidth,
                    d = t.get(nr), f = r.getAvailableSize(o.pos, o.box), p = o.totalWidth, v = o.renderList, g = v[Wn] - 1; g >= 0; g--) {
                        var m = v[g],
                        y = m.width,
                        x = m.text;
                        p > f.width && (p -= y - h, y = h, x = ""),
                        this.group.add(new n[we]({
                            shape: {
                                points: i(c, 0, y, d, g === v[Wn] - 1, 0 === g)
                            },
                            style: a[qn](l[sn](), {
                                lineJoin: "bevel",
                                text: x,
                                textFill: u[nn](),
                                textFont: u[rn]()
                            }),
                            z: 10,
                            onclick: a.bind(this._onSelect, this, m.node)
                        })),
                        c += y + s
                    }
                },
                remove: function() {
                    this.group[cn]()
                }
            },
            e
        }),
        e("echarts/util/animation", [Tr, Ar],
        function(t) {
            function e() {
                var t, e = [],
                n = {};
                return {
                    add: function(t, r, a, o, s) {
                        return i[pn](o) && (s = o, o = 0),
                        n[t.id] ? !1 : (n[t.id] = 1, e.push({
                            el: t,
                            target: r,
                            time: a,
                            delay: o,
                            easing: s
                        }), !0)
                    },
                    done: function(e) {
                        return t = e,
                        this
                    },
                    start: function() {
                        function i() {
                            r--,
                            r || (e[Wn] = 0, n = {},
                            t && t())
                        }
                        for (var r = e[Wn], a = 0, o = e[Wn]; o > a; a++) {
                            var s = e[a];
                            s.el.animateTo(s[Vn], s.time, s.delay, s.easing, i)
                        }
                        return this
                    }
                }
            }
            var i = t(Ar);
            return {
                createWrap: e
            }
        }),
        e("echarts/chart/graph/adjustEdge", [Tr, "zrender/core/curve", wr],
        function(t) {
            function e(t, e, i) {
                for (var n, c = t[0], h = t[1], d = t[2], f = 1 / 0, p = i * i, v = .1, g = .1;.9 >= g; g += .1) {
                    r[0] = s(c[0], h[0], d[0], g),
                    r[1] = s(c[1], h[1], d[1], g);
                    var m = u(l(r, e) - p);
                    f > m && (f = m, n = g)
                }
                for (var y = 0; 32 > y; y++) {
                    var x = n + v;
                    a[0] = s(c[0], h[0], d[0], n),
                    a[1] = s(c[1], h[1], d[1], n),
                    o[0] = s(c[0], h[0], d[0], x),
                    o[1] = s(c[1], h[1], d[1], x);
                    var m = l(a, e) - p;
                    if (u(m) < .01) break;
                    var _ = l(o, e) - p;
                    v /= 2,
                    0 > m ? _ >= 0 ? n += v: n -= v: _ >= 0 ? n -= v: n += v
                }
                return n
            }
            var i = t("zrender/core/curve"),
            n = t(wr),
            r = [],
            a = [],
            o = [],
            s = i.quadraticAt,
            l = n.distSquare,
            u = Math.abs;
            return function(t, r) {
                function a(t) {
                    var e = t[ce](oe);
                    return e instanceof Array && (e = (e[0] + e[1]) / 2),
                    e
                }
                var o = [],
                s = i.quadraticSubdivide,
                l = [[], [], []],
                u = [[], []],
                c = [];
                r /= 2,
                t.eachEdge(function(t) {
                    var i = t.getLayout(),
                    h = t[ce]("fromSymbol"),
                    d = t[ce]("toSymbol");
                    i.__original || (i.__original = [n.clone(i[0]), n.clone(i[1])], i[2] && i.__original.push(n.clone(i[2])));
                    var f = i.__original;
                    if (null != i[2]) {
                        if (n.copy(l[0], f[0]), n.copy(l[1], f[2]), n.copy(l[2], f[1]), h && "none" != h) {
                            var p = a(t.node1),
                            v = e(l, f[0], p * r);
                            s(l[0][0], l[1][0], l[2][0], v, o),
                            l[0][0] = o[3],
                            l[1][0] = o[4],
                            s(l[0][1], l[1][1], l[2][1], v, o),
                            l[0][1] = o[3],
                            l[1][1] = o[4]
                        }
                        if (d && "none" != d) {
                            var p = a(t.node2),
                            v = e(l, f[1], p * r);
                            s(l[0][0], l[1][0], l[2][0], v, o),
                            l[1][0] = o[1],
                            l[2][0] = o[2],
                            s(l[0][1], l[1][1], l[2][1], v, o),
                            l[1][1] = o[1],
                            l[2][1] = o[2]
                        }
                        n.copy(i[0], l[0]),
                        n.copy(i[1], l[2]),
                        n.copy(i[2], l[1])
                    } else {
                        if (n.copy(u[0], f[0]), n.copy(u[1], f[1]), n.sub(c, u[1], u[0]), n[Ui](c, c), h && "none" != h) {
                            var p = a(t.node1);
                            n.scaleAndAdd(u[0], u[0], c, p * r)
                        }
                        if (d && "none" != d) {
                            var p = a(t.node2);
                            n.scaleAndAdd(u[1], u[1], c, -p * r)
                        }
                        n.copy(i[0], u[0]),
                        n.copy(i[1], u[1])
                    }
                })
            }
        }),
        e("echarts/util/array/nest", [Tr, Ar],
        function(t) {
            function e() {
                function t(e, r) {
                    if (r >= n[Wn]) return e;
                    for (var a = -1,
                    o = e[Wn], s = n[r++], l = {},
                    u = {}; ++a < o;) {
                        var c = s(e[a]),
                        h = u[c];
                        h ? h.push(e[a]) : u[c] = [e[a]]
                    }
                    return i.each(u,
                    function(e, i) {
                        l[i] = t(e, r)
                    }),
                    l
                }
                function e(t, a) {
                    if (a >= n[Wn]) return t;
                    var o = [],
                    s = r[a++];
                    return i.each(t,
                    function(t, i) {
                        o.push({
                            key: i,
                            values: e(t, a)
                        })
                    }),
                    s ? o.sort(function(t, e) {
                        return s(t.key, e.key)
                    }) : o
                }
                var n = [],
                r = [];
                return {
                    key: function(t) {
                        return n.push(t),
                        this
                    },
                    sortKeys: function(t) {
                        return r[n[Wn] - 1] = t,
                        this
                    },
                    entries: function(i) {
                        return e(t(i, 0), 0)
                    }
                }
            }
            var i = t(Ar);
            return e
        }),
        e("echarts/action/roamHelper", [Tr],
        function() {
            var t = {};
            return t.updateCenterAndZoom = function(t, e, n) {
                var r = t.getZoom(),
                a = t.getCenter(),
                o = e.zoom,
                s = t[ae](a);
                if (null != e.dx && null != e.dy) {
                    s[0] -= e.dx,
                    s[1] -= e.dy;
                    var a = t.pointToData(s);
                    t.setCenter(a)
                }
                if (null != o) {
                    if (n) {
                        var l = n.min || 0,
                        u = n.max || 1 / 0;
                        o = Math.max(Math.min(r * o, u), l) / r
                    }
                    t.scale[0] *= o,
                    t.scale[1] *= o;
                    var c = t[$i],
                    h = (e.originX - c[0]) * (o - 1),
                    d = (e.originY - c[1]) * (o - 1);
                    c[0] -= h,
                    c[1] -= d,
                    t[i]();
                    var a = t.pointToData(s);
                    t.setCenter(a),
                    t.setZoom(o * r)
                }
                return {
                    center: t.getCenter(),
                    zoom: t.getZoom()
                }
            },
            t
        }),
        e("echarts/component/dataZoom/SelectZoomModel", [Tr, "./DataZoomModel"],
        function(t) {
            var e = t("./DataZoomModel");
            return e[jn]({
                type: "dataZoom.select"
            })
        }),
        e("echarts/component/dataZoom/SelectZoomView", [Tr, "./DataZoomView"],
        function(t) {
            return t("./DataZoomView")[jn]({
                type: "dataZoom.select"
            })
        }),
        e("echarts/coord/parallel/AxisModel", [Tr, c, Ar, "../../model/mixin/makeStyleMapper", "../axisModelCreator", qe, "../axisModelCommonMixin"],
        function(t) {
            function e(t, e) {
                return e.type || (e.data ? te: "value")
            }
            var i = t(c),
            n = t(Ar),
            r = t("../../model/mixin/makeStyleMapper"),
            a = t("../axisModelCreator"),
            o = t(qe),
            s = i[jn]({
                type: "baseParallelAxis",
                axis: null,
                activeIntervals: [],
                getAreaSelectStyle: function() {
                    return r([["fill", "color"], [xe, "borderWidth"], [ye, N], ["width", "width"], [Yi, Yi]]).call(this[fr]("areaSelectStyle"))
                },
                setActiveIntervals: function(t) {
                    var e = this.activeIntervals = n.clone(t);
                    if (e) for (var i = e[Wn] - 1; i >= 0; i--) o.asc(e[i])
                },
                getActiveState: function(t) {
                    var e = this.activeIntervals;
                    if (!e[Wn]) return ki;
                    if (null == t) return "inactive";
                    for (var i = 0,
                    n = e[Wn]; n > i; i++) if (e[i][0] <= t && t <= e[i][1]) return "active";
                    return "inactive"
                }
            }),
            l = {
                type: "value",
                dim: null,
                areaSelectStyle: {
                    width: 20,
                    borderWidth: 1,
                    borderColor: "rgba(160,197,232)",
                    color: "rgba(160,197,232)",
                    opacity: .3
                },
                realtime: !0,
                z: 10
            };
            return n.merge(s[xr], t("../axisModelCommonMixin")),
            a("parallel", s, e, l),
            s
        }),
        e("echarts/chart/graph/simpleLayoutHelper", [Tr, "./simpleLayoutEdge"],
        function(t) {
            var e = t("./simpleLayoutEdge");
            return function(t) {
                var i = t[ln];
                if (!i || "view" === i.type) {
                    var n = t.getGraph();
                    n[C](function(t) {
                        var e = t[fr]();
                        t[ue]([ + e.get("x"), +e.get("y")])
                    }),
                    e(n)
                }
            }
        }),
        e("echarts/chart/graph/simpleLayoutEdge", [Tr, wr],
        function(t) {
            var e = t(wr);
            return function(t) {
                t.eachEdge(function(t) {
                    var i = t[fr]().get("lineStyle.normal.curveness") || 0,
                    n = e.clone(t.node1.getLayout()),
                    r = e.clone(t.node2.getLayout()),
                    a = [n, r]; + i && a.push([(n[0] + r[0]) / 2 - (n[1] - r[1]) * i, (n[1] + r[1]) / 2 - (r[0] - n[0]) * i]),
                    t[ue](a)
                })
            }
        }),
        e("echarts/component/axis/parallelAxisAction", [Tr, Ei],
        function(t) {
            var e = t(Ei),
            i = {
                type: "axisAreaSelect",
                event: "axisAreaSelected",
                update: "updateVisual"
            };
            e[Mn](i,
            function(t, e) {
                e[or]({
                    mainType: "parallelAxis",
                    query: t
                },
                function(e) {
                    e.axis.model.setActiveIntervals(t.intervals)
                })
            }),
            e[Mn]("parallelAxisExpand",
            function(t, e) {
                e[or]({
                    mainType: "parallel",
                    query: t
                },
                function(e) {
                    e.setAxisExpand(t)
                })
            })
        }),
        e("echarts/component/axis/ParallelAxisView", [Tr, Ar, "./AxisBuilder", "../helper/BrushController", Si, Ei],
        function(t) {
            function e(t, e, i) {
                return i && "axisAreaSelect" === i.type && e.findComponents({
                    mainType: "parallelAxis",
                    query: i
                })[0] === t
            }
            var i = t(Ar),
            r = t("./AxisBuilder"),
            a = t("../helper/BrushController"),
            o = t(Si),
            s = [x, g, m, u],
            l = t(Ei)[_n]({
                type: "parallelAxis",
                init: function(t, e) {
                    l[Oi](this, "init", arguments),
                    (this._brushController = new a(e.getZr())).on("brush", i.bind(this._onBrush, this))
                },
                render: function(t, n, a, l) {
                    if (!e(t, n, l)) {
                        this.axisModel = t,
                        this.api = a,
                        this.group[cn]();
                        var u = this._axisGroup;
                        if (this._axisGroup = new o.Group, this.group.add(this._axisGroup), t.get("show")) {
                            var c, h = n[Re]("parallel", t.get("parallelIndex"))[ln],
                            d = t.getAreaSelectStyle(),
                            f = d.width,
                            p = t.axis.dim,
                            v = h.getAxisLayout(p),
                            g = i[gn](h[de], p),
                            m = v.axisExpandWindow;
                            m && (g <= m[0] || g >= m[1]) && (c = !1);
                            var y = i[jn]({
                                axisLabelShow: c,
                                strokeContainThreshold: f
                            },
                            v),
                            x = new r(t, y);
                            i.each(s, x.add, x),
                            this._axisGroup.add(x.getGroup()),
                            this._refreshBrushController(y, d, t, f),
                            o.groupTransition(u, this._axisGroup, t)
                        }
                    }
                },
                _refreshBrushController: function(t, e, n, r) {
                    var a = n.axis,
                    o = i.map(n.activeIntervals,
                    function(t) {
                        return {
                            brushType: "lineX",
                            panelId: "pl",
                            range: [a[B](t[0], !0), a[B](t[1], !0)]
                        }
                    }),
                    s = a[Fi](),
                    l = 30,
                    u = {
                        x: s[0] - l,
                        y: -r / 2,
                        width: s[1] - s[0] + 2 * l,
                        height: r
                    };
                    this._brushController.mount({
                        enableGlobalPan: !0,
                        rotation: t[ni],
                        position: t[$i]
                    }).setPanels([{
                        panelId: "pl",
                        rect: u
                    }]).enableBrush({
                        brushType: "lineX",
                        brushStyle: e,
                        removeOnClick: !0
                    }).updateCovers(o)
                },
                _onBrush: function(t, e) {
                    var r = this.axisModel,
                    a = r.axis,
                    o = i.map(t,
                    function(t) {
                        return [a[n](t.range[0], !0), a[n](t.range[1], !0)]
                    }); (!r[zi].realtime === e.isEnd || e.removeOnClick) && this.api[Un]({
                        type: "axisAreaSelect",
                        parallelAxisId: r.id,
                        intervals: o
                    })
                },
                dispose: function() {
                    this._brushController[Hn]()
                }
            });
            return l
        }),
        e("echarts/chart/graph/circularLayoutHelper", [Tr, wr],
        function(t) {
            var e = t(wr);
            return function(t) {
                var i = t[ln];
                if (!i || "view" === i.type) {
                    var n = i[en](),
                    r = t[Kn](),
                    a = r.graph,
                    o = 0,
                    s = r.getSum("value"),
                    l = 2 * Math.PI / (s || r.count()),
                    u = n.width / 2 + n.x,
                    c = n[nr] / 2 + n.y,
                    h = Math.min(n.width, n[nr]) / 2;
                    a[C](function(t) {
                        var e = t.getValue("value");
                        o += l * (s ? e: 2) / 2,
                        t[ue]([h * Math.cos(o) + u, h * Math.sin(o) + c]),
                        o += l * (s ? e: 2) / 2
                    }),
                    r[ue]({
                        cx: u,
                        cy: c
                    }),
                    a.eachEdge(function(t) {
                        var i, n = t[fr]().get("lineStyle.normal.curveness") || 0,
                        r = e.clone(t.node1.getLayout()),
                        a = e.clone(t.node2.getLayout()),
                        o = (r[0] + a[0]) / 2,
                        s = (r[1] + a[1]) / 2; + n && (n *= 3, i = [u * n + o * (1 - n), c * n + s * (1 - n)]),
                        t[ue]([r, a, i])
                    })
                }
            }
        }),
        e("echarts/chart/graph/forceHelper", [Tr, wr],
        function(t) {
            var e = t(wr),
            i = e.scaleAndAdd;
            return function(t, n, r) {
                for (var a = r.rect,
                o = a.width,
                s = a[nr], l = [a.x + o / 2, a.y + s / 2], u = null == r.gravity ? .1 : r.gravity, c = 0; c < t[Wn]; c++) {
                    var h = t[c];
                    h.p || (h.p = e[ir](o * (Math.random() - .5) + l[0], s * (Math.random() - .5) + l[1])),
                    h.pp = e.clone(h.p),
                    h.edges = null
                }
                var d = .6;
                return {
                    warmUp: function() {
                        d = .5
                    },
                    setFixed: function(e) {
                        t[e].fixed = !0
                    },
                    setUnfixed: function(e) {
                        t[e].fixed = !1
                    },
                    step: function(r) {
                        for (var a = [], o = t[Wn], s = 0; s < n[Wn]; s++) {
                            var c = n[s],
                            h = c.n1,
                            f = c.n2;
                            e.sub(a, f.p, h.p);
                            var p = e.len(a) - c.d,
                            v = f.w / (h.w + f.w);
                            e[Ui](a, a),
                            !h.fixed && i(h.p, h.p, a, v * p * d),
                            !f.fixed && i(f.p, f.p, a, -(1 - v) * p * d)
                        }
                        for (var s = 0; o > s; s++) {
                            var g = t[s];
                            g.fixed || (e.sub(a, l, g.p), e.scaleAndAdd(g.p, g.p, a, u * d))
                        }
                        for (var s = 0; o > s; s++) for (var h = t[s], m = s + 1; o > m; m++) {
                            var f = t[m];
                            e.sub(a, f.p, h.p);
                            var p = e.len(a);
                            0 === p && (e.set(a, Math.random() - .5, Math.random() - .5), p = 1);
                            var y = (h.rep + f.rep) / p / p; ! h.fixed && i(h.pp, h.pp, a, y),
                            !f.fixed && i(f.pp, f.pp, a, -y)
                        }
                        for (var x = [], s = 0; o > s; s++) {
                            var g = t[s];
                            g.fixed || (e.sub(x, g.p, g.pp), e.scaleAndAdd(g.p, g.p, x, d), e.copy(g.pp, g.p))
                        }
                        d = .992 * d,
                        r && r(t, n, .01 > d)
                    }
                }
            }
        }),
        e("echarts/component/visualMap/typeDefaulter", [Tr, c],
        function(t) {
            t(c).registerSubTypeDefaulter("visualMap",
            function(t) {
                return t.categories || (t.pieces ? t.pieces[Wn] > 0 : t.splitNumber > 0) && !t.calculable ? "piecewise": "continuous"
            })
        }),
        e("echarts/component/visualMap/VisualMapModel", [Tr, Ei, Ar, Sr, "../../visual/visualDefault", "../../visual/VisualMapping", "../../visual/visualSolution", Bi, qe],
        function(t) {
            var e = t(Ei),
            i = t(Ar),
            n = t(Sr),
            r = t("../../visual/visualDefault"),
            a = t("../../visual/VisualMapping"),
            o = t("../../visual/visualSolution"),
            s = a.mapVisual,
            l = t(Bi),
            u = a.eachVisual,
            c = t(qe),
            h = i[An],
            d = i.each,
            f = c.asc,
            p = c[Ge],
            g = i.noop,
            m = ["#f6efa6", "#d88273", "#bf444c"],
            y = e[wn]({
                type: "visualMap",
                dependencies: [Fn],
                stateList: ["inRange", "outOfRange"],
                replacableOptionKeys: ["inRange", "outOfRange", Vn, "controller", "color"],
                dataBound: [ - 1 / 0, 1 / 0],
                layoutMode: {
                    type: "box",
                    ignoreSize: !0
                },
                defaultOption: {
                    show: !0,
                    zlevel: 0,
                    z: 4,
                    seriesIndex: null,
                    min: 0,
                    max: 200,
                    dimension: null,
                    inRange: null,
                    outOfRange: null,
                    left: 0,
                    right: null,
                    top: null,
                    bottom: 0,
                    itemWidth: null,
                    itemHeight: null,
                    inverse: !1,
                    orient: "vertical",
                    backgroundColor: "rgba(0,0,0,0)",
                    borderColor: "#ccc",
                    contentColor: "#5793f3",
                    inactiveColor: "#aaa",
                    borderWidth: 0,
                    padding: 5,
                    textGap: 10,
                    precision: 0,
                    color: null,
                    formatter: null,
                    text: null,
                    textStyle: {
                        color: "#333"
                    }
                },
                init: function(t, e, i) {
                    this._dataExtent,
                    this.targetVisuals = {},
                    this.controllerVisuals = {},
                    this.textStyleModel,
                    this.itemSize,
                    this[De](t, i)
                },
                optionUpdated: function(t, e) {
                    var i = this[zi];
                    n[cr] || (i.realtime = !1),
                    !e && o.replaceVisualOption(i, t, this.replacableOptionKeys),
                    this.textStyleModel = this[fr](on),
                    this.resetItemSize(),
                    this.completeVisualOption()
                },
                resetVisual: function(t) {
                    var e = this.stateList;
                    t = i.bind(t, this),
                    this.controllerVisuals = o.createVisualMappings(this[zi].controller, e, t),
                    this.targetVisuals = o.createVisualMappings(this[zi][Vn], e, t)
                },
                resetTargetSeries: function() {
                    var t = this[zi],
                    e = null == t[Dn];
                    t[Dn] = e ? [] : l.normalizeToArray(t[Dn]),
                    e && this[Te][tr](function(e, i) {
                        t[Dn].push(i)
                    })
                },
                eachTargetSeries: function(t, e) {
                    i.each(this[zi][Dn],
                    function(i) {
                        t.call(e, this[Te].getSeriesByIndex(i))
                    },
                    this)
                },
                isTargetSeries: function(t) {
                    var e = !1;
                    return this.eachTargetSeries(function(i) {
                        i === t && (e = !0)
                    }),
                    e
                },
                formatValueText: function(t, e, n) {
                    function r(t) {
                        return t === u[0] ? "min": t === u[1] ? "max": ( + t)[Ii](l)
                    }
                    var a, o, s = this[zi],
                    l = s.precision,
                    u = this.dataBound,
                    c = s[v];
                    return n = n || ["<", ">"],
                    i[An](t) && (t = t.slice(), a = !0),
                    o = e ? t: a ? [r(t[0]), r(t[1])] : r(t),
                    i[pn](c) ? c[Tn]("{value}", a ? o[0] : o)[Tn]("{value2}", a ? o[1] : o) : i.isFunction(c) ? a ? c(t[0], t[1]) : c(t) : a ? t[0] === u[0] ? n[0] + " " + o[1] : t[1] === u[1] ? n[1] + " " + o[0] : o[0] + " - " + o[1] : o
                },
                resetExtent: function() {
                    var t = this[zi],
                    e = f([t.min, t.max]);
                    this._dataExtent = e
                },
                getDataDimension: function(t) {
                    var e = this[zi].dimension;
                    return null != e ? e: t[de][Wn] - 1
                },
                getExtent: function() {
                    return this._dataExtent.slice()
                },
                completeVisualOption: function() {
                    function t(t) {
                        h(o.color) && !t.inRange && (t.inRange = {
                            color: o.color.slice()[S]()
                        }),
                        t.inRange = t.inRange || {
                            color: m
                        },
                        d(this.stateList,
                        function(e) {
                            var n = t[e];
                            if (i[pn](n)) {
                                var a = r.get(n, "active", v);
                                a ? (t[e] = {},
                                t[e][n] = a) : delete t[e]
                            }
                        },
                        this)
                    }
                    function e(t, e, i) {
                        var n = t[e],
                        o = t[i];
                        n && !o && (o = t[i] = {},
                        d(n,
                        function(t, e) {
                            if (a.isValidType(e)) {
                                var i = r.get(e, "inactive", v);
                                null != i && (o[e] = i, "color" !== e || o.hasOwnProperty(Yi) || o.hasOwnProperty("colorAlpha") || (o[Yi] = [0, 0]))
                            }
                        }))
                    }
                    function n(t) {
                        var e = (t.inRange || {})[se] || (t.outOfRange || {})[se],
                        n = (t.inRange || {})[oe] || (t.outOfRange || {})[oe],
                        r = this.get("inactiveColor");
                        d(this.stateList,
                        function(a) {
                            var o = this.itemSize,
                            l = t[a];
                            l || (l = t[a] = {
                                color: v ? r: [r]
                            }),
                            null == l[se] && (l[se] = e && i.clone(e) || (v ? "roundRect": ["roundRect"])),
                            null == l[oe] && (l[oe] = n && i.clone(n) || (v ? o[0] : [o[0], o[0]])),
                            l[se] = s(l[se],
                            function(t) {
                                return "none" === t || "square" === t ? "roundRect": t
                            });
                            var c = l[oe];
                            if (null != c) {
                                var h = -1 / 0;
                                u(c,
                                function(t) {
                                    t > h && (h = t)
                                }),
                                l[oe] = s(c,
                                function(t) {
                                    return p(t, [0, h], [0, o[0]], !0)
                                })
                            }
                        },
                        this)
                    }
                    var o = this[zi],
                    l = {
                        inRange: o.inRange,
                        outOfRange: o.outOfRange
                    },
                    c = o[Vn] || (o[Vn] = {}),
                    f = o.controller || (o.controller = {});
                    i.merge(c, l),
                    i.merge(f, l);
                    var v = this.isCategory();
                    t.call(this, c),
                    t.call(this, f),
                    e.call(this, c, "inRange", "outOfRange"),
                    n.call(this, f)
                },
                resetItemSize: function() {
                    this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))]
                },
                isCategory: function() {
                    return !! this[zi].categories
                },
                setSelected: g,
                getValueState: g
            });
            return y
        }),
        e("echarts/visual/visualDefault", [Tr, Ar],
        function(t) {
            var e = t(Ar),
            i = {
                get: function(t, i, r) {
                    var a = e.clone((n[t] || {})[i]);
                    return r && e[An](a) ? a[a[Wn] - 1] : a
                }
            },
            n = {
                color: {
                    active: ["#006edd", "#e0ffff"],
                    inactive: ["rgba(0,0,0,0)"]
                },
                colorHue: {
                    active: [0, 360],
                    inactive: [0, 0]
                },
                colorSaturation: {
                    active: [.3, 1],
                    inactive: [0, 0]
                },
                colorLightness: {
                    active: [.9, .5],
                    inactive: [0, 0]
                },
                colorAlpha: {
                    active: [.3, 1],
                    inactive: [0, 0]
                },
                opacity: {
                    active: [.3, 1],
                    inactive: [0, 0]
                },
                symbol: {
                    active: [fn, "roundRect", "diamond"],
                    inactive: ["none"]
                },
                symbolSize: {
                    active: [10, 50],
                    inactive: [0, 0]
                }
            };
            return i
        }),
        e("echarts/component/visualMap/helper", [Tr, re],
        function(t) {
            var e = t(re),
            i = {
                getItemAlign: function(t, i, n) {
                    var r = t[zi],
                    a = r.align;
                    if (null != a && "auto" !== a) return a;
                    for (var o = {
                        width: i[dr](),
                        height: i[hr]()
                    },
                    s = r[l] === O ? 1 : 0, u = [["left", "right", "width"], ["top", rr, nr]], c = u[s], h = [0, null, 10], d = {},
                    f = 0; 3 > f; f++) d[u[1 - s][f]] = h[f],
                    d[c[f]] = 2 === f ? n[0] : r[c[f]];
                    var p = [["x", "width", 3], ["y", nr, 0]][s],
                    v = e[Ki](d, o, r.padding);
                    return c[(v.margin[p[2]] || 0) + v[p[0]] + .5 * v[p[1]] < .5 * o[p[1]] ? 0 : 1]
                }
            };
            return i
        }),
        e("echarts/component/visualMap/VisualMapView", [Tr, Ar, Si, G, re, Ei, "../../visual/VisualMapping"],
        function(t) {
            var e = t(Ar),
            i = t(Si),
            n = t(G),
            r = t(re),
            a = t(Ei),
            o = t("../../visual/VisualMapping");
            return a[_n]({
                type: "visualMap",
                autoPositionValues: {
                    left: 1,
                    right: 1,
                    top: 1,
                    bottom: 1
                },
                init: function(t, e) {
                    this[Te] = t,
                    this.api = e,
                    this.visualMapModel
                },
                render: function(t) {
                    return this.visualMapModel = t,
                    t.get("show") === !1 ? void this.group[cn]() : void this.doRender.apply(this, arguments)
                },
                renderBackground: function(t) {
                    var e = this.visualMapModel,
                    r = n.normalizeCssArray(e.get("padding") || 0),
                    a = t[en]();
                    t.add(new i.Rect({
                        z2: -1,
                        silent: !0,
                        shape: {
                            x: a.x - r[3],
                            y: a.y - r[0],
                            width: a.width + r[3] + r[1],
                            height: a[nr] + r[0] + r[2]
                        },
                        style: {
                            fill: e.get(ur),
                            stroke: e.get(N),
                            lineWidth: e.get("borderWidth")
                        }
                    }))
                },
                getControllerVisual: function(t, i, n) {
                    function r(t) {
                        return u[t]
                    }
                    function a(t, e) {
                        u[t] = e
                    }
                    n = n || {};
                    var s = n.forceState,
                    l = this.visualMapModel,
                    u = {};
                    if (i === se && (u[se] = l.get("itemSymbol")), "color" === i) {
                        var c = l.get("contentColor");
                        u.color = c
                    }
                    var h = l.controllerVisuals[s || l.getValueState(t)],
                    d = o.prepareVisualTypes(h);
                    return e.each(d,
                    function(e) {
                        var s = h[e];
                        n.convertOpacityToAlpha && e === Yi && (e = "colorAlpha", s = h.__alphaForOpacity),
                        o.dependsOn(e, i) && s && s.applyVisual(t, r, a)
                    }),
                    u[i]
                },
                positionGroup: function(t) {
                    var e = this.visualMapModel,
                    i = this.api;
                    r.positionGroup(t, e[tn](), {
                        width: i[dr](),
                        height: i[hr]()
                    })
                },
                doRender: e.noop
            })
        }),
        e("echarts/component/visualMap/PiecewiseView", [Tr, "./VisualMapView", Ar, Si, I, re, "./helper"],
        function(t) {
            var e = t("./VisualMapView"),
            i = t(Ar),
            n = t(Si),
            r = t(I),
            a = t(re),
            o = t("./helper"),
            u = e[jn]({
                type: "visualMap.piecewise",
                doRender: function() {
                    function t(t) {
                        var a = t.piece,
                        s = new n.Group;
                        s.onclick = i.bind(this._onItemClick, this, a),
                        this._enableHoverLink(s, t.indexInModelPieceList);
                        var l = r.getRepresentValue(a);
                        if (this._createItemSymbol(s, l, [0, 0, d[0], d[1]]), p) {
                            var f = this.visualMapModel.getValueState(l);
                            s.add(new n.Text({
                                style: {
                                    x: "right" === h ? -o: d[0] + o,
                                    y: d[1] / 2,
                                    text: a.text,
                                    textVerticalAlign: "middle",
                                    textAlign: h,
                                    textFont: u,
                                    fill: c,
                                    opacity: "outOfRange" === f ? .5 : 1
                                }
                            }))
                        }
                        e.add(s)
                    }
                    var e = this.group;
                    e[cn]();
                    var r = this.visualMapModel,
                    o = r.get("textGap"),
                    s = r.textStyleModel,
                    u = s[rn](),
                    c = s[nn](),
                    h = this._getItemAlign(),
                    d = r.itemSize,
                    f = this._getViewData(),
                    p = !f.endsText,
                    v = !p;
                    v && this._renderEndsText(e, f.endsText[0], d),
                    i.each(f.viewPieceList, t, this),
                    v && this._renderEndsText(e, f.endsText[1], d),
                    a.box(r.get(l), e, r.get("itemGap")),
                    this.renderBackground(e),
                    this.positionGroup(e)
                },
                _enableHoverLink: function(t, e) {
                    function n(t) {
                        var i = this.visualMapModel;
                        i[zi].hoverLink && this.api[Un]({
                            type: t,
                            batch: i.findTargetDataIndices(e)
                        })
                    }
                    t.on(En, i.bind(n, this, Jn)).on(On, i.bind(n, this, $n))
                },
                _getItemAlign: function() {
                    var t = this.visualMapModel,
                    e = t[zi];
                    if (e[l] === s) return o.getItemAlign(t, this.api, t.itemSize);
                    var i = e.align;
                    return i && "auto" !== i || (i = "left"),
                    i
                },
                _renderEndsText: function(t, e, i) {
                    if (e) {
                        var r = new n.Group,
                        a = this.visualMapModel.textStyleModel;
                        r.add(new n.Text({
                            style: {
                                x: i[0] / 2,
                                y: i[1] / 2,
                                textVerticalAlign: "middle",
                                textAlign: "center",
                                text: e,
                                textFont: a[rn](),
                                fill: a[nn]()
                            }
                        })),
                        t.add(r)
                    }
                },
                _getViewData: function() {
                    var t = this.visualMapModel,
                    e = i.map(t.getPieceList(),
                    function(t, e) {
                        return {
                            piece: t,
                            indexInModelPieceList: e
                        }
                    }),
                    n = t.get("text"),
                    r = t.get(l),
                    a = t.get(Q);
                    return (r === O ? a: !a) ? e[S]() : n && (n = n.slice()[S]()),
                    {
                        viewPieceList: e,
                        endsText: n
                    }
                },
                _createItemSymbol: function(t, e, i) {
                    t.add(r[P](this.getControllerVisual(e, se), i[0], i[1], i[2], i[3], this.getControllerVisual(e, "color")))
                },
                _onItemClick: function(t) {
                    var e = this.visualMapModel,
                    n = e[zi],
                    r = i.clone(n[ai]),
                    a = e.getSelectedMapKey(t);
                    "single" === n.selectedMode ? (r[a] = !0, i.each(r,
                    function(t, e) {
                        r[e] = e === a
                    })) : r[a] = !r[a],
                    this.api[Un]({
                        type: "selectDataRange",
                        from: this.uid,
                        visualMapId: this.visualMapModel.id,
                        selected: r
                    })
                }
            });
            return u
        }),
        e("echarts/component/visualMap/PiecewiseModel", [Tr, "./VisualMapModel", Ar, "../../visual/VisualMapping"],
        function(t) {
            function e(t, e) {
                var i = t[Q]; (t[l] === s ? !i: i) && e[S]()
            }
            function i(t) {
                function e(t, i, n) {
                    return n = n || 0,
                    t[R][n] < i[R][n] || t[R][n] === i[R][n] && ( + t.close[n] > i.close[n] || e(t, i, 1))
                }
                t.sort(function(t, i) {
                    return e(t, i) ? -1 : 1
                });
                for (var i = -1 / 0,
                n = 0; n < t[Wn]; n++) for (var r = t[n][R], a = t[n].close, o = 0; 2 > o; o++) r[o] < i && (r[o] = i, a[o] = 1 - o),
                i = r[o]
            }
            var n = t("./VisualMapModel"),
            r = t(Ar),
            a = t("../../visual/VisualMapping"),
            o = n[jn]({
                type: "visualMap.piecewise",
                defaultOption: {
                    selected: null,
                    align: "auto",
                    itemWidth: 20,
                    itemHeight: 14,
                    itemSymbol: "roundRect",
                    pieceList: null,
                    categories: null,
                    splitNumber: 5,
                    selectedMode: "multiple",
                    itemGap: 10,
                    hoverLink: !0
                },
                optionUpdated: function(t, e) {
                    o[Oi](this, "optionUpdated", arguments),
                    this._pieceList = [],
                    this.resetTargetSeries(),
                    this.resetExtent();
                    var i = this._mode = this._determineMode();
                    u[this._mode].call(this),
                    this._resetSelected(t, e);
                    var n = this[zi].categories;
                    this.resetVisual(function(t, e) {
                        "categories" === i ? (t.mappingMethod = te, t.categories = r.clone(n)) : (t.dataExtent = this[Fi](), t.mappingMethod = "piecewise", t.pieceList = r.map(this._pieceList,
                        function(t) {
                            var t = r.clone(t);
                            return "inRange" !== e && (t.visual = null),
                            t
                        }))
                    })
                },
                _resetSelected: function(t, e) {
                    var i = this[zi],
                    n = this._pieceList,
                    a = (e ? i: t)[ai] || {};
                    if (i[ai] = a, r.each(n,
                    function(t) {
                        var e = this.getSelectedMapKey(t);
                        e in a || (a[e] = !0)
                    },
                    this), "single" === i.selectedMode) {
                        var o = !1;
                        r.each(n,
                        function(t) {
                            var e = this.getSelectedMapKey(t);
                            a[e] && (o ? a[e] = !1 : o = !0)
                        },
                        this)
                    }
                },
                getSelectedMapKey: function(t) {
                    return "categories" === this._mode ? t.value + "": t.index + ""
                },
                getPieceList: function() {
                    return this._pieceList
                },
                _determineMode: function() {
                    var t = this[zi];
                    return t.pieces && t.pieces[Wn] > 0 ? "pieces": this[zi].categories ? "categories": "splitNumber"
                },
                setSelected: function(t) {
                    this[zi][ai] = r.clone(t)
                },
                getValueState: function(t) {
                    var e = a.findPieceIndex(t, this._pieceList);
                    return null != e && this[zi][ai][this.getSelectedMapKey(this._pieceList[e])] ? "inRange": "outOfRange"
                },
                findTargetDataIndices: function(t) {
                    var e = [];
                    return this.eachTargetSeries(function(i) {
                        var n = [],
                        r = i[Kn]();
                        r.each(this.getDataDimension(r),
                        function(e, i) {
                            var r = a.findPieceIndex(e, this._pieceList);
                            r === t && n.push(i)
                        },
                        !0, this),
                        e.push({
                            seriesId: i.id,
                            dataIndex: n
                        })
                    },
                    this),
                    e
                },
                getRepresentValue: function(t) {
                    var e;
                    if (this.isCategory()) e = t.value;
                    else if (null != t.value) e = t.value;
                    else {
                        var i = t[R] || [];
                        e = (i[0] + i[1]) / 2
                    }
                    return e
                },
                getStops: function(t, e) {
                    function i(t) {
                        n.push(t),
                        t.color = e(a, a.getRepresentValue(t), t.valueState)
                    }
                    var n = [],
                    a = this,
                    o = -1 / 0;
                    return r.each(this._pieceList,
                    function(t) {
                        var e = t[R];
                        e && (e[0] > o && i({
                            interval: [o, e[0]],
                            valueState: "outOfRange"
                        }), i({
                            interval: e.slice(),
                            valueState: this.getValueState((e[0] + e[1]) / 2)
                        }), o = e[1])
                    },
                    this),
                    n
                }
            }),
            u = {
                splitNumber: function() {
                    var t = this[zi],
                    e = this._pieceList,
                    n = t.precision,
                    a = this[Fi](),
                    o = t.splitNumber;
                    o = Math.max(parseInt(o, 10), 1),
                    t.splitNumber = o;
                    for (var s = (a[1] - a[0]) / o; + s[Ii](n) !== s && 5 > n;) n++;
                    t.precision = n,
                    s = +s[Ii](n);
                    for (var l = 0,
                    u = a[0]; o > l; l++, u += s) {
                        var c = l === o - 1 ? a[1] : u + s;
                        e.push({
                            index: l,
                            interval: [u, c],
                            close: [1, 1]
                        })
                    }
                    i(e),
                    r.each(e,
                    function(t) {
                        t.text = this.formatValueText(t[R])
                    },
                    this)
                },
                categories: function() {
                    var t = this[zi];
                    r.each(t.categories,
                    function(t) {
                        this._pieceList.push({
                            text: this.formatValueText(t, !0),
                            value: t
                        })
                    },
                    this),
                    e(t, this._pieceList)
                },
                pieces: function() {
                    var t = this[zi],
                    n = this._pieceList;
                    r.each(t.pieces,
                    function(t, e) {
                        r[Yn](t) || (t = {
                            value: t
                        });
                        var i = {
                            text: "",
                            index: e
                        };
                        if (null != t.label && (i.text = t.label), t.hasOwnProperty("value")) {
                            var o = i.value = t.value;
                            i[R] = [o, o],
                            i.close = [1, 1]
                        } else {
                            for (var s = i[R] = [], l = i.close = [0, 0], u = [1, 0, 1], c = [ - 1 / 0, 1 / 0], h = [], d = 0; 2 > d; d++) {
                                for (var f = [["gte", "gt", "min"], ["lte", "lt", "max"]][d], p = 0; 3 > p && null == s[d]; p++) s[d] = t[f[p]],
                                l[d] = u[p],
                                h[d] = 2 === p;
                                null == s[d] && (s[d] = c[d])
                            }
                            h[0] && 1 / 0 === s[1] && (l[0] = 0),
                            h[1] && s[0] === -1 / 0 && (l[1] = 0),
                            s[0] === s[1] && l[0] && l[1] && (i.value = s[0])
                        }
                        i.visual = a.retrieveVisuals(t),
                        n.push(i)
                    },
                    this),
                    e(t, n),
                    i(n),
                    r.each(n,
                    function(t) {
                        var e = t.close,
                        i = [["<", "≤"][e[1]], [">", "≥"][e[0]]];
                        t.text = t.text || this.formatValueText(null != t.value ? t.value: t[R], !1, i)
                    },
                    this)
                }
            };
            return o
        }),
        e("zrender", ["zrender/zrender"],
        function(t) {
            return t
        }),
        e("echarts", ["echarts/echarts"],
        function(t) {
            return t
        });
        var Cr = t("echarts");
        return Cr.graphic = t("echarts/util/graphic"),
        Cr.number = t("echarts/util/number"),
        Cr.format = t("echarts/util/format"),
        t("echarts/chart/bar"),
        t("echarts/chart/line"),
        t("echarts/chart/pie"),
        t("echarts/chart/scatter"),
        t("echarts/chart/candlestick"),
        t("echarts/chart/radar"),
        t("echarts/chart/heatmap"),
        t("echarts/chart/treemap"),
        t("echarts/chart/map"),
        t("echarts/chart/lines"),
        t("echarts/chart/graph"),
        t("echarts/chart/boxplot"),
        t("echarts/chart/parallel"),
        t("echarts/chart/gauge"),
        t("echarts/chart/funnel"),
        t("echarts/chart/sankey"),
        t("echarts/chart/effectScatter"),
        t("echarts/component/grid"),
        t("echarts/component/polar"),
        t("echarts/component/geo"),
        t("echarts/component/singleAxis"),
        t("echarts/component/title"),
        t("echarts/component/legend"),
        t("echarts/component/tooltip"),
        t("echarts/component/markPoint"),
        t("echarts/component/markLine"),
        t("echarts/component/markArea"),
        t("echarts/component/timeline"),
        t("echarts/component/dataZoom"),
        t("echarts/component/brush"),
        t("echarts/component/visualMap"),
        t("echarts/component/toolbox"),
        t("zrender/vml/vml"),
        Cr
    });